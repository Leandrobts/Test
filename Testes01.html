<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Vetores Core DOM</title>
</head>
<body>
    <h1>Testes de Corrupção WebCore - Lote 3</h1>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }

        // Teste 11: MutationObserver e Destruição Síncrona
        // Os MutationObservers acionam microtasks no motor JSC. Alterar a árvore 
        // durante o processamento de registros pode induzir o WebCore a acessar nós já liberados.
        function test11() {
            logMsg("Iniciando Teste 11 (MutationObserver Race)...");
            try {
                let div = document.createElement("div");
                document.body.appendChild(div);
                
                let observer = new MutationObserver((records) => {
                    // Tenta acessar o nó e forçar uma re-renderização enquanto ele é destruído
                    div.innerHTML = "trigger";
                    div.remove(); 
                });
                
                observer.observe(div, { attributes: true, childList: true, subtree: true });
                div.setAttribute("id", "fuzz"); // Dispara o observer
            } catch(e) {}
            logMsg("Fim do Teste 11.");
        }

        // Teste 12: Ciclo de Vida de Objetos Embutidos (<object>)
        // Elementos <object> possuem rotinas pesadas de inicialização no C++ para checar plugins.
        // Interromper esse processo pode vazar a estrutura ou causar Use-After-Free.
        function test12() {
            logMsg("Iniciando Teste 12 (Object Tag Lifecycle UAF)...");
            try {
                let obj = document.createElement("object");
                document.body.appendChild(obj);
                
                // Define um tipo/dados e imediatamente corta a referência da árvore DOM
                obj.type = "text/html";
                obj.data = "about:blank";
                
                // Spray básico no FastMalloc
                let spray = new Array(2000).fill(new ArrayBuffer(512));
                
                obj.remove(); 
            } catch(e) {}
            logMsg("Fim do Teste 12.");
        }

        // Teste 13: Canvas 2D com ArrayBuffer Desanexado (Detached Buffer)
        // Usa a API tradicional do Canvas (sem WebGL) acoplada a um ArrayBuffer.
        // O buffer é transferido (desanexado) via MessageChannel antes da renderização.
        function test13() {
            logMsg("Iniciando Teste 13 (Canvas 2D Detached Buffer)...");
            try {
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                let imgData = ctx.createImageData(100, 100);
                
                let channel = new MessageChannel();
                // Transfere a propriedade do buffer, invalidando-o no contexto atual
                channel.port1.postMessage(imgData.data.buffer, [imgData.data.buffer]);
                
                // O WebCore tentará ler os dados de imagem de um ponteiro que não lhe pertence mais
                ctx.putImageData(imgData, 0, 0);
            } catch(e) {}
            logMsg("Fim do Teste 13.");
        }

        // Teste 14: Race Condition em Rede Local (Blob e XHR)
        // Cria um recurso em memória, inicia uma requisição assíncrona para ele,
        // e destrói o recurso imediatamente.
        function test14() {
            logMsg("Iniciando Teste 14 (Blob Revoke Race)...");
            try {
                let blob = new Blob(["A".repeat(1024 * 1024)], {type: "text/plain"});
                let url = URL.createObjectURL(blob);
                
                let xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.send();
                
                // Revoga o ponteiro do Blob enquanto a thread de rede do WebKit tenta acessá-lo
                URL.revokeObjectURL(url);
                blob = null;
            } catch(e) {}
            logMsg("Fim do Teste 14.");
        }

        // Teste 15: Corrupção da API de Seleção (Selection & Range)
        // A API de seleção no WebCore frequentemente sofre bugs de limites (OOB) quando
        // os nós selecionados são removidos dinamicamente da árvore DOM.
        function test15() {
            logMsg("Iniciando Teste 15 (Selection API OOB)...");
            try {
                let p = document.createElement("p");
                p.innerText = "Fuzzing";
                document.body.appendChild(p);
                
                let selection = window.getSelection();
                let range = document.createRange();
                range.selectNodeContents(p);
                selection.addRange(range);
                
                // Remove o nó selecionado
                p.remove();
                
                // Tenta interagir com a seleção que aponta para o nó órfão
                selection.collapseToEnd();
            } catch(e) {}
            logMsg("Fim do Teste 15.");
        }

        // Execução Sequencial
        setTimeout(() => { test11(); }, 500);
        setTimeout(() => { test12(); }, 1500);
        setTimeout(() => { test13(); }, 2500);
        setTimeout(() => { test14(); }, 3500);
        setTimeout(() => { test15(); }, 4500);

    </script>
</body>
</html>
