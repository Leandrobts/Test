<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Vetores Avancados</title>
</head>
<body>
    <h1>Testes de Corrupção WebCore - Lote 2</h1>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }

        // Teste 6: WebGL OOB (Out-of-Bounds)
        // Força a alocação de buffers gráficos anômalos para estressar a camada ANGLE/Metal do navegador[cite: 91, 94].
        function test6() {
            logMsg("Iniciando Teste 6 (WebGL OOB)...");
            try {
                let canvas = document.createElement("canvas");
                let gl = canvas.getContext("webgl");
                if (gl) {
                    let buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    // Tenta alocar um tamanho anômalo para desestabilizar o mapeamento de memória em C++
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(1024), gl.STATIC_DRAW);
                    gl.deleteBuffer(buffer);
                    // Tenta forçar o uso do buffer recém-liberado no backend gráfico
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(10)); 
                }
            } catch(e) {}
            logMsg("Fim do Teste 6.");
        }

        // Teste 7: MessageChannel Race Condition
        // Explora a transferência de portas de comunicação assíncronas enquanto a memória é limpa.
        function test7() {
            logMsg("Iniciando Teste 7 (MessageChannel Race)...");
            try {
                let channel = new MessageChannel();
                let port1 = channel.port1;
                
                port1.onmessage = function(e) {
                    // Tenta acessar a porta durante o processamento da mensagem
                    port1.close();
                };
                
                // Transfere a porta e imediatamente tenta invalidá-la
                window.postMessage("trigger", "*", [channel.port2]);
                channel = null; 
            } catch(e) {}
            logMsg("Fim do Teste 7.");
        }

        // Teste 8: Custom Elements & Shadow DOM UAF
        // Brinca com o ciclo de vida (callbacks) de elementos customizados ao serem desconectados abruptamente.
        function test8() {
            logMsg("Iniciando Teste 8 (Shadow DOM UAF)...");
            try {
                class FuzzElement extends HTMLElement {
                    disconnectedCallback() {
                        // O elemento foi removido, mas tentamos reanexá-lo ou modificar seu Shadow Root a partir do limbo
                        this.attachShadow({mode: 'open'}).innerHTML = "dangling root";
                    }
                }
                customElements.define('fuzz-el', FuzzElement);
                
                let el = document.createElement('fuzz-el');
                document.body.appendChild(el);
                el.remove(); // Dispara o disconnectedCallback assincronamente no WebCore
            } catch(e) {}
            logMsg("Fim do Teste 8.");
        }

        // Teste 9: WeakMap e Anomalia de Garbage Collection (GC)
        // Oculta a referência de um nó DOM em um WeakMap e força um spray no Heap para confundir o coletor.
        function test9() {
            logMsg("Iniciando Teste 9 (WeakMap GC)...");
            try {
                let map = new WeakMap();
                let node = document.createElement("span");
                map.set(node, new ArrayBuffer(1024 * 1024)); // Aloca 1MB atrelado ao nó
                
                node.remove(); // Remove do DOM
                node = null;   // Remove a referência principal
                
                // Spray forçado para acionar o fastMalloc e o GC simultaneamente [cite: 73]
                let spray = [];
                for(let i = 0; i < 10000; i++) {
                    spray.push(new String("spray").repeat(100));
                }
            } catch(e) {}
            logMsg("Fim do Teste 9.");
        }

        // Teste 10: Range API e Deleção de Texto Síncrona
        // O objeto Range do WebKit é notoriamente sensível quando os nós subjacentes são deletados sob ele.
        function test10() {
            logMsg("Iniciando Teste 10 (Range API OOB/UAF)...");
            try {
                let textNode = document.createTextNode("Vulnerabilidade WebCore");
                document.body.appendChild(textNode);
                
                let range = document.createRange();
                range.setStart(textNode, 5);
                range.setEnd(textNode, 15);
                
                // Deleta o nó que serve de fundação para o Range
                textNode.remove();
                
                // Tenta extrair o conteúdo de uma região de memória que não pertence mais ao DOM ativo
                let fragment = range.extractContents(); 
            } catch(e) {}
            logMsg("Fim do Teste 10.");
        }

        // Execução Sequencial com espaçamento para evitar acúmulo no loop de eventos
        setTimeout(() => { test6(); }, 500);
        setTimeout(() => { test7(); }, 1500);
        setTimeout(() => { test8(); }, 2500);
        setTimeout(() => { test9(); }, 3500);
        setTimeout(() => { test10(); }, 4500);

    </script>
</body>
</html>
