<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Test 11 - MutationObserver Race (Instrumented)</title>
<style>
  body { font-family: monospace; background:#111; color:#0f0; }
  .warn { color: yellow; }
  .err { color: red; }
</style>
</head>
<body>

<h2>MutationObserver Race – Instrumented</h2>
<pre id="log"></pre>

<script>
function log(msg, cls="") {
    const el = document.getElementById("log");
    const span = document.createElement("div");
    if (cls) span.className = cls;
    span.textContent = "[" + performance.now().toFixed(2) + "] " + msg;
    el.appendChild(span);
}

function runTest() {
    log("Iniciando Teste 11 Instrumentado...");

    let div = document.createElement("div");
    div.id = "target";
    document.body.appendChild(div);

    let callbackCount = 0;
    let maxDepth = 0;
    let inCallback = false;
    let mutationRecordsTotal = 0;
    let detachedAccessDetected = false;

    let observer = new MutationObserver((records) => {

        callbackCount++;
        mutationRecordsTotal += records.length;

        if (inCallback) {
            log("REENTRÂNCIA detectada!", "warn");
        }

        inCallback = true;
        maxDepth++;

        log("Callback #" + callbackCount + 
            " | records=" + records.length + 
            " | totalRecords=" + mutationRecordsTotal);

        try {

            // Sanity check 1: acessar nó após possível remoção
            if (!div.isConnected) {
                log("Nó já desconectado do DOM", "warn");
            }

            // Força mutação interna
            div.innerHTML = "trigger_" + callbackCount;

            // Remove nó (potencial ponto crítico)
            div.remove();

            // Sanity check 2: tentar acessar após remoção
            try {
                let x = div.innerHTML;
                if (div.isConnected === false) {
                    detachedAccessDetected = true;
                    log("Acesso a nó removido realizado", "warn");
                }
            } catch(e) {
                log("Erro ao acessar nó removido: " + e, "err");
            }

        } catch(e) {
            log("Erro interno no callback: " + e, "err");
        }

        inCallback = false;

        // Limite de segurança
        if (callbackCount > 50) {
            log("Loop excessivo detectado. Desconectando observer.", "err");
            observer.disconnect();
        }
    });

    observer.observe(div, {
        attributes: true,
        childList: true,
        subtree: true
    });

    // Disparo inicial
    div.setAttribute("data-test", "start");

    // Watchdog para detectar travamento
    setTimeout(() => {
        log("Watchdog 2s executado.");
        log("Resumo:");
        log("Total callbacks: " + callbackCount);
        log("Total mutation records: " + mutationRecordsTotal);
        log("Max depth: " + maxDepth);
        log("Detached access detected: " + detachedAccessDetected);

        if (callbackCount === 0) {
            log("Observer não disparou.", "warn");
        }

        if (callbackCount > 20) {
            log("Possível microtask loop.", "warn");
        }

        log("Fim do Teste.");
    }, 2000);
}

window.onload = runTest;
</script>

</body>
</html>
