
<!DOCTYPE html>
<meta charset="utf-8">
<title>PS4 T8 Recheck — DROP Confirm + Post-Detach DataView Oracle (Minimal)</title>

<h3>PS4 T8 Recheck — DROP Confirm + Post-Detach DataView Oracle (Minimal)</h3>

<button id="run">RUN AUTO</button>
<button id="stop">STOP</button>
<button id="reset">Reset log</button>

<div>
  N: <input id="N" type="number" value="60" min="1" step="1">
  fastTimeout(ms): <input id="fast" type="number" value="2" min="0" step="1">
  lateWait(ms): <input id="late" type="number" value="1500" min="0" step="50">
  delay(ms): <input id="delay" type="number" value="30" min="0" step="5">
  pressure(0..3): <input id="p" type="number" value="1" min="0" max="3" step="1">
</div>

<pre id="log"></pre>

<script>
(() => {
  "use strict";
  const $log = document.getElementById("log");
  const $N = document.getElementById("N");
  const $fast = document.getElementById("fast");
  const $late = document.getElementById("late");
  const $delay = document.getElementById("delay");
  const $p = document.getElementById("p");

  let STOP = false;

  const ts = () => Date.now();
  const logLine = (s) => ($log.textContent += `[${ts()}] ${s}\n`);
  const reset = () => { $log.textContent = ""; logLine("Reset."); };
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const j = (x) => { try { return JSON.stringify(x); } catch(e){ return String(x); } };

  function pressure(level){
    // 0..3: bem controlado (não DoS)
    if (!level) return null;
    const chunks = [0, 24, 48, 72][level];
    const size   = [0, 0x6000, 0x8000, 0xA000][level];
    const keep = [];
    for (let i=0;i<chunks;i++){
      const ab = new ArrayBuffer(size);
      const u8 = new Uint8Array(ab);
      u8[0] = i & 0xFF;
      u8[u8.length-1] = (i*13) & 0xFF;
      keep.push(u8);
    }
    return keep;
  }

  async function runOnce(i, cfg, stats, samples){
    const ch = new MessageChannel();

    // Victim
    const ab = new ArrayBuffer(4096);
    const u8 = new Uint8Array(ab);
    const dv = new DataView(ab);
    u8[0] = 0xAA;

    let got = undefined;
    let gotAt = 0;

    ch.port2.onmessage = (ev) => { got = ev.data; gotAt = ts(); };

    // Transfer
    try {
      ch.port1.postMessage(ab, [ab]);
    } catch(e){
      stats.post_throw++;
      if (samples.post_throw.length < 3) samples.post_throw.push({i, err: (e&&e.name)||"ERR"});
      return;
    }

    // FAST WAIT (para reproduzir “drop_fast”)
    if (cfg.fastTimeoutMs > 0) await sleep(cfg.fastTimeoutMs);

    const senderLenFast = ab.byteLength;
    const gotFast = !(got === undefined || got === null);

    if (senderLenFast === 0 && !gotFast) {
      stats.drop_fast++;
    }

    // LATE WAIT (confirmar se era só entrega atrasada)
    if (cfg.lateWaitMs > 0) await sleep(cfg.lateWaitMs);

    const senderLen = ab.byteLength;
    const gotLate = !(got === undefined || got === null);

    // Classificações base
    if (senderLen === 0 && gotLate) {
      stats.detach_ok++;
    } else if (senderLen === 0 && !gotLate) {
      // DROP CONFIRMADO: detached + nada chegou mesmo depois do late wait
      stats.drop_confirmed++;
      if (samples.drop_confirmed.length < 3) {
        samples.drop_confirmed.push({i, senderLen, gotType: (got === null ? "null" : "undefined")});
      }

      // sanity: canal ainda funciona? (fila pós-drop)
      const q = [];
      ch.port2.onmessage = (ev) => q.push(ev.data);
      try { ch.port1.postMessage({k:1}); ch.port1.postMessage({k:2}); ch.port1.postMessage({k:3}); } catch(e){}

      await sleep(50);

      const ok = (q.length === 3 && q[0]?.k===1 && q[1]?.k===2 && q[2]?.k===3);
      if (ok) stats.queue_ok++;
      else {
        stats.queue_bad++;
        if (samples.queue_bad.length < 3) samples.queue_bad.push({i, gotCount:q.length, first:q[0]?.k});
      }
      return;
    } else if (senderLen === 4096 && gotLate) {
      stats.no_detach_or_clone++;
      return;
    } else if (senderLen !== 0 && senderLen !== 4096) {
      stats.sender_impossible++;
      if (samples.sender_impossible.length < 3) samples.sender_impossible.push({i, senderLen});
      return;
    } else {
      stats.other++;
      return;
    }

    // A partir daqui: detach_ok
    // Oracle forte: DataView pós-detach deve lançar (em engines corretas).
    let dvOK = false, dvErr = null, dvVal = null;
    try { dvVal = dv.getUint8(0); dvOK = true; }
    catch(e){ dvErr = (e && e.name) ? e.name : "ERR"; }

    // TypedArray index normalmente vira undefined (sem throw). Isso não é “bug” sozinho.
    let taVal = null, taThrew = false;
    try { taVal = u8[0]; } catch(e){ taThrew = true; }

    // Invariantes do view
    const inv = {
      abLen: ab.byteLength,
      u8Len: u8.length,
      u8ByteLen: u8.byteLength
    };

    // Se DataView leu após detach, isso é “hot” (bem melhor que u8[0]).
    if (dvOK) {
      stats.dv_read_after_detach++;
      if (samples.dv_read_after_detach.length < 3) {
        samples.dv_read_after_detach.push({i, dvVal, taVal, taThrew, inv});
      }
    } else {
      stats.dv_throw_after_detach++;
    }

    // Pressão leve e recheck (só para “changed without write”, se existir)
    const keep = pressure(cfg.pressure);
    await Promise.resolve();

    if (dvOK) {
      // re-leitura: mudou sem write?
      let dvOK2=false, dvVal2=null;
      try { dvVal2 = dv.getUint8(0); dvOK2 = true; } catch(e){}
      if (dvOK2 && dvVal2 !== dvVal) {
        stats.dv_changed_no_write++;
        if (samples.dv_changed_no_write.length < 3) {
          samples.dv_changed_no_write.push({i, before:dvVal, after:dvVal2, inv});
        }
      }
    }

    if (keep && keep.length) keep[0][0] ^= 0;
  }

  async function runAuto(){
    STOP = false;

    const cfg = {
      N: Math.max(1, parseInt($N.value||"60",10)),
      fastTimeoutMs: Math.max(0, parseInt($fast.value||"2",10)),
      lateWaitMs: Math.max(0, parseInt($late.value||"1500",10)),
      delayMs: Math.max(0, parseInt($delay.value||"30",10)),
      pressure: Math.max(0, Math.min(3, parseInt($p.value||"1",10)))
    };

    logLine(`RUN AUTO :: N=${cfg.N} fast=${cfg.fastTimeoutMs}ms late=${cfg.lateWaitMs}ms delay=${cfg.delayMs}ms pressure=${cfg.pressure}`);

    const stats = {
      detach_ok: 0,
      drop_fast: 0,
      drop_confirmed: 0,
      post_throw: 0,
      sender_impossible: 0,
      no_detach_or_clone: 0,
      other: 0,

      queue_ok: 0,
      queue_bad: 0,

      dv_throw_after_detach: 0,
      dv_read_after_detach: 0,
      dv_changed_no_write: 0
    };

    const samples = {
      drop_confirmed: [],
      queue_bad: [],
      sender_impossible: [],
      post_throw: [],
      dv_read_after_detach: [],
      dv_changed_no_write: []
    };

    for (let i=0;i<cfg.N;i++){
      if (STOP) break;
      await runOnce(i, cfg, stats, samples);
      if ((i+1) % 10 === 0) logLine(`progress: ${i+1}/${cfg.N}`);
      if (cfg.delayMs) await sleep(cfg.delayMs);
    }

    logLine("RESULT SUMMARY:");
    logLine(j(stats));

    const hot = [];
    if (samples.dv_read_after_detach.length) hot.push({kind:"DV_READ_AFTER_DETACH", samples: samples.dv_read_after_detach});
    if (samples.dv_changed_no_write.length) hot.push({kind:"DV_CHANGED_NO_WRITE", samples: samples.dv_changed_no_write});
    if (samples.drop_confirmed.length) hot.push({kind:"DROP_CONFIRMED", samples: samples.drop_confirmed});
    if (samples.queue_bad.length) hot.push({kind:"QUEUE_BAD_AFTER_DROP", samples: samples.queue_bad});
    if (samples.sender_impossible.length) hot.push({kind:"SENDER_LEN_IMPOSSIBLE", samples: samples.sender_impossible});
    if (samples.post_throw.length) hot.push({kind:"POST_THROW", samples: samples.post_throw});

    if (hot.length) {
      logLine("HOT SAMPLES:");
      logLine(j(hot));
    }

    logLine("DONE.");
  }

  document.getElementById("run").onclick = () => runAuto().catch(e => logLine("ERR: " + ((e&&e.name)||String(e))));
  document.getElementById("stop").onclick = () => { STOP = true; logLine("STOP requested."); };
  document.getElementById("reset").onclick = reset;

  reset();
})();
</script>
