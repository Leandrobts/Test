<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 45 — structuredClone Cyclic + Backing Store Leak</title></head>
<body>
<h2>TEST 45 — structuredClone Cyclic Bug + Pointer Leak via Copy Inconsistency</h2>

<p><b>Base:</b> TEST 31-B confirmou que <code>structuredClone(ciclico)</code> <b>não lançou</b> excecão
   — violação da spec (deve lançar DataCloneError).</p>
<p><b>Hipótese:</b> O clone de um objeto cíclico pode ter estruturas internas inconsistentes
   que expõem ponteiros de heap.</p>

<p><b>Sub-testes:</b></p>
<ul>
  <li><b>45-A</b> structuredClone de objeto cíclico com TypedArray — o clone compartilha backing store?</li>
  <li><b>45-B</b> Modificar o original após clone — o clone reflete? (shared backing store = UAF potencial)</li>
  <li><b>45-C</b> Clone de objeto cíclico com getter definido — o getter é preservado? (prototype chain confusion)</li>
  <li><b>45-D</b> Combinar: cyclic + TypedArray transfer + structuredClone para criar estado inconsistente</li>
</ul>

<pre id="log">Pronto. Execute A → B → C → D.</pre>
<button onclick="runA()">45-A: CLONE TYPEDARRAY</button>
<button onclick="runB()">45-B: SHARED BACKING STORE?</button>
<button onclick="runC()">45-C: GETTER NO CLONE</button>
<button onclick="runD()">45-D: CLONE + TRANSFER</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }
function forceGC() {
  var t=[]; for(var i=0;i<80000;i++) t.push({x:i,b:new Uint8Array(4)}); t=null;
}
function f64bits(val) {
  var buf=new ArrayBuffer(8); new Float64Array(buf)[0]=val;
  var u=new Uint32Array(buf);
  return '0x'+u[1].toString(16).padStart(8,'0')+'_'+u[0].toString(16).padStart(8,'0');
}

// ─── 45-A ─────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 45-A] structuredClone de objeto cíclico com TypedArray\n';
  sep();
  info('31-B confirmou: structuredClone(ciclico) não lança DataCloneError.');
  info('Verificando: o clone de um TypedArray dentro de um ciclo compartilha o backing store?\n');

  // Criar TypedArray com dados conhecidos
  var origBuf = new ArrayBuffer(256);
  var origU32 = new Uint32Array(origBuf);
  for(var i=0;i<64;i++) origU32[i] = 0xAABB0000 + i;
  info('origU32[0]=0x' + origU32[0].toString(16) + ' origU32[63]=0x' + origU32[63].toString(16));

  // Objeto cíclico com o TypedArray
  var cyclic = {
    id: 'test45A',
    arr: origU32,
    buf: origBuf,
    self: null
  };
  cyclic.self = cyclic;

  // structuredClone do cíclico
  var clone = null;
  try {
    clone = structuredClone(cyclic);
    info('structuredClone(cyclic) não lançou!');
    info('clone.id: ' + clone.id);
    info('clone.arr instanceof Uint32Array: ' + (clone.arr instanceof Uint32Array));
    if(clone.arr instanceof Uint32Array) {
      info('clone.arr.length: ' + clone.arr.length);
      info('clone.arr[0]: 0x' + clone.arr[0].toString(16));
      info('clone.arr === origU32: ' + (clone.arr === origU32));
      info('clone.arr.buffer === origBuf: ' + (clone.arr.buffer === origBuf));

      if(clone.arr === origU32) {
        alerta('CLONE COMPARTILHA A MESMA REFERÊNCIA DO TYPEDARRAY!\n' +
               'structuredClone deveria criar uma cópia independente.\n' +
               'Se clone.arr === origU32, qualquer modificação em um afeta o outro.\n' +
               'Isso é um bug de aliasing em objetos cíclicos!');
      } else if(clone.arr.buffer === origBuf) {
        alerta('CLONE COMPARTILHA O MESMO ARRAYBUFFER!\n' +
               'clone.arr é uma nova view mas sobre o MESMO backing store!\n' +
               'Modificar origBuf via origU32 afeta clone.arr e vice-versa.\n' +
               'Isso é um shared backing store não intencional!');
      } else {
        ok('Clone tem backing store independente. Verificando se os dados são iguais...');
        var match = true;
        for(var i=0;i<64;i++) {
          if(clone.arr[i] !== origU32[i]) { match=false; break; }
        }
        info('Dados idênticos: ' + match);
        info('clone.arr.buffer.byteLength: ' + clone.arr.buffer.byteLength);
      }

      // Verificar o ciclo no clone
      info('\nVerificando ciclo no clone:');
      info('clone.self === clone: ' + (clone.self === clone));
      if(clone.self === clone) {
        info('Ciclo preservado no clone!');
      }
      info('clone.self.arr === clone.arr: ' + (clone.self && clone.self.arr === clone.arr));
    }
  } catch(e) {
    ok('structuredClone lançou: ' + e.message + ' (comportamento correto pela spec)');
    info('31-B pode ter sido timing-specific. Retestando...');
    // Tentar várias vezes
    for(var attempt=0; attempt<5; attempt++) {
      try {
        var c2 = structuredClone(cyclic);
        alerta('structuredClone NÃO LANÇOU em tentativa ' + (attempt+1) + '!');
        break;
      } catch(e2) {
        info('Tentativa ' + (attempt+1) + ': lançou ' + e2.message);
      }
    }
  }
}

// ─── 45-B ─────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 45-B] Modificar original após clone — clone reflete a mudança?\n';
  sep();
  info('Se o clone compartilhar o backing store (mesmo que indiretamente),');
  info('modificar o TypedArray original deve afetar o clone.\n');

  var buf = new ArrayBuffer(128);
  var u32 = new Uint32Array(buf);
  for(var i=0;i<32;i++) u32[i] = 0xDEAD0000 + i;

  var cyclic = { data: u32, ref: null };
  cyclic.ref = cyclic;

  var clone = null;
  try {
    clone = structuredClone(cyclic);
    info('Clone criado.');
  } catch(e) {
    info('structuredClone lançou: ' + e.message);
    return;
  }

  if(!clone || !(clone.data instanceof Uint32Array)) {
    info('Clone não contém TypedArray válido. Abortando.');
    return;
  }

  info('Antes da modificação:');
  info('  original u32[0]: 0x' + u32[0].toString(16));
  info('  clone.data[0]: 0x' + clone.data[0].toString(16));

  // Modificar o original
  u32[0] = 0xC0FFEE42;
  u32[1] = 0xDEADBEEF;
  info('\nApós modificar original (u32[0]=0xC0FFEE42, u32[1]=0xDEADBEEF):');
  info('  original u32[0]: 0x' + u32[0].toString(16));
  info('  clone.data[0]: 0x' + clone.data[0].toString(16));

  if(clone.data[0] === 0xC0FFEE42) {
    alerta('SHARED BACKING STORE CONFIRMADO!\n' +
           'Modificar o TypedArray original afetou o clone!\n' +
           'clone.data[0]=0x' + clone.data[0].toString(16) + '\n\n' +
           'Isso significa que ambos apontam para o mesmo buffer físico.\n' +
           'Temos dois "donos" do mesmo buffer → potencial UAF e arbitrary write!');
  } else {
    ok('Clone não foi afetado (backing stores independentes).');
    info('clone.data[0] ainda = 0x' + clone.data[0].toString(16));
  }

  // Modificar o clone e ver se o original é afetado
  clone.data[0] = 0x41414141;
  info('\nApós modificar clone (clone.data[0]=0x41414141):');
  info('  original u32[0]: 0x' + u32[0].toString(16));
  if(u32[0] === 0x41414141) {
    alerta('WRITE-THROUGH CONFIRMADO! Clone escreveu no original!\n' +
           'u32[0]=0x41414141 — modificação do clone atingiu o buffer do original!');
  } else {
    info('Original não afetado pela escrita no clone (0x' + u32[0].toString(16) + ')');
  }

  // Verificar Float64Array — se backing stores são diferentes, suas estruturas internas diferem
  info('\nComparando estruturas internas (Float64Array sobre os mesmos buffers):');
  var f64_orig = new Float64Array(buf);
  if(clone.data.buffer) {
    var f64_clone = new Float64Array(clone.data.buffer);
    info('f64_orig[0] bits: ' + f64bits(f64_orig[0]));
    info('f64_clone[0] bits: ' + f64bits(f64_clone[0]));
    if(f64_orig[0] !== f64_clone[0]) {
      alerta('BUFFERS TÊM CONTEÚDOS DIFERENTES!\n' +
             'f64_orig[0]=' + f64_orig[0] + ' vs f64_clone[0]=' + f64_clone[0] + '\n' +
             'Os backing stores divergiram após as escritas!');
    }
  }
}

// ─── 45-C ─────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 45-C] Getter no objeto clonado — preservado no clone?\n';
  sep();
  info('structuredClone normalmente NÃO clona getters/setters (apenas valores).');
  info('Mas em objeto cíclico onde o clone pode ter inconsistências,');
  info('verificar se o getter é preservado ou se o valor é snapshotted.\n');

  var sideEffect_count = 0;
  var SECRET_VALUE = 0xDEADC0DE;

  var objWithGetter = {};
  Object.defineProperty(objWithGetter, 'secret', {
    get: function() {
      sideEffect_count++;
      return SECRET_VALUE;
    },
    configurable: true, enumerable: true
  });
  objWithGetter.normal = 12345;

  // Criar ciclo
  var cyclic = { payload: objWithGetter, self: null };
  cyclic.self = cyclic;

  info('objWithGetter.secret getter configurado (retorna 0xDEADC0DE).');
  info('sideEffect_count antes do clone: ' + sideEffect_count);

  try {
    var clone = structuredClone(cyclic);
    info('Clone criado. sideEffect_count após clone: ' + sideEffect_count);

    if(sideEffect_count > 0) {
      info('O getter FOI chamado durante a clonagem (' + sideEffect_count + ' vezes)!');
      info('clone.payload.secret: ' + clone.payload.secret);
      info('typeof clone.payload.secret getter: ');

      // Verificar se o clone tem o getter ou o valor snapshotted
      var descriptor = Object.getOwnPropertyDescriptor(clone.payload, 'secret');
      if(descriptor) {
        info('  value: ' + descriptor.value);
        info('  get: ' + (typeof descriptor.get));
        if(typeof descriptor.get === 'function') {
          alerta('GETTER PRESERVADO NO CLONE!\n' +
                 'structuredClone manteve o getter no clone.\n' +
                 'Isso viola a spec (deve copiar o valor, não o getter).\n' +
                 'Um getter malicioso em um objeto clonado pode ter side-effects inesperados!');
        } else {
          ok('Getter foi convertido para valor: ' + descriptor.value);
        }
      }
    } else {
      info('Getter NÃO foi chamado durante a clonagem.');
      if(clone.payload) {
        info('clone.payload.secret: ' + clone.payload.secret);
        info('(chamou o getter para exibir = count agora ' + sideEffect_count + ')');
      }
    }
  } catch(e) {
    info('structuredClone lançou: ' + e.message);
  }

  sep();
  // Teste de prototype chain confusion
  info('\nTeste de prototype chain: objeto com prototype custom no clone...');
  function SpecialClass() { this.data = new Uint32Array(16); }
  SpecialClass.prototype.readSecret = function() { return 0xBEEFBEEF; };

  var special = new SpecialClass();
  var cyclicSpecial = { obj: special, self: null };
  cyclicSpecial.self = cyclicSpecial;

  try {
    var cloneSpecial = structuredClone(cyclicSpecial);
    info('Clone de SpecialClass criado.');
    info('cloneSpecial.obj instanceof SpecialClass: ' + (cloneSpecial.obj instanceof SpecialClass));
    info('typeof cloneSpecial.obj.readSecret: ' + typeof cloneSpecial.obj.readSecret);
    if(typeof cloneSpecial.obj.readSecret === 'function') {
      alerta('PROTOTYPE PRESERVADO NO CLONE!\n' +
             'cloneSpecial.obj tem o método readSecret() do prototype de SpecialClass!\n' +
             'structuredClone deveria criar plain objects, não instâncias de classes.');
    } else {
      ok('Prototype não preservado (comportamento correto).');
    }
    if(cloneSpecial.obj.data instanceof Uint32Array) {
      info('cloneSpecial.obj.data é Uint32Array: ' + cloneSpecial.obj.data.length + ' elementos');
    }
  } catch(e) {
    info('structuredClone(SpecialClass) lançou: ' + e.message);
  }
}

// ─── 45-D ─────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 45-D] Clone + Transfer: criar estado inconsistente\n';
  sep();
  info('Combinar Vuln #1 (buffer leak via postMessage) com structuredClone.');
  info('\nCenário:');
  info('1. Criar TypedArray A com buffer X');
  info('2. structuredClone(cyclic_with_A) → cloneA com buffer Y (cópia)');
  info('3. postMessage(cyclic_with_A, *, [X]) → transfer X no remetente');
  info('4. O cloneA ainda aponta para Y (cópia feita antes do transfer)');
  info('5. Mas se cloneA.buffer === X (shared backing store) → cloneA lê buffer transferido!\n');

  var buf = new ArrayBuffer(512);
  var u32 = new Uint32Array(buf);
  for(var i=0;i<128;i++) u32[i] = 0xFEED0000 + i;
  info('buf criado: u32[0]=0x' + u32[0].toString(16));

  var cyclic = { arr: u32, buf: buf, id: 'clone_transfer_test', self: null };
  cyclic.self = cyclic;

  // Passo 1: structuredClone
  var cloned = null;
  try {
    cloned = structuredClone(cyclic);
    info('structuredClone OK.');
    info('cloned.arr.buffer === buf: ' + (cloned.arr && cloned.arr.buffer === buf));
    info('cloned.buf === buf: ' + (cloned.buf === buf));
    info('cloned.arr[0]: 0x' + (cloned.arr ? cloned.arr[0].toString(16) : 'N/A'));
  } catch(e) {
    info('structuredClone lançou: ' + e.message);
    cloned = null;
  }

  // Passo 2: postMessage com transfer
  window.onmessage = function(e) {
    var obj = e.data;
    if(!obj || obj.id !== 'clone_transfer_test') return;
    info('[onmessage] Recebeu obj.id=' + obj.id);
    if(obj.buf instanceof ArrayBuffer) {
      info('[onmessage] obj.buf.byteLength=' + obj.buf.byteLength);
      var rv = new Uint32Array(obj.buf);
      info('[onmessage] obj.buf[0]=0x' + rv[0].toString(16));
    }
  };

  try {
    postMessage(cyclic, '*', [buf]);
    info('\nTransfer executado. buf.byteLength=' + buf.byteLength);
    info('u32.buffer.byteLength=' + u32.buffer.byteLength);

    if(cloned && cloned.arr) {
      info('\nVerificando cloneA após transfer do original:');
      info('cloned.arr.buffer.byteLength: ' + cloned.arr.buffer.byteLength);
      try {
        var v = cloned.arr[0];
        info('cloned.arr[0]: 0x' + (v !== undefined ? v.toString(16) : 'undefined'));
        if(v === undefined && buf.byteLength === 0) {
          alerta('CLONE COMPARTILHAVA O BUFFER TRANSFERIDO!\n' +
                 'Após transfer de buf, cloned.arr[0] = undefined\n' +
                 '(buffer do clone foi zerado junto com o original)\n' +
                 'Isso confirma que o clone e o original compartilhavam o mesmo ArrayBuffer!');
        } else if(v !== undefined && buf.byteLength === 0) {
          info('Clone ainda tem acesso após transfer do original.');
          info('buf zerado mas cloned.arr[0]=0x' + v.toString(16) + ' (backing store independente)');
        }
      } catch(ex) {
        alerta('EXCECAO ao acessar cloned.arr[0] após transfer: ' + ex.message + '\n' +
               'O clone não consegue mais acessar seu buffer!');
      }
    }

    // Passo 3: verificar se podemos criar um TypedArray apontando para o buf zerado
    info('\nTentando criar nova view sobre buf transferido...');
    try {
      var zombieView = new Uint32Array(buf); // buf.byteLength=0
      info('Uint32Array(buf) criado: length=' + zombieView.length);
      if(zombieView.length === 0) {
        info('zombieView.length=0 (buffer zerado — expected)');
      }
    } catch(ex) {
      info('new Uint32Array(buf) lançou: ' + ex.message);
    }

    // Verificar estado do cloned após todos os testes
    if(cloned) {
      info('\nEstado final do clone:');
      info('cloned.self === cloned: ' + (cloned.self === cloned));
      info('cloned.arr: ' + (cloned.arr ? 'exists len='+cloned.arr.length : 'null'));
      if(cloned.arr && cloned.arr.buffer) {
        info('cloned.arr.buffer.byteLength: ' + cloned.arr.buffer.byteLength);
        if(cloned.arr.buffer.byteLength === 0) {
          alerta('CLONE.ARR.BUFFER FOI ZERADO!\n' +
                 'O buffer do TypedArray no clone tem byteLength=0 após o transfer.\n' +
                 'O clone e o original compartilhavam o ArrayBuffer. UAF potencial!');
        }
      }
    }
  } catch(e) {
    ok('postMessage lançou: ' + e.message);
  }
}
</script>
</body>
</html>

