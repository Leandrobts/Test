<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PS4 T8 DROP Finder (Auto-Scan Minimal)</title>
</head>
<body>
  <h3>PS4 T8 DROP Finder (Auto-Scan Minimal)</h3>

  <button id="run">RUN AUTO-SCAN</button>
  <button id="stop">STOP</button>
  <button id="reset">Reset</button>

  <div>
    N por config: <input id="N" type="number" value="40" min="5" step="5">
    Delay entre tentativas (ms): <input id="delay" type="number" value="0" min="0" step="1">
  </div>

  <div>
    Baseline FastWait (ms): <input id="fast0" type="number" value="0" min="0" step="1">
    Baseline LateWait (ms): <input id="late0" type="number" value="800" min="0" step="50">
    Baseline Pressure (0..3): <input id="p0" type="number" value="1" min="0" max="3" step="1">
  </div>

  <pre id="log"></pre>

<script>
(() => {
  "use strict";

  const $log = document.getElementById("log");
  const $N = document.getElementById("N");
  const $delay = document.getElementById("delay");
  const $fast0 = document.getElementById("fast0");
  const $late0 = document.getElementById("late0");
  const $p0 = document.getElementById("p0");

  let STOP = false;

  function ts(){ return Date.now(); }
  function logLine(s){ $log.textContent += `[${ts()}] ${s}\n`; }
  function reset(){ $log.textContent = ""; logLine("Reset."); }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // pressão controlada (0..3), sem DoS
  function pressure(level){
    if (!level) return null;
    const bufs = [];
    const chunks = [0, 24, 48, 72][Math.max(0, Math.min(3, level))];
    const size   = [0, 0x4000, 0x6000, 0x8000][Math.max(0, Math.min(3, level))];
    for (let i = 0; i < chunks; i++){
      const ab = new ArrayBuffer(size);
      const u8 = new Uint8Array(ab);
      u8[0] = i & 0xFF;
      u8[u8.length - 1] = (i * 13) & 0xFF;
      bufs.push(u8);
    }
    return bufs;
  }

  function j(x){
    try { return JSON.stringify(x); } catch(e){ return String(x); }
  }

  async function wait0(ms){
    // mantém o “jeito PS4” de aguardar: microtask + setTimeout
    // ms=0/1 costuma ser onde janela aparece
    if (ms <= 0) {
      await Promise.resolve();
      await new Promise(r => setTimeout(r, 0));
      return;
    }
    await new Promise(r => setTimeout(r, ms));
  }

  async function attemptOnce(cfg, stats){
    if (typeof MessageChannel !== "function") {
      stats.noMC++;
      return;
    }

    const ch = new MessageChannel();
    let got = undefined;

    ch.port2.onmessage = (ev) => { got = ev.data; };

    const ab = new ArrayBuffer(4096);
    const u8 = new Uint8Array(ab);
    u8[0] = 0xAA;

    // pressão antes do transfer ajuda a “perturbar” fila/memória sem DOS
    pressure(cfg.pressure);

    let threw = false;
    try { ch.port1.postMessage(ab, [ab]); }
    catch(e){ threw = true; }

    if (threw) { stats.transfer_throw++; return; }

    // FAST WAIT (onde nasce o drop_fast)
    await wait0(cfg.fastWait);

    const senderLen = ab.byteLength;
    if (senderLen !== 0 && senderLen !== 4096) {
      stats.sender_impossible++;
      return;
    }

    if (senderLen !== 0) {
      // clone path (raro)
      stats.clone++;
      return;
    }

    // detach path
    stats.detach_ok++;

    if (got === undefined || got === null) {
      stats.drop_fast++;

      // LATE CONFIRM (se continuar undefined, vira "drop_confirmed")
      await wait0(cfg.lateWait);

      if (got === undefined || got === null) {
        stats.drop_confirmed++;

        // “fila pós-drop”: manda 3 mensagens e checa consistência
        let q = [];
        ch.port2.onmessage = (ev) => { q.push(ev.data); };
        try {
          ch.port1.postMessage({k:1});
          ch.port1.postMessage({k:2});
          ch.port1.postMessage({k:3});
        } catch(_) {}

        await wait0(200); // curto

        const ok = (q.length === 3 && q[0] && q[1] && q[2] && q[0].k===1 && q[1].k===2 && q[2].k===3);
        if (ok) stats.queue_ok++;
        else stats.queue_bad++;
      }
    } else {
      stats.recv_ok++;
    }
  }

  function score(s){
    // prioridade: drop_confirmed > queue_bad > drop_fast
    return (s.drop_confirmed * 1000) + (s.queue_bad * 50) + (s.drop_fast * 5);
  }

  async function runConfig(cfg, N, delayMs){
    const stats = {
      detach_ok:0, recv_ok:0, clone:0,
      drop_fast:0, drop_confirmed:0,
      queue_ok:0, queue_bad:0,
      sender_impossible:0, transfer_throw:0,
      noMC:0
    };

    for (let i = 0; i < N; i++){
      if (STOP) break;
      await attemptOnce(cfg, stats);
      if (delayMs) await sleep(delayMs);
    }
    return stats;
  }

  async function runAutoScan(){
    STOP = false;

    const N = Math.max(5, parseInt($N.value || "40", 10));
    const delayMs = Math.max(0, parseInt($delay.value || "0", 10));

    const base = {
      fastWait: Math.max(0, parseInt($fast0.value || "0", 10)),
      lateWait: Math.max(0, parseInt($late0.value || "800", 10)),
      pressure: Math.max(0, Math.min(3, parseInt($p0.value || "1", 10)))
    };

    logLine(`AUTO-SCAN start :: N=${N} delay=${delayMs} base=${j(base)}`);

    // Varre "em volta" do baseline (não aumenta tudo!)
    const fastList = [base.fastWait, 0, 1, 2, 5].filter((v,i,a)=>a.indexOf(v)===i);
    const lateList = [base.lateWait, 200, 400, 800, 1200, 1500].filter((v,i,a)=>a.indexOf(v)===i);
    const pList    = [base.pressure, 0, 1, 2, 3].filter((v,i,a)=>a.indexOf(v)===i);

    let best = null;

    let total = 0;
    for (const fastWait of fastList){
      for (const lateWait of lateList){
        for (const pressureLevel of pList){
          if (STOP) break;

          const cfg = { fastWait, lateWait, pressure: pressureLevel };
          total++;

          const stats = await runConfig(cfg, N, delayMs);
          const sc = score(stats);

          // log mínimo por config
          logLine(`CFG#${total} fast=${fastWait} late=${lateWait} p=${pressureLevel} :: ${j(stats)}`);

          if (!best || sc > best.score){
            best = { cfg, stats, score: sc };
            logLine(`BEST UPDATE :: score=${best.score} cfg=${j(best.cfg)} stats=${j(best.stats)}`);
          }

          // se achou drop_confirmed, para cedo (isso é o que interessa)
          if (stats.drop_confirmed > 0){
            logLine("STOP EARLY: drop_confirmed>0 encontrado.");
            STOP = true;
            break;
          }
        }
        if (STOP) break;
      }
      if (STOP) break;
    }

    if (best){
      logLine("==== BEST RESULT ====");
      logLine(`best_cfg=${j(best.cfg)}`);
      logLine(`best_stats=${j(best.stats)}`);
    } else {
      logLine("No results.");
    }

    logLine("AUTO-SCAN done.");
  }

  document.getElementById("run").onclick = () => runAutoScan().catch(e => logLine("ERR: " + ((e&&e.name)||String(e))));
  document.getElementById("stop").onclick = () => { STOP = true; logLine("STOP requested."); };
  document.getElementById("reset").onclick = reset;

  reset();
})();
</script>
</body>
</html>
