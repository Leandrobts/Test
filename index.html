<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PoC #1 — Sanity Checks (ArrayBuffer Leak)</title>
<style>
  body { font-family: monospace; background: #111; color: #eee; padding: 20px; }
  h2 { color: #f90; }
  pre { background: #1e1e1e; padding: 16px; border-left: 3px solid #f90; white-space: pre-wrap; }
  .ok    { color: #4f4; }
  .alert { color: #f44; font-weight: bold; }
  .info  { color: #aaa; }
  .warn  { color: #fa4; }
  button { background: #f90; color: #000; border: none; padding: 10px 24px;
           font-size: 14px; font-weight: bold; cursor: pointer; margin: 4px; }
  #log { margin-top: 10px; display: block; }
</style>
</head>
<body>

<h2>PoC #1 — Sanity Checks (ArrayBuffer / Transfer Semantics)</h2>
<pre>
Objetivo: Validar se o vazamento reportado não é apenas o comportamento 
legítimo e esperado da especificação StructuredSerializeWithTransfer.
</pre>

<button onclick="runSanityChecks()">▶ EXECUTAR SANITY CHECKS</button>
<pre id="log">Pressione o botão para iniciar os testes de sanidade.</pre>

<script>
var log = document.getElementById('log');
function line(cls, msg) {
  var s = document.createElement('span');
  s.className = cls;
  s.textContent = msg + '\n';
  log.appendChild(s);
}
function info(m)  { line('info',  '[INFO]  ' + m); }
function ok(m)    { line('ok',    '[OK]    ' + m); }
function alert_(m){ line('alert', '[VULN]  ' + m); }
function warn(m)  { line('warn',  '[WARN]  ' + m); }
function sep()    { line('info',  '─'.repeat(60)); }

async function runSanityChecks() {
  log.textContent = '';
  info('=== INICIANDO SANITY CHECKS (ArrayBuffer) ===');
  sep();

  // 1. Criando buffer de teste
  var secretBuf = new ArrayBuffer(256);
  var view = new Uint8Array(secretBuf);
  view[0] = 0x42; // Magic byte
  info('Buffer criado. byteLength = ' + secretBuf.byteLength);

  // 2. Criando o ciclo e transferindo
  var cyclic = { buf: secretBuf, self: null };
  cyclic.self = cyclic;

  var leakedBuf = await new Promise(function(resolve) {
    var prev = window.onmessage;
    window.onmessage = function(e) {
      window.onmessage = prev;
      resolve(e.data.buf);
    };
    postMessage(cyclic, '*', [secretBuf]);
  });

  sep();
  info('--- Check 1: Acesso de Leitura no Sender ---');
  info('Sender byteLength: ' + secretBuf.byteLength);
  try {
    // Tenta ler o conteúdo após o transfer (neuter)
    var testRead = new Uint8Array(secretBuf);
    if (testRead.length === 0) {
      ok('Sender buffer tem view length 0 (Neutered / Detached).');
    } else {
      alert_('FALHA: Sender ainda consegue ver tamanho > 0! Tamanho: ' + testRead.length);
    }
  } catch(e) {
    ok('Sender buffer lançou exceção ao tentar criar view (Detached). Exceção: ' + e.message);
  }

  sep();
  info('--- Check 2: Comportamento Sem Ciclo (Baseline) ---');
  var normalBuf = new ArrayBuffer(64);
  var baselineResult = await new Promise(function(resolve) {
    var prev = window.onmessage;
    window.onmessage = function(e) {
      window.onmessage = prev;
      resolve(e.data);
    };
    postMessage(normalBuf, '*', [normalBuf]);
  });

  info('Baseline (Sem ciclo) Sender byteLength   = ' + normalBuf.byteLength);
  info('Baseline (Sem ciclo) Receiver byteLength = ' + (baselineResult ? baselineResult.byteLength : 'null'));

  sep();
  info('--- CONCLUSÃO DO SANITY CHECK ---');
  if (secretBuf.byteLength === 0 && normalBuf.byteLength === 0 && 
      leakedBuf.byteLength > 0 && baselineResult.byteLength > 0) {
    ok('O comportamento com ciclo é IDÊNTICO ao comportamento sem ciclo.');
    ok('O "vazamento" reportado é, na verdade, a funcionalidade correta e segura do Structured Clone.');
    ok('O sender foi corretamente invalidado (neutered) em ambos os casos.');
  } else {
    warn('Comportamento anômalo detectado. Pode haver uma vulnerabilidade real.');
  }
}
</script>
</body>
</html>
