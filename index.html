<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PS4 T8 Minimal — DROP (Fast vs Confirmed) + Queue Integrity</title>
</head>
<body>
  <h2>PS4 T8 Minimal — DROP Confirm + Queue Integrity (Minimal Log)</h2>

  <button id="run">RUN AUTO</button>
  <button id="stop">STOP</button>
  <button id="reset">Reset log</button>

  <div>
    Attempts (N): <input id="N" type="number" value="30" min="1" step="1">
    FastTimeout (ms): <input id="fast" type="number" value="1" min="0" step="1">
    LateCheck (ms): <input id="late" type="number" value="800" min="0" step="50">
    Delay between attempts (ms): <input id="delay" type="number" value="10" min="0" step="5">
    Pressure (1..5): <input id="p" type="number" value="3" min="1" max="5" step="1">
  </div>

  <pre id="log"></pre>

<script>
(() => {
  "use strict";

  const $log   = document.getElementById("log");
  const $N     = document.getElementById("N");
  const $fast  = document.getElementById("fast");
  const $late  = document.getElementById("late");
  const $delay = document.getElementById("delay");
  const $p     = document.getElementById("p");

  let STOP = false;

  function ts(){ return Date.now(); }
  function logLine(s){ $log.textContent += `[${ts()}] ${s}\n`; }
  function reset(){ $log.textContent = ""; logLine("Reset."); }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function j(x){ try { return JSON.stringify(x); } catch(e){ return String(x); } }

  // Lightweight pressure (avoid DoS)
  function heapPressure(level){
    const L = Math.max(1, Math.min(5, level|0));
    const chunks = [12, 20, 28, 36, 44][L-1];
    const size   = [0x4000, 0x6000, 0x8000, 0xA000, 0xC000][L-1];
    const bufs = [];
    for (let i = 0; i < chunks; i++){
      const ab = new ArrayBuffer(size);
      const u8 = new Uint8Array(ab);
      u8[0] = (i & 0xFF);
      u8[u8.length - 1] = ((i * 17) & 0xFF);
      bufs.push(u8);
    }
    return bufs;
  }

  function waitMessageOnce(port, ms){
    // Resolves with: { ok:true, data } if message arrives before ms
    // Resolves with: { ok:false, timeout:true } if not
    return new Promise((resolve) => {
      let done = false;
      let t = null;

      function finish(obj){
        if (done) return;
        done = true;
        try { port.onmessage = null; } catch(_){}
        if (t !== null) clearTimeout(t);
        resolve(obj);
      }

      port.onmessage = (ev) => finish({ ok:true, data: ev.data });

      if (ms >= 0) {
        t = setTimeout(() => finish({ ok:false, timeout:true }), ms);
      }
    });
  }

  async function queueIntegrityTest(K, waitMs){
    // fresh channel only (clean invariant test)
    const ch = new MessageChannel();
    const got = [];
    ch.port2.onmessage = (ev) => { got.push(ev.data); };

    for (let i = 1; i <= K; i++){
      try { ch.port1.postMessage({ seq: i }); } catch(_) {}
    }

    await sleep(waitMs);

    // Check: count==K and strict order 1..K
    let okCount = (got.length === K);
    let okOrder = true;
    let seen = Object.create(null);
    let dup = 0;

    for (let i = 0; i < got.length; i++){
      const v = got[i] && got[i].seq;
      if (typeof v !== "number") { okOrder = false; continue; }
      if (seen[v]) dup++;
      seen[v] = 1;
      if (v !== (i+1)) okOrder = false;
    }

    // Missing?
    let missing = 0;
    for (let i = 1; i <= K; i++){
      if (!seen[i]) missing++;
    }

    // cleanup
    try { ch.port1.close(); ch.port2.close(); } catch(_) {}

    return {
      K,
      gotCount: got.length,
      okCount,
      okOrder,
      missing,
      dup
    };
  }

  async function runOnce(i, cfg, stats, samples){
    // ---- T8 transfer attempt ----
    const ch = new MessageChannel();

    // victim
    const ab = new ArrayBuffer(4096);
    const u8 = new Uint8Array(ab);
    u8[0] = 0xAA;

    // pressure (to mimic your “good conditions” without DoS)
    const keep = heapPressure(cfg.pressure);

    let postThrew = false;
    try { ch.port1.postMessage(ab, [ab]); }
    catch(e){ postThrew = true; }

    if (postThrew){
      stats.post_throw++;
      try { ch.port1.close(); ch.port2.close(); } catch(_){}
      return;
    }

    // senderLen classification (after transfer attempt)
    const senderLen0 = ab.byteLength;
    if (senderLen0 !== 0 && senderLen0 !== 4096){
      stats.sender_impossible++;
      if (samples.sender_impossible.length < 2) samples.sender_impossible.push({ i, senderLen: senderLen0 });
      try { ch.port1.close(); ch.port2.close(); } catch(_){}
      return;
    }

    // FAST wait: did receiver get a message quickly?
    const fastRes = await waitMessageOnce(ch.port2, cfg.fastMs);

    if (senderLen0 === 0) {
      // transfer path expected: receiver should eventually get ArrayBuffer
      if (!fastRes.ok) {
        stats.drop_fast++;

        // LATE confirm: wait longer to distinguish "late delivery" vs "confirmed drop"
        const lateRes = await waitMessageOnce(ch.port2, cfg.lateMs);

        if (lateRes.ok) {
          stats.late_delivery++;

          // optional: verify type quickly (minimal)
          const t = Object.prototype.toString.call(lateRes.data);
          if (t !== "[object ArrayBuffer]" && samples.bad_type.length < 2) {
            samples.bad_type.push({ i, gotType: t });
            stats.bad_payload_type++;
          }
        } else {
          stats.drop_confirmed++;
          if (samples.drop_confirmed.length < 2) {
            samples.drop_confirmed.push({ i, senderLen: senderLen0, note: "no msg fast and no msg by lateCheck" });
          }

          // ---- Only on DROP_CONFIRMED: run a clean queue integrity test on a fresh channel ----
          const qi = await queueIntegrityTest(cfg.queueK, cfg.queueWaitMs);
          if (!qi.okCount || !qi.okOrder || qi.missing || qi.dup) {
            stats.queue_invariant_fail++;
            if (samples.queue_fail.length < 2) samples.queue_fail.push({ i, qi });
          } else {
            stats.queue_ok++;
          }
        }
      } else {
        stats.detach_ok_fast++;
        // minimal type check
        const t = Object.prototype.toString.call(fastRes.data);
        if (t !== "[object ArrayBuffer]") stats.bad_payload_type++;
      }
    } else {
      // clone/no-detach path (rare): not our focus
      stats.no_detach_or_clone++;
    }

    // keep alive
    if (keep && keep.length) keep[0][0] ^= 0;

    // cleanup
    try { ch.port1.close(); ch.port2.close(); } catch(_){}
  }

  async function runAuto(){
    STOP = false;

    const cfg = {
      N: Math.max(1, parseInt($N.value||"30",10)),
      fastMs: Math.max(0, parseInt($fast.value||"1",10)),
      lateMs: Math.max(0, parseInt($late.value||"800",10)),
      delayMs: Math.max(0, parseInt($delay.value||"10",10)),
      pressure: Math.max(1, Math.min(5, parseInt($p.value||"3",10))),

      // Queue test parameters (kept constant, minimal)
      queueK: 8,
      queueWaitMs: 200
    };

    logLine(`RUN AUTO :: N=${cfg.N} fast=${cfg.fastMs}ms late=${cfg.lateMs}ms delay=${cfg.delayMs}ms pressure=${cfg.pressure}`);

    const stats = {
      detach_ok_fast: 0,
      drop_fast: 0,
      late_delivery: 0,
      drop_confirmed: 0,

      post_throw: 0,
      sender_impossible: 0,
      no_detach_or_clone: 0,

      bad_payload_type: 0,

      queue_ok: 0,
      queue_invariant_fail: 0
    };

    const samples = {
      drop_confirmed: [],
      queue_fail: [],
      sender_impossible: [],
      bad_type: []
    };

    for (let i = 0; i < cfg.N; i++){
      if (STOP) break;

      await runOnce(i, cfg, stats, samples);

      if ((i+1) % 10 === 0) logLine(`progress: ${i+1}/${cfg.N}`);
      if (cfg.delayMs) await sleep(cfg.delayMs);
    }

    logLine("RESULT SUMMARY:");
    logLine(j(stats));

    const hot = [];
    if (samples.drop_confirmed.length) hot.push({ kind:"drop_confirmed", samples: samples.drop_confirmed });
    if (samples.queue_fail.length) hot.push({ kind:"queue_invariant_fail", samples: samples.queue_fail });
    if (samples.sender_impossible.length) hot.push({ kind:"sender_impossible", samples: samples.sender_impossible });
    if (samples.bad_type.length) hot.push({ kind:"bad_payload_type", samples: samples.bad_type });

    if (hot.length){
      logLine("SAMPLES (hot):");
      logLine(j(hot));
    }

    logLine("DONE.");
  }

  document.getElementById("run").onclick = () => runAuto().catch(e => logLine("ERR: " + (e && e.name ? e.name : String(e))));
  document.getElementById("stop").onclick = () => { STOP = true; logLine("STOP requested."); };
  document.getElementById("reset").onclick = reset;

  reset();
})();
</script>
</body>
</html>
