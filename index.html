<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>PoC #2 — Sanity Checks (JIT Type Confusion)</title>
<style>
  body { font-family: monospace; background: #111; color: #eee; padding: 20px; }
  h2 { color: #4af; }
  pre { background: #1e1e1e; padding: 16px; border-left: 3px solid #4af; white-space: pre-wrap; }
  .ok    { color: #4f4; }
  .alert { color: #f44; font-weight: bold; }
  .info  { color: #aaa; }
  .warn  { color: #fa4; }
  button { background: #4af; color: #000; border: none; padding: 10px 24px;
           font-size: 14px; font-weight: bold; cursor: pointer; margin: 4px; }
  #log { margin-top: 10px; display: block; }
</style>
</head>
<body>

<h2>PoC #2 — Sanity Checks (JIT / Coerção de Tipos)</h2>
<pre>
Objetivo: Validar se as primitivas de Type Confusion não são apenas
mecanismos seguros de fallback (Deopt) ou coerções padrão da spec (ToNumber/ToString).
</pre>

<button onclick="runSanityChecks()">▶ EXECUTAR SANITY CHECKS</button>
<pre id="log">Pressione o botão para iniciar os testes de sanidade.</pre>

<script>
var log = document.getElementById('log');
function line(cls, msg) {
  var s = document.createElement('span');
  s.className = cls;
  s.textContent = msg + '\n';
  log.appendChild(s);
}
function info(m)  { line('info',  '[INFO]  ' + m); }
function ok(m)    { line('ok',    '[OK]    ' + m); }
function alert_(m){ line('alert', '[VULN]  ' + m); }
function warn(m)  { line('warn',  '[WARN]  ' + m); }
function sep()    { line('info',  '─'.repeat(60)); }

var WARMUP = 60000;

function buildGadget(phase, payloadRef) {
  return {
    [Symbol.replace]: function(str) {
      if (phase[0] === 'warmup') return str; 
      return payloadRef[0]; // Retorna diretamente o payload no ataque
    }
  };
}

function strLen(s, handler) {
  return s.replace(handler, '').length;
}

function readViaLength(arr, len) {
  return arr[len >>> 0];
}

async function runSanityChecks() {
  log.textContent = '';
  info('=== INICIANDO SANITY CHECKS (JIT) ===');
  sep();

  var phase = ['warmup'];
  var payload = [0];
  var handler = buildGadget(phase, payload);
  var base = 'test string';

  info('Realizando warmup JIT (' + WARMUP + ' iterações)...');
  for (var w = 0; w < WARMUP; w++) strLen(base, handler);
  info('Warmup concluído.');
  sep();

  // --- Check 1: Coerção ToString (ECMAScript Spec) ---
  info('--- Check 1: Teste de coerção ToString() vs .length ---');
  payload[0] = {
    toString: function() { return "ABC"; }, // length será 3 após coerção correta
    length: 99999
  };
  phase[0] = 'attack';
  var coercionResult = strLen(base, handler);
  phase[0] = 'warmup';

  info('Resultado: ' + coercionResult);
  if (coercionResult === 3) {
    ok('Engine respeitou ToString() ignorando a propriedade .length falsa (Spec Compliant). Não é Type Confusion.');
  } else if (coercionResult === 99999) {
    alert_('Atenção: Engine leu .length diretamente do objeto sem coerção prévia. (Vulnerabilidade potencial confirmada).');
  } else {
    warn('Resultado inesperado: ' + coercionResult);
  }

  sep();
  // --- Check 2: Estabilidade e Deopt ---
  info('--- Check 2: Teste de estabilidade / Deopt (100 execuções) ---');
  payload[0] = { toString: function(){ return "X"; }, length: 777 }; 
  phase[0] = 'attack';
  
  let successes = 0;
  let deopts = 0;
  
  for(let i = 0; i < 100; i++) {
    let res = strLen(base, handler);
    if (res === 777) successes++;
    else deopts++;
  }
  phase[0] = 'warmup';
  
  info('Retornou fake length (777): ' + successes + ' vezes');
  info('Retornou fallback seguro    : ' + deopts + ' vezes');
  
  if (deopts > 0 && successes > 0) {
    warn('A Primitiva é instável. O JIT está fazendo deopt (Bailout) intermitentemente.');
  } else if (deopts === 100) {
    ok('JIT fez deopt consistentemente. Falha mitigada pela engine.');
  } else if (successes === 100) {
    alert_('A primitiva é altamente estável. Type Confusion mantida na JIT.');
  }

  sep();
  // --- Check 3: Desmascarando a Primitiva C (OOB Falso) ---
  info('--- Check 3: Desmascarando a Primitiva C (OOB Falso) ---');
  var f64 = new Float64Array(8);
  for (var i = 0; i < 8; i++) f64[i] = (i + 1) * 1.1111;

  info('Warmup para readViaLength...');
  for (var w = 0; w < WARMUP; w++) readViaLength(f64, 3);

  var dummyObj = { magic: 0x1234 };
  var resultC = readViaLength(f64, dummyObj);
  
  info('O valor no índice 0 de f64 é: ' + f64[0]);
  info('O retorno da função com objeto foi: ' + resultC);
  
  if (resultC === f64[0]) {
    ok('Explicação: NaN >>> 0 resulta em 0.');
    ok('O motor leu f64[0]. Isso NÃO é um vazamento OOB nem Type Confusion de ponteiro.');
    ok('É apenas o fallback matemático de ToNumber(object) resultando em NaN e virando índice 0.');
  } else if (resultC === undefined) {
    ok('O retorno foi undefined (índice fora do limite natural). Comportamento seguro.');
  } else {
    warn('Valor lido: ' + resultC + '. Pode requerer investigação.');
  }
}
</script>
</body>
</html>
