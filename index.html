<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PS4 T8 Scan — DROP + Stale/Changed After Detach (Minimal Log)</title>
</head>
<body>
  <h2>PS4 T8 Scan — MessageChannel Transfer DROP + Stale/Changed After Detach</h2>

  <button id="run">RUN AUTO</button>
  <button id="stop">STOP</button>
  <button id="reset">Reset log</button>

  <p>
    Attempts per size (N):
    <input id="n" type="number" value="30" min="1" step="1">
    &nbsp; Timeout (ms):
    <input id="timeout" type="number" value="200" min="50" step="50">
    &nbsp; Delay (ms):
    <input id="delay" type="number" value="10" min="0" step="5">
    &nbsp; Pressure (0..10):
    <input id="pressure" type="number" value="5" min="0" max="10" step="1">
  </p>

  <p>
    Sizes (bytes) CSV (vazio = padrão buckets):
    <input id="sizes" type="text" size="60" placeholder="4096,8192,16384,32768,65536,131072,262144,524288,1048576">
  </p>

  <pre id="log"></pre>

<script>
(function(){
  "use strict";

  var $log = document.getElementById("log");
  function ts(){ return Date.now(); }
  function logLine(s){ $log.textContent += "[" + ts() + "] " + s + "\n"; }
  function resetLog(){ $log.textContent=""; logLine("Reset."); }

  function toJSON(x){
    try { return JSON.stringify(x); } catch(e){ return String(x); }
  }

  function parseSizesCSV(s){
    s = (s || "").trim();
    if (!s) return null;
    var parts = s.split(",");
    var out = [];
    for (var i=0;i<parts.length;i++){
      var v = parseInt(parts[i].trim(),10);
      if (isFinite(v) && v > 0) out.push(v);
    }
    return out.length ? out : null;
  }

  function defaultSizes(){
    return [4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576];
  }

  function isArrayBuffer(x){
    if (!x) return false;
    var tag = Object.prototype.toString.call(x);
    if (tag === "[object ArrayBuffer]") return true;
    // fallback-ish
    return (typeof x.byteLength === "number" && typeof x.slice === "function");
  }

  function clampInt(v, lo, hi, def){
    v = parseInt(v,10);
    if (!isFinite(v)) return def;
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
  }

  // Pressure: bounded, same-size allocations. NOT unbounded spray.
  function doPressureSameSize(sz, level){
    if (!level) return;
    // Budget: cap total at ~16MB per call (conservador).
    var budget = 16 * 1024 * 1024;
    var per = Math.max(sz, 1024);
    var maxCount = Math.floor(budget / per);
    // Level scales count, but never exceeds maxCount.
    var count = Math.min(maxCount, Math.max(0, Math.floor((level / 10) * maxCount)));
    var junk = [];
    for (var i=0;i<count;i++){
      junk.push(new ArrayBuffer(per));
    }
    // keep briefly, then release
    return junk;
  }

  // Read probe on pre-existing typed array view after detach.
  // Expected: length becomes 0 and u8[0] is undefined (or throws).
  function safeReadU8(u8){
    try {
      return { threw:false, v: u8[0], len: u8.length };
    } catch(e){
      return { threw:true, err: (e && e.name) ? e.name : "ERR" };
    }
  }

  var running = false;
  var stopRequested = false;

  function runAuto(){
    if (running) return;
    stopRequested = false;
    running = true;

    if (typeof MessageChannel !== "function") {
      logLine("ERRO: MessageChannel não disponível.");
      running = false;
      return;
    }

    var N = clampInt(document.getElementById("n").value, 1, 10000, 30);
    var timeoutMs = clampInt(document.getElementById("timeout").value, 50, 10000, 200);
    var delayMs = clampInt(document.getElementById("delay").value, 0, 5000, 10);
    var pressure = clampInt(document.getElementById("pressure").value, 0, 10, 5);
    var sizes = parseSizesCSV(document.getElementById("sizes").value) || defaultSizes();

    logLine("============================================================");
    logLine("RUN AUTO :: scan sizes (T8 base) + stale/changed probes");
    logLine("Config :: " + toJSON({ N:N, timeoutMs:timeoutMs, delayMs:delayMs, pressure:pressure, sizes:sizes }));
    logLine("============================================================");

    // Aggregated results by size.
    var agg = {}; // size -> stats
    function initStats(sz){
      agg[sz] = {
        N: 0,
        detach_ok: 0,
        drop: 0,
        throw_post: 0,
        stale_AA: 0,
        changed_no_write: 0,
        other: 0,
        samples: [] // keep a few only
      };
    }
    for (var si=0;si<sizes.length;si++){
      initStats(String(sizes[si]));
    }

    var siIdx = 0;
    var attemptIdx = 0;

    function next(){
      if (stopRequested) return finish();
      if (siIdx >= sizes.length) return finish();

      var sz = sizes[siIdx];
      var key = String(sz);
      var st = agg[key];

      if (attemptIdx >= N){
        // move to next size
        siIdx++;
        attemptIdx = 0;
        return setTimeout(next, 0);
      }

      attemptIdx++;
      st.N++;

      // Progress: only every 10
      if ((attemptIdx % 10) === 0) {
        logLine("progress size=" + sz + " " + attemptIdx + "/" + N);
      }

      // --- Attempt body
      var ch = new MessageChannel();
      var ab = new ArrayBuffer(sz);
      var u8 = new Uint8Array(ab);

      // Place sentinels (multiple offsets to avoid trivialities).
      // Keep it simple/minimal.
      u8[0] = 0xAA;
      if (sz > 64) u8[63] = 0xAA;
      if (sz > 256) u8[255] = 0xAA;

      var got = undefined;
      ch.port2.onmessage = function(ev){ got = ev.data; };

      var postThrew = false;
      try {
        ch.port1.postMessage(ab, [ab]); // transfer => sender should detach
      } catch(e) {
        postThrew = true;
      }

      // wait timeoutMs then evaluate
      setTimeout(function(){
        if (stopRequested) return finish();

        var senderLen = 0;
        try { senderLen = ab.byteLength; } catch(_) { senderLen = -1; }

        if (postThrew) {
          st.other++;
          return afterDelay();
        }

        if (senderLen !== 0) {
          // Not detached path (unexpected in this harness)
          st.other++;
          return afterDelay();
        }

        // detached sender
        if (got === undefined || got === null) {
          // DROP
          st.drop++;

          // Post-drop probe A/B: attempt to read from pre-existing u8 view.
          // A: immediate read
          var r1 = safeReadU8(u8);

          // Pressure (bounded) then B: late read
          var junk = doPressureSameSize(sz, pressure);
          var r2 = safeReadU8(u8);
          // release
          junk = null;

          // Classification:
          // - "stale_AA": got 0xAA after detach (strong)
          // - "changed_no_write": got a NUMBER not 0xAA (and not undefined) after pressure (strong)
          // - "throw_post": throws accessing view after detach (expected-ish)
          var stale = false;
          var changed = false;
          var threw = false;

          if (r1 && r1.threw) threw = true;
          if (r2 && r2.threw) threw = true;

          if (!r1.threw && r1.v === 0xAA) stale = true;
          if (!r2.threw && typeof r2.v === "number" && r2.v !== 0xAA) changed = true;

          if (stale) st.stale_AA++;
          if (changed) st.changed_no_write++;
          if (threw) st.throw_post++;

          // Keep only a few samples per size
          if (st.samples.length < 3 && (stale || changed)) {
            st.samples.push({
              i: attemptIdx-1,
              kind: "DROP+probe",
              sz: sz,
              senderLen: senderLen,
              r1: r1,
              r2: r2
            });
          }

          return afterDelay();
        }

        // receiver got something: validate ArrayBuffer and sentinel
        if (isArrayBuffer(got)) {
          try {
            var ru8 = new Uint8Array(got);
            var ok = (ru8.length === sz && ru8[0] === 0xAA);
            if (ok) st.detach_ok++;
            else st.other++;
          } catch(e2) {
            st.other++;
          }
        } else {
          st.other++;
        }

        return afterDelay();
      }, timeoutMs);

      function afterDelay(){
        // cleanup ports best-effort
        try { ch.port1.close(); } catch(_) {}
        try { ch.port2.close(); } catch(_) {}
        ch = null;
        // slight delay between attempts
        if (delayMs) setTimeout(next, delayMs);
        else setTimeout(next, 0);
      }
    }

    function finish(){
      if (!running) return;
      running = false;

      // Print compact summary per size (one line)
      logLine("------------------------------------------------------------");
      logLine("RESULT SUMMARY (per size):");
      for (var i=0;i<sizes.length;i++){
        var sz = sizes[i];
        var st = agg[String(sz)];
        logLine("sz=" + sz +
          " N=" + st.N +
          " detach_ok=" + st.detach_ok +
          " drop=" + st.drop +
          " staleAA=" + st.stale_AA +
          " changedNoWrite=" + st.changed_no_write +
          " postThrow=" + st.throw_post +
          " other=" + st.other
        );
      }

      // Print only “hot” samples
      logLine("------------------------------------------------------------");
      logLine("HOT SAMPLES (max 3 per size):");
      for (var j=0;j<sizes.length;j++){
        var szz = sizes[j];
        var sst = agg[String(szz)];
        if (sst.samples.length) {
          logLine("sz=" + szz + " samples=" + toJSON(sst.samples));
        }
      }
      logLine("DONE.");
    }

    next();
  }

  document.getElementById("run").onclick = runAuto;
  document.getElementById("stop").onclick = function(){
    stopRequested = true;
    logLine("STOP requested.");
  };
  document.getElementById("reset").onclick = function(){
    stopRequested = true;
    running = false;
    resetLog();
  };

  resetLog();
})();
</script>
</body>
</html>
