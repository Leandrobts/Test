
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>PS4 T8 Recheck — DROP vs Late Delivery + Queue Integrity (Minimal)</title>
</head>
<body>
  <h2>PS4 T8 Recheck — DROP vs Late Delivery + Queue Integrity (Minimal)</h2>

  <button id="run">RUN AUTO</button>
  <button id="stop">STOP</button>
  <button id="reset">Reset log</button>

  <div>
    Attempts (N):
    <input id="N" type="number" value="60" min="1" step="1">
    AB size (bytes):
    <input id="abSize" type="number" value="4096" min="256" step="256">
    FastTimeout (ms):
    <input id="fast" type="number" value="2" min="0" step="1">
    LateCheck (ms):
    <input id="late" type="number" value="1500" min="0" step="50">
    Delay between attempts (ms):
    <input id="delay" type="number" value="20" min="0" step="5">
    Pressure (0..5):
    <input id="p" type="number" value="3" min="0" max="5" step="1">
    Queue K (messages):
    <input id="K" type="number" value="3" min="1" max="8" step="1">
  </div>

  <pre id="log"></pre>

<script>
(() => {
  "use strict";

  const $log  = document.getElementById("log");
  const $N    = document.getElementById("N");
  const $abSz = document.getElementById("abSize");
  const $fast = document.getElementById("fast");
  const $late = document.getElementById("late");
  const $delay= document.getElementById("delay");
  const $p    = document.getElementById("p");
  const $K    = document.getElementById("K");

  let STOP = false;

  function ts(){ return Date.now(); }
  function logLine(s){ $log.textContent += "[" + ts() + "] " + s + "\n"; }
  function resetLog(){ $log.textContent = ""; logLine("Reset."); }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
  function j(x){ try { return JSON.stringify(x); } catch(e){ return String(x); } }

  async function withTimeout(p, ms){
    if (ms <= 0) return await p;
    let t;
    const to = new Promise((_, rej) => { t = setTimeout(() => rej(new Error("TIMEOUT")), ms); });
    try { return await Promise.race([p, to]); }
    finally { clearTimeout(t); }
  }

  // Controlado (evita DoS): pressão leve/moderada, apenas para "chacoalhar" scheduling/GC.
  function pressure(level){
    level = Math.max(0, Math.min(5, level|0));
    if (!level) return null;

    const bufs = [];
    const chunks = [0, 12, 24, 36, 48, 60][level];     // máx 60
    const size   = [0, 0x4000, 0x5000, 0x6000, 0x7000, 0x8000][level]; // máx 32KB

    for (let i = 0; i < chunks; i++) {
      const ab = new ArrayBuffer(size);
      const u8 = new Uint8Array(ab);
      // toque mínimo para materializar
      u8[0] = (i & 0xFF);
      u8[u8.length - 1] = ((i * 17) & 0xFF);
      bufs.push(u8);
    }
    return bufs;
  }

  // Núcleo do recheck:
  // - drop_fast: senderLen==0 e não chegou payload dentro do FastTimeout
  // - late_delivery: chegou payload depois do fast (mas até LateCheck)
  // - drop_confirmed: senderLen==0 e payload não chegou nem até LateCheck
  // - queue_invariant_fail: após drop_fast, envia K mensagens com attemptId e valida (count e order)
  async function runAttempt(i, cfg, stats, samples){
    const attemptId = ((ts() & 0x7fffffff) + "_" + i);

    const ch = new MessageChannel();
    let gotPayload = undefined;
    let gotAt = -1;

    // fila pós-drop (somente mensagens com attemptId atual)
    let q = [];
    ch.port2.onmessage = (ev) => {
      const d = ev.data;
      // Primeiro payload esperado: ArrayBuffer transferido
      if (gotPayload === undefined) {
        gotPayload = d;
        gotAt = ts();
        return;
      }
      // Depois: mensagens de fila
      if (d && d.__attemptId === attemptId) q.push(d);
    };

    // AB “vítima”
    const abSize = cfg.abSize;
    const ab = new ArrayBuffer(abSize);
    const u8 = new Uint8Array(ab);
    u8[0] = 0xAA;

    let postThrew = false;
    try {
      ch.port1.postMessage(ab, [ab]);
    } catch (e) {
      postThrew = true;
    }

    if (postThrew) {
      stats.post_throw++;
      // cleanup
      try { ch.port1.close(); ch.port2.close(); } catch(_){}
      return;
    }

    // Observação do senderLen imediatamente após postMessage:
    // se transfer ocorreu, senderLen tende a 0 "logo"; mas pode ser assíncrono.
    // Então usamos duas janelas:
    //   - FastTimeout: diagnostica "drop_fast"
    //   - LateCheck: confirma entrega tardia vs drop confirmado
    const t0 = ts();

    // Fast wait (mínimo)
    if (cfg.fastMs > 0) await sleep(cfg.fastMs);

    const senderLenFast = ab.byteLength; // 0 ou abSize (ou algo impossível)
    if (senderLenFast !== 0 && senderLenFast !== abSize) {
      stats.sender_impossible++;
      if (samples.sender_impossible.length < 3) {
        samples.sender_impossible.push({ i, senderLenFast, abSize });
      }
      try { ch.port1.close(); ch.port2.close(); } catch(_){}
      return;
    }

    // Se já chegou algo, é "detach_ok_fast" (entrega rápida)
    if (gotPayload !== undefined) {
      stats.detach_ok_fast++;
      // opcional: sanity do tipo
      const okType = (Object.prototype.toString.call(gotPayload) === "[object ArrayBuffer]");
      if (!okType) stats.bad_payload_type++;
      // cleanup
      try { ch.port1.close(); ch.port2.close(); } catch(_){}
      return;
    }

    // Se ainda não chegou e senderLenFast==0 => drop_fast candidato
    let sawDropFast = false;
    if (senderLenFast === 0) {
      stats.drop_fast++;
      sawDropFast = true;
    } else {
      // senderLenFast==abSize e sem payload: isso é "no_detach_or_clone_fast"
      stats.no_detach_or_clone_fast++;
    }

    // Pós-drop_fast: probe de fila (K mensagens) para ver invariantes (ordem/contagem)
    // Importante: só faz se drop_fast (para manter base do seu sinal).
    if (sawDropFast && cfg.K > 0) {
      // Pressão leve antes de postar fila (para simular condições onde drop_fast aparece)
      const keep = pressure(cfg.pressure);
      await Promise.resolve();

      // Envia K msgs com attemptId e seq
      try {
        for (let k = 1; k <= cfg.K; k++) {
          ch.port1.postMessage({ __attemptId: attemptId, seq: k });
        }
      } catch (e) {
        stats.queue_post_throw++;
      }

      // mantém keep vivo
      if (keep && keep.length) keep[0][0] ^= 0;
    }

    // Late window: espera até lateMs (contado desde t0)
    const remaining = Math.max(0, cfg.lateMs - (ts() - t0));
    if (remaining > 0) await sleep(remaining);

    const senderLenLate = ab.byteLength;

    // Classificação final do payload
    if (gotPayload === undefined) {
      // Não chegou nada
      if (senderLenLate === 0) {
        stats.drop_confirmed++;
        if (samples.drop_confirmed.length < 3) {
          samples.drop_confirmed.push({ i, senderLenLate, gotType: "undefined" });
        }
      } else {
        // sem payload e senderLen != 0 => clone ou falha de entrega (ou scheduling extremo)
        stats.no_payload_late++;
        if (samples.no_payload_late.length < 3) {
          samples.no_payload_late.push({ i, senderLenLate, abSize });
        }
      }
    } else {
      // Chegou payload no late => entrega tardia
      stats.late_delivery++;
      const dt = gotAt - t0;
      if (samples.late_delivery.length < 3) {
        samples.late_delivery.push({ i, dtMs: dt, senderLenLate });
      }

      const okType = (Object.prototype.toString.call(gotPayload) === "[object ArrayBuffer]");
      if (!okType) stats.bad_payload_type++;
    }

    // Validação de fila (somente se drop_fast)
    if (sawDropFast && cfg.K > 0) {
      // Filtra e valida
      const gotCount = q.length;
      let okCount = (gotCount === cfg.K);
      let okOrder = true;
      for (let idx = 0; idx < Math.min(gotCount, cfg.K); idx++) {
        if (!q[idx] || q[idx].seq !== (idx + 1)) { okOrder = false; break; }
      }

      if (okCount && okOrder) {
        stats.queue_ok++;
      } else {
        stats.queue_invariant_fail++;
        if (samples.queue_fail.length < 3) {
          samples.queue_fail.push({
            i,
            expectK: cfg.K,
            gotCount,
            firstSeq: q[0] ? q[0].seq : null,
            outOfOrder: !okOrder
          });
        }
      }
    }

    // cleanup forte (evita “lixo” entre attempts)
    try { ch.port1.close(); ch.port2.close(); } catch(_){}
  }

  async function runAuto(){
    STOP = false;

    const cfg = {
      N: Math.max(1, ($N.value|0) || 60),
      abSize: Math.max(256, ($abSz.value|0) || 4096),
      fastMs: Math.max(0, ($fast.value|0) || 2),
      lateMs: Math.max(0, ($late.value|0) || 1500),
      delayMs: Math.max(0, ($delay.value|0) || 20),
      pressure: Math.max(0, Math.min(5, ($p.value|0) || 0)),
      K: Math.max(0, Math.min(8, ($K.value|0) || 3))
    };

    logLine("RUN AUTO :: " + j({
      N: cfg.N, abSize: cfg.abSize, fastMs: cfg.fastMs, lateMs: cfg.lateMs,
      delayMs: cfg.delayMs, pressure: cfg.pressure, K: cfg.K
    }));

    const stats = {
      detach_ok_fast: 0,        // payload chegou rápido
      late_delivery: 0,         // payload chegou depois do fast
      drop_fast: 0,             // senderLen=0 e sem payload no fast
      drop_confirmed: 0,        // senderLen=0 e sem payload até late
      no_detach_or_clone_fast: 0,
      no_payload_late: 0,

      post_throw: 0,
      queue_post_throw: 0,

      sender_impossible: 0,
      bad_payload_type: 0,

      queue_ok: 0,
      queue_invariant_fail: 0
    };

    const samples = {
      late_delivery: [],
      drop_confirmed: [],
      queue_fail: [],
      sender_impossible: [],
      no_payload_late: []
    };

    for (let i = 0; i < cfg.N; i++) {
      if (STOP) break;
      await runAttempt(i, cfg, stats, samples);

      if ((i + 1) % 10 === 0) logLine("progress: " + (i + 1) + "/" + cfg.N);
      if (cfg.delayMs) await sleep(cfg.delayMs);
    }

    logLine("RESULT SUMMARY:");
    logLine(j(stats));

    // Só imprime amostras “quentes” (máx 3 cada)
    const hot = [];
    if (samples.drop_confirmed.length) hot.push({ kind: "drop_confirmed", samples: samples.drop_confirmed });
    if (samples.queue_fail.length)     hot.push({ kind: "queue_invariant_fail", samples: samples.queue_fail });
    if (samples.late_delivery.length)  hot.push({ kind: "late_delivery", samples: samples.late_delivery });
    if (samples.sender_impossible.length) hot.push({ kind: "sender_impossible", samples: samples.sender_impossible });
    if (samples.no_payload_late.length) hot.push({ kind: "no_payload_late", samples: samples.no_payload_late });

    if (hot.length) {
      logLine("SAMPLES (hot):");
      logLine(j(hot));
    }

    logLine("DONE.");
  }

  document.getElementById("run").onclick = () => runAuto().catch(e => logLine("ERR: " + (e && e.name ? e.name : String(e))));
  document.getElementById("stop").onclick = () => { STOP = true; logLine("STOP requested."); };
  document.getElementById("reset").onclick = resetLog;

  resetLog();
})();
</script>
</body>
</html>
