<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TEST 09 - Regex ReDOS + GC + String Explosion</title>
</head>
<body>

<h2>TEST 09 - Regex Catastrophic Backtracking + String OOM</h2>
<p>Alvo: crash via regex ReDOS, alocacao massiva de strings, pressao sobre string heap</p>
<p>API: RegExp, String, Array.join</p>
<p>Tecnica: ReDOS para travar JS thread + string bomb para OOM + interned string flood</p>

<pre id="log">Aguardando inicio...</pre>
<button onclick="testReDOS()">REDOS (CUIDADO: pode travar UI)</button>
<button onclick="testStringBomb()">STRING BOMB</button>
<button onclick="testRegexHeap()">REGEX HEAP FLOOD</button>
<button onclick="testStringConcat()">STRING CONCAT OOM</button>

<script>
var log = document.getElementById('log');

function append(msg) {
  log.textContent += '\n' + msg;
}

function testReDOS() {
  append('[09] ReDOS: regex com backtracking catastrofico...');
  append('[09] AVISO: pode travar o browser completamente!');

  // Regex classico com backtracking catastrofico
  var redos_patterns = [
    // Pattern 1: (a+)+ classico
    { re: /^(a+)+$/, input: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab', name: 'a+)+ classico' },
    // Pattern 2: alternation com prefix comum
    { re: /^(a|aa)+$/, input: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaab', name: '(a|aa)+' },
    // Pattern 3: nested quantifiers
    { re: /^([a-zA-Z]+)*$/, input: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!', name: '([a-zA-Z]+)*' },
  ];

  for (var i = 0; i < redos_patterns.length; i++) {
    var p = redos_patterns[i];
    append('[09] Testando: ' + p.name + ' | input len=' + p.input.length);

    var start = Date.now();
    try {
      var r = p.re.test(p.input);
      var elapsed = Date.now() - start;
      append('[09] ' + p.name + ': result=' + r + ' | tempo=' + elapsed + 'ms');
      if (elapsed > 5000) {
        append('[09] *** REDOS ATIVO: ' + elapsed + 'ms para match ***');
      }
    } catch(e) {
      append('[09] ' + p.name + ' EXCECAO: ' + e.message);
    }
  }
}

function testStringBomb() {
  append('[09] String bomb: crescimento exponencial de string...');

  try {
    var s = 'A';
    var iterations = 0;

    while (s.length < 2147483647) { // Max 32-bit int
      s = s + s; // Dobra o tamanho a cada iteracao
      iterations++;
      append('[09] Iter ' + iterations + ': string.length = ' + s.length);

      if (s.length > 500 * 1024 * 1024) { // 500MB threshold
        append('[09] String de 500MB+ criada. Tentando operacoes...');

        // Operacoes em string gigante
        var idx = s.indexOf('B'); // deve ser -1 - busca em 500MB de 'A'
        append('[09] indexOf result: ' + idx);

        var sub = s.substring(s.length - 1000, s.length);
        append('[09] substring(last 1000): len=' + sub.length);

        // Tentar criar uma segunda string gigante
        var s2 = s + 'B' + s; // 2x o tamanho + 1
        append('[09] String duplicada: s2.length=' + s2.length);
        break;
      }
    }
  } catch(e) {
    append('[09] String bomb EXCECAO: ' + e.message);
  }
}

function testRegexHeap() {
  append('[09] Regex heap flood: criando 100k objetos RegExp...');

  var regexes = [];
  try {
    for (var i = 0; i < 100000; i++) {
      // Cada regex tem pattern diferente para evitar cache
      var pattern = 'test_' + i + '_([a-z]+){' + (i % 10 + 1) + '}';
      regexes.push(new RegExp(pattern, 'gi'));

      if (i % 10000 === 0) {
        append('[09] Regex criados: ' + i);
      }
    }

    append('[09] 100k RegExp criados. Executando todos contra string...');
    var testStr = 'test_12345_abcdefghij';

    var matchCount = 0;
    for (var j = 0; j < regexes.length; j++) {
      if (regexes[j].test(testStr)) matchCount++;
    }

    append('[09] Matches encontrados: ' + matchCount);

    // Agora forcar GC com todos os regex ainda na memoria
    append('[09] Forcando pressao de memoria com regex vivos...');
    var pressure = [];
    for (var k = 0; k < 1000000; k++) {
      pressure.push(k.toString(36));
    }
    pressure = null;
    append('[09] Pressao aplicada');

  } catch(e) {
    append('[09] Regex heap EXCECAO: ' + e.message);
  }
}

function testStringConcat() {
  append('[09] String concat OOM: concatenacao massiva em loop...');

  try {
    var parts = [];
    var PARTS = 1000000;

    // Criar array de 1M strings pequenas
    for (var i = 0; i < PARTS; i++) {
      parts.push('abcdefghij' + i); // ~15 chars each = ~15MB total
    }
    append('[09] Array de ' + PARTS + ' strings criado');

    // Join para criar mega-string de ~15GB (provavelmente vai falhar)
    append('[09] Tentando join de ' + PARTS + ' strings...');
    var big = parts.join('|');
    append('[09] Join OK: resultado.length=' + big.length);

    // Split de volta
    append('[09] Tentando split em ' + big.length + ' chars...');
    var back = big.split('|');
    append('[09] Split OK: ' + back.length + ' partes');

    // Regex replace em string gigante
    append('[09] Tentando replace em string gigante...');
    var replaced = big.replace(/abcdefghij(\d+)/g, 'x$1');
    append('[09] Replace OK: len=' + replaced.length);

  } catch(e) {
    append('[09] String concat EXCECAO: ' + e.message);
  }
}
</script>

</body>
</html>
