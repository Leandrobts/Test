<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>TEST 10 - rAF + Detached Node Race</title>
</head>
<body>

<h2>TEST 10 - requestAnimationFrame + Detached Node Race</h2>
<p>Alvo: use-after-free via race entre rAF callback e remocao de nos do DOM</p>
<p>API: requestAnimationFrame, MutationObserver, DOM manipulation</p>
<p>Tecnica: agendar callbacks em nos que serao removidos antes da execucao</p>

<div id="arena"></div>
<pre id="log">Aguardando inicio...</pre>
<button onclick="testRAFRace()">RAF + DETACH RACE</button>
<button onclick="testMutationRAF()">MUTATION OBSERVER + RAF</button>
<button onclick="testEventDetach()">EVENT LISTENER + DETACH</button>
<button onclick="testAnimationDetach()">CSS ANIMATION + DETACH</button>

<script>
var log = document.getElementById('log');
var arena = document.getElementById('arena');
var running = false;

function append(msg) {
  log.textContent += '\n' + msg;
}

function testRAFRace() {
  append('[10] rAF + detach race iniciado...');
  running = true;
  var frame = 0;
  var nodes = [];
  var detached_accesses = 0;

  // Criar multiplos nos com canvas
  for (var i = 0; i < 100; i++) {
    var div = document.createElement('div');
    var canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    div.appendChild(canvas);
    arena.appendChild(div);
    nodes.push({div: div, canvas: canvas, ctx: canvas.getContext('2d')});
  }

  append('[10] 100 canvas nodes criados no DOM');

  // rAF loop que desenha em todos os canvas
  function rafCallback(timestamp) {
    if (!running || frame > 5000) {
      append('[10] Loop encerrado em frame ' + frame + ' | detached_accesses=' + detached_accesses);
      return;
    }

    // Desenhar em TODOS os canvas, incluindo possivelmente detachados
    for (var j = 0; j < nodes.length; j++) {
      try {
        var n = nodes[j];
        // canvas e seu ctx podem estar detachados neste momento
        n.ctx.fillRect(0, frame % 256, 256, 1);
        n.ctx.getImageData(0, 0, 256, 256); // Leitura pesada em canvas potencialmente detachado

        if (!document.contains(n.div)) {
          detached_accesses++;
          // Acesso a canvas detachado do DOM - comportamento undefined em alguns WebKit
          n.ctx.fillStyle = '#' + frame.toString(16).slice(-6).padStart(6, '0');
          n.ctx.fillRect(0, 0, 256, 256);
        }
      } catch(e) {
        append('[10] rAF canvas excecao frame=' + frame + ' node=' + j + ': ' + e.message);
      }
    }

    // Remover e re-adicionar nos randomicamente durante o loop
    if (frame % 3 === 0) {
      var idx = Math.floor(Math.random() * nodes.length);
      var node = nodes[idx];
      if (node.div.parentNode) {
        arena.removeChild(node.div); // Detach enquanto rAF pode estar processando
      } else {
        arena.appendChild(node.div); // Re-attach
      }
    }

    frame++;
    requestAnimationFrame(rafCallback);
  }

  requestAnimationFrame(rafCallback);
}

function testMutationRAF() {
  append('[10] MutationObserver + rAF: modificacoes DOM durante render...');

  var mutCount = 0;
  var rafCount = 0;

  // Observer que agenda rAF durante mutacao
  var observer = new MutationObserver(function(mutations) {
    mutCount++;
    // Agendar RAF durante callback de mutacao (nested scheduling)
    requestAnimationFrame(function() {
      rafCount++;
      // Dentro do rAF: fazer mais mutacoes DOM que vao disparar novo observer
      var el = document.createElement('span');
      el.textContent = 'r' + rafCount;

      if (arena.children.length > 10000) {
        // Limpar para evitar OOM, mas de forma potencialmente racing
        arena.innerHTML = '';
      } else {
        arena.appendChild(el);
        // Remover imediatamente para criar race entre observer e render
        if (rafCount % 2 === 0) {
          arena.removeChild(el);
        }
      }
    });
  });

  observer.observe(arena, {
    childList: true,
    subtree: true,
    attributes: true,
    characterData: true
  });

  append('[10] MutationObserver instalado. Iniciando mutacoes em cascata...');

  // Iniciar cadeia de mutacoes
  function cascade(depth) {
    if (depth > 200) {
      observer.disconnect();
      append('[10] Cascade completo: mutCount=' + mutCount + ' rafCount=' + rafCount);
      return;
    }

    arena.appendChild(document.createElement('div'));
    setTimeout(function() { cascade(depth + 1); }, 10);
  }

  cascade(0);
}

function testEventDetach() {
  append('[10] Event listener em nos detachados...');

  var nodes = [];
  var fired = 0;
  var NODES = 10000;

  // Criar nos com event listeners
  for (var i = 0; i < NODES; i++) {
    var el = document.createElement('div');
    el.textContent = i;

    // Closure que referencia o elemento - cria ciclo de retencao
    (function(element, index) {
      element.addEventListener('click', function(e) {
        fired++;
        append('[10] Click disparado em node ' + index + ' | no DOM: ' + document.contains(element));
      });

      // Listener de scroll em elemento que pode ser detachado
      element.addEventListener('animationend', function(e) {
        // Tentar acessar propriedades do elemento apos possivelmente detachado
        var rect = element.getBoundingClientRect();
        append('[10] animationend em node ' + index + ' | rect: ' + JSON.stringify(rect));
      });
    })(el, i);

    arena.appendChild(el);
    nodes.push(el);
  }

  append('[10] ' + NODES + ' nodes com listeners criados');

  // Remover todos do DOM mas manter referencias JS
  for (var j = 0; j < nodes.length; j++) {
    nodes[j].parentNode && nodes[j].parentNode.removeChild(nodes[j]);
  }

  append('[10] Todos os nodes removidos do DOM. Disparando eventos sinteticamente...');

  // Disparar eventos em nos detachados
  for (var k = 0; k < nodes.length; k++) {
    try {
      var evt = document.createEvent('Event');
      evt.initEvent('click', true, true);
      nodes[k].dispatchEvent(evt);

      var evt2 = document.createEvent('Event');
      evt2.initEvent('animationend', true, true);
      nodes[k].dispatchEvent(evt2);
    } catch(e) {
      append('[10] dispatchEvent excecao node ' + k + ': ' + e.message);
    }
  }

  append('[10] Eventos disparados em nodes detachados: fired=' + fired);
}

function testAnimationDetach() {
  append('[10] CSS animation start + detach rapido...');

  var style = document.createElement('style');
  style.textContent = '@keyframes spin { from { opacity:1 } to { opacity:0.5 } }';
  document.head.appendChild(style);

  var detach_count = 0;

  function spawnAndDetach() {
    var el = document.createElement('div');
    el.style.animation = 'spin 0.1s linear infinite';
    el.style.width = '10px';
    el.style.height = '10px';

    el.addEventListener('animationstart', function() {
      // Remover imediatamente ao comecar animacao
      if (el.parentNode) {
        el.parentNode.removeChild(el);
        detach_count++;
      }
    });

    el.addEventListener('animationiteration', function() {
      // Tentar re-adicionar e remover durante iteracao
      if (!el.parentNode) {
        arena.appendChild(el);
        requestAnimationFrame(function() {
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          }
        });
      }
    });

    arena.appendChild(el);
  }

  // Criar 1000 elementos com animacoes que serao detachados imediatamente
  append('[10] Criando 1000 elementos com CSS animations para detach race...');
  for (var i = 0; i < 1000; i++) {
    spawnAndDetach();
  }

  setTimeout(function() {
    append('[10] Animation detach: ' + detach_count + ' elementos detachados durante animationstart');
    append('[10] arena.children: ' + arena.children.length);
  }, 2000);
}
</script>

</body>
</html>
