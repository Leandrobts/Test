<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 17 - WeakMap Object Lifecycle</title></head>
<body>
<h2>TEST 17 - WeakMap / WeakRef Lifecycle Abuse</h2>
<p>Alvo: UAF via ressurreicao de objeto fraco / acesso apos finalizacao</p>
<p>API: WeakMap, WeakSet, WeakRef (se disponivel), FinalizationRegistry (se disponivel)</p>
<p>Tecnica: "ressurreicao" de objeto - um objeto morto e re-referenciado durante o callback
de finalizacao, criando um objeto zumbi que o GC ja liberou parcialmente.
Tambem testa acesso a valores de WeakMap apos a chave ter sido coletada.</p>

<pre id="log">Aguardando...</pre>
<button onclick="checkAPIs()">CHECAR APIs</button>
<button onclick="testWeakMapLeak()">WEAKMAP KEY LEAK</button>
<button onclick="testWeakRefZombie()">WEAKREF ZOMBIE</button>
<button onclick="testFinalizationRace()">FINALIZATION REGISTRY</button>
<button onclick="testWeakSetConfusion()">WEAKSET CONFUSION</button>

<script>
var log = document.getElementById('log');
function append(msg) { log.textContent += '\n' + msg; }

function forceGC() {
  var t = [];
  for (var i = 0; i < 100000; i++) t.push({x:i});
  t = null;
}

function checkAPIs() {
  append('[17] Verificando APIs de weak references...');
  append('[17] WeakMap: ' + (typeof WeakMap !== 'undefined' ? 'PRESENTE' : 'AUSENTE'));
  append('[17] WeakSet: ' + (typeof WeakSet !== 'undefined' ? 'PRESENTE' : 'AUSENTE'));
  append('[17] WeakRef: ' + (typeof WeakRef !== 'undefined' ? 'PRESENTE' : 'AUSENTE'));
  append('[17] FinalizationRegistry: ' + (typeof FinalizationRegistry !== 'undefined' ? 'PRESENTE' : 'AUSENTE'));
}

function testWeakMapLeak() {
  append('[17] WeakMap: acessar valor apos chave ser coletada...');
  try {
    var wm = new WeakMap();
    var ENTRIES = 10000;

    // Criar muitas entradas no WeakMap com chaves temporarias
    (function() {
      for (var i = 0; i < ENTRIES; i++) {
        var key = {id: i, data: new Float64Array(128)}; // ~1KB cada
        var val = {secret: 0xDEAD + i, ref: key};
        wm.set(key, val);
      }
      append('[17] ' + ENTRIES + ' entradas no WeakMap (chaves locais, saem de escopo)');
      // key vai sair de escopo aqui - GC pode coletar
    })();

    // Forcam GC para coletar as chaves
    forceGC();
    forceGC();
    forceGC();
    append('[17] GC forcado 3x');

    // Tentar acessar via WeakMap - sem a chave, impossivel por design
    // Mas verificar se o proprio WeakMap ficou corrompido
    var testKey = {test: true};
    wm.set(testKey, {value: 999});
    var got = wm.get(testKey);
    append('[17] wm.get(testKey) apos GC: ' + (got ? got.value : 'null'));
    append('[17] wm.has(testKey): ' + wm.has(testKey));

    // Verificar se delete funciona corretamente apos GC
    wm.delete(testKey);
    append('[17] Apos delete: wm.has(testKey)=' + wm.has(testKey));

  } catch(e) {
    append('[17] WeakMap leak EXCECAO: ' + e.message);
  }
}

function testWeakRefZombie() {
  if (typeof WeakRef === 'undefined') {
    append('[17] WeakRef nao disponivel neste browser');
    return;
  }

  append('[17] WeakRef zombie: ressuscitar objeto durante deref...');
  try {
    var zombie = null;
    var ref = null;
    var resurrectCount = 0;

    // Criar objeto e WeakRef para ele
    (function createTarget() {
      var target = {
        alive: true,
        data: new ArrayBuffer(1024 * 64), // 64KB
        resurrect: function() {
          // Se chamado durante finalizacao, ressuscita o objeto
          zombie = this; // Re-referencia a si mesmo
          resurrectCount++;
          append('[17] Objeto ressuscitado! resurrectCount=' + resurrectCount);
        }
      };
      ref = new WeakRef(target);
      append('[17] WeakRef criado para target');
      // target sai de escopo aqui
    })();

    append('[17] Target saiu de escopo. Ref ainda vivo? ' + (ref.deref() !== undefined));

    // Forcam GC
    forceGC();
    forceGC();

    // Tentar deref apos GC
    var derefed = ref.deref();
    if (derefed !== undefined) {
      append('[17] ref.deref() ainda retornou objeto! (GC nao coletou)');
      append('[17] derefed.alive: ' + derefed.alive);
      // Chamar resurrect para manter vivo
      derefed.resurrect();
    } else {
      append('[17] ref.deref() retornou undefined (GC coletou corretamente)');
    }

    // Se zombie foi definido, o objeto foi ressuscitado durante o GC
    if (zombie) {
      append('[17] zombie ainda acessivel: ' + zombie.alive);
      append('[17] zombie.data.byteLength: ' + zombie.data.byteLength);
      // Null e forcam GC novamente - objeto zumbi pode ser coletado agora
      zombie = null;
      forceGC();
      append('[17] zombie nulificado. ref.deref() = ' + (ref.deref() !== undefined ? 'ainda vivo' : 'morto'));
    }

  } catch(e) {
    append('[17] WeakRef zombie EXCECAO: ' + e.message);
  }
}

function testFinalizationRace() {
  if (typeof FinalizationRegistry === 'undefined') {
    append('[17] FinalizationRegistry nao disponivel');
    return;
  }

  append('[17] FinalizationRegistry race: acessar objeto no callback de finalizacao...');
  try {
    var resurrected = [];
    var callbackCount = 0;

    var registry = new FinalizationRegistry(function(heldValue) {
      callbackCount++;
      append('[17] Finalization callback #' + callbackCount + ' | heldValue.id=' + heldValue.id);

      // Tentar ressuscitar o objeto usando o heldValue como gancho
      // (o proprio objeto alvo ja foi coletado, mas heldValue ainda existe)
      resurrected.push({
        id: heldValue.id,
        data: heldValue.bigData, // bigData pode ser referencia ao objeto morto?
        phantom: heldValue
      });

      // Tentar alocar no local que o objeto morto ocupava
      for (var i = 0; i < 100; i++) {
        var replacement = new ArrayBuffer(heldValue.size || 1024);
        resurrected.push(replacement);
      }
    });

    // Registrar objetos com held value que contem referencia ao proprio objeto
    (function() {
      for (var i = 0; i < 50; i++) {
        var obj = {
          id: i,
          data: new Float64Array(256),
          circular: null // sera preenchido
        };
        // held value contem referencia ao obj - mesmo tamanho/layout
        var held = {id: i, bigData: obj.data, size: obj.data.byteLength};
        obj.circular = held; // obj -> held
        registry.register(obj, held, obj);
        // obj sai de escopo - GC pode coletar, callback sera chamado
      }
      append('[17] 50 objetos registrados no FinalizationRegistry');
    })();

    forceGC();
    forceGC();

    append('[17] GC forcado. Aguardando callbacks...');

    setTimeout(function() {
      append('[17] Callbacks recebidos: ' + callbackCount);
      append('[17] Objetos ressuscitados: ' + resurrected.length);
      // Verificar se os ressuscitados estao intactos
      for (var j = 0; j < Math.min(resurrected.length, 5); j++) {
        var r = resurrected[j];
        if (r && r.id !== undefined) {
          append('[17] resurrected[' + j + '].id: ' + r.id);
        }
      }
    }, 3000);

  } catch(e) {
    append('[17] FinalizationRegistry EXCECAO: ' + e.message);
  }
}

function testWeakSetConfusion() {
  append('[17] WeakSet: has() apos GC e confusion com objetos similares...');
  try {
    var ws = new WeakSet();
    var keys = [];

    // Adicionar 1000 objetos com layout identico
    for (var i = 0; i < 1000; i++) {
      var obj = {x: 1.1, y: 2.2, z: 3.3}; // mesmo layout
      ws.add(obj);
      if (i < 10) keys.push(obj); // manter refs para os primeiros 10
    }

    append('[17] WeakSet: 1000 entradas | keeping refs para 10');
    append('[17] ws.has(keys[0]): ' + ws.has(keys[0]));

    // GC para coletar as 990 sem referencia
    forceGC();
    forceGC();

    append('[17] Apos GC: ws.has(keys[0]): ' + ws.has(keys[0]));
    append('[17] Apos GC: ws.has(keys[9]): ' + ws.has(keys[9]));

    // Criar novo objeto com mesmo layout - nao deve estar no set
    var impostor = {x: 1.1, y: 2.2, z: 3.3};
    append('[17] ws.has(impostor com mesmo layout): ' + ws.has(impostor));

    // Adicionar impostor e checar
    ws.add(impostor);
    append('[17] Apos add(impostor): ws.has(impostor)=' + ws.has(impostor));
    append('[17] ws.has(keys[0]) ainda: ' + ws.has(keys[0]));

    // Deletar uma key real e verificar se impostor ainda esta
    ws.delete(keys[0]);
    append('[17] Apos delete(keys[0]): ws.has(keys[0])=' + ws.has(keys[0]));
    append('[17] ws.has(impostor) apos delete de keys[0]: ' + ws.has(impostor));

  } catch(e) {
    append('[17] WeakSet confusion EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
