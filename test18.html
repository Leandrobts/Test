<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 18 - eval / Function JIT Deopt</title></head>
<body>
<h2>TEST 18 - eval + Function Constructor JIT Deoptimization</h2>
<p>Alvo: crash via deoptimizacao forcada de funcoes JIT via eval e Function() dinamicos</p>
<p>API: eval, Function constructor, with statement (se disponivel), dynamic scoping</p>
<p>Tecnica: JSC tem optimistic JIT que assume variaveis nao sao afetadas por eval.
Introduzir eval em um escopo onde JIT ja especializou funcoes forca deoptimizacao.
Em versoes antigas do WebKit, o caminho de deopt pode ter UAF.</p>

<pre id="log">Aguardando...</pre>
<button onclick="testEvalDeopt()">EVAL DEOPT</button>
<button onclick="testFunctionRecompile()">FUNCTION RECOMPILE</button>
<button onclick="testEvalScopeEscape()">EVAL SCOPE ESCAPE</button>
<button onclick="testWithStatement()">WITH STATEMENT</button>

<script>
var log = document.getElementById('log');
function append(msg) { log.textContent += '\n' + msg; }

function forceGC() {
  var t = []; for (var i = 0; i < 30000; i++) t.push({a:i}); t = null;
}

function testEvalDeopt() {
  append('[18] Eval deoptimization: contaminar escopo de funcao JIT-compilada...');
  try {
    var x = 1.337;
    var y = 2.674;

    // Funcao que sera JIT-compilada
    // JSC assume que x e y sao escalares simples no closure
    function hotFn() {
      return x + y; // JIT especializa: assume double + double
    }

    // Warmup
    var sum = 0;
    for (var i = 0; i < 200000; i++) {
      sum += hotFn();
    }
    append('[18] Warmup: sum=' + sum + ' | hotFn esperado=' + (1.337 + 2.674));

    // Agora introduzir eval no mesmo escopo
    // Em non-strict: eval pode criar variaveis que afetam o closure
    eval('x = {evil: "object", valueOf: function() { append("[18] valueOf chamado!"); return 9.9; }}');
    append('[18] eval executado: x agora e ' + typeof x);

    // JIT precisa deoptimizar hotFn pois x mudou de tipo
    var result = hotFn();
    append('[18] hotFn() apos eval: ' + result);
    append('[18] Esperado: 9.9 + 2.674 = ' + (9.9 + 2.674));

    // Mais agressivo: eval que redefine a funcao em si
    eval('function hotFn() { return "SUBSTITUIDA"; }');
    try {
      var r2 = hotFn();
      append('[18] hotFn() apos redefinicao por eval: ' + r2);
    } catch(e2) {
      append('[18] hotFn() apos redefinicao: EXCECAO ' + e2.message);
    }

  } catch(e) {
    append('[18] Eval deopt EXCECAO: ' + e.message);
  }
}

function testFunctionRecompile() {
  append('[18] Function constructor: recompilacao dinamica em loop...');
  try {
    var compiled_fns = [];
    var results = [];

    // Criar 10000 funcoes com codigo ligeiramente diferente
    // para estressar o compilador JIT
    for (var i = 0; i < 10000; i++) {
      var code = 'return ' + i + '.0 + a + b;';
      var fn = new Function('a', 'b', code);
      compiled_fns.push(fn);
    }
    append('[18] 10000 funcoes compiladas via Function()');

    // Executar todas em serie (JIT vai tentar otimizar)
    var total = 0;
    for (var j = 0; j < compiled_fns.length; j++) {
      try {
        var r = compiled_fns[j](1.1, 2.2);
        total += r;
      } catch(e2) {
        append('[18] fn[' + j + '] EXCECAO: ' + e2.message);
      }
    }
    append('[18] total: ' + total);

    // Agora substituir funcoes no meio com versoes que tem tipos diferentes
    for (var k = 0; k < 10000; k += 100) {
      compiled_fns[k] = new Function('a', 'b', 'return {x: a, y: b};'); // retorna objeto!
    }
    append('[18] 100 funcoes substituidas para retornar objeto');

    // Executar novamente - mix de double e object returns
    var total2 = 0;
    var objCount = 0;
    for (var m = 0; m < compiled_fns.length; m++) {
      try {
        var r2 = compiled_fns[m](1.1, 2.2);
        if (typeof r2 === 'object') {
          objCount++;
        } else {
          total2 += r2;
        }
      } catch(e3) {
        append('[18] fn[' + m + '] segunda passagem EXCECAO: ' + e3.message);
      }
    }
    append('[18] Segunda passagem: total2=' + total2 + ' | objCount=' + objCount);

  } catch(e) {
    append('[18] Function recompile EXCECAO: ' + e.message);
  }
}

function testEvalScopeEscape() {
  append('[18] eval scope escape: vazar referencia de escopo interno...');
  try {
    var leaked_fn = null;

    (function outerScope() {
      var SECRET = new ArrayBuffer(1024 * 64); // 64KB - queremos "escapar" isso
      var secretView = new Uint32Array(SECRET);
      secretView[0] = 0xDEADC0DE;

      // eval cria funcao que tem acesso ao escopo de outerScope
      eval('leaked_fn = function() { return secretView[0]; }');

      append('[18] leaked_fn definida via eval dentro do escopo com SECRET');
      append('[18] Dentro do escopo: leaked_fn() = 0x' + leaked_fn().toString(16));
    })();

    // outerScope terminou - SECRET deveria ser elegivel para GC
    // Mas leaked_fn ainda tem referencia ao closure (via eval)
    forceGC();
    forceGC();

    append('[18] Apos GC: chamando leaked_fn() do escopo externo...');
    var val = leaked_fn();
    append('[18] leaked_fn() = 0x' + val.toString(16));

    if (val === 0xDEADC0DE) {
      append('[18] Valor preservado: closure manteve SECRET vivo (esperado mas interessante)');
    } else {
      append('[18] *** VALOR INESPERADO: possivel UAF ou corrupcao de closure! ***');
    }

    // Nulificar leaked_fn e verificar GC
    leaked_fn = null;
    forceGC();
    forceGC();
    append('[18] leaked_fn nulificada. SECRET deve ser elegivel para GC agora.');

  } catch(e) {
    append('[18] Eval scope escape EXCECAO: ' + e.message);
  }
}

function testWithStatement() {
  append('[18] with statement: interceptar leitura de variaveis via proxy-like object...');
  try {
    // 'with' cria escopo adicional que intercepta acesso a propriedades
    var interceptor = {
      x: 1.337,
      y: 2.674,
      toString: function() { return '[interceptor]'; }
    };

    var capturedAccess = [];

    // Usar Proxy como objeto do 'with' para capturar cada acesso
    if (typeof Proxy !== 'undefined') {
      var proxyInterceptor = new Proxy(interceptor, {
        has: function(target, prop) {
          capturedAccess.push('has:' + String(prop));
          return prop in target;
        },
        get: function(target, prop) {
          capturedAccess.push('get:' + String(prop));
          return target[prop];
        }
      });

      // 'with' com Proxy - cada acesso a variavel vai checar o proxy primeiro
      with(proxyInterceptor) {
        var sumWith = x + y;
        append('[18] x + y via with(proxy): ' + sumWith);
        append('[18] Acessos capturados: ' + capturedAccess.join(', '));
      }

      // Agora mudar o proxy durante execucao com 'with'
      var withResult = 0;
      proxyInterceptor = new Proxy({
        x: {valueOf: function() { return 13.37; }},
        y: 26.74
      }, {
        has: function(t, p) { return p === 'x' || p === 'y'; },
        get: function(t, p, r) { return Reflect.get(t, p, r); }
      });

      with(proxyInterceptor) {
        withResult = x + y; // x.valueOf() sera chamado
        append('[18] x + y via with(proxy com valueOf): ' + withResult);
      }

    } else {
      // Fallback sem Proxy
      with(interceptor) {
        var r = x + y;
        append('[18] x + y via with(object): ' + r);
      }
      append('[18] Proxy nao disponivel para interceptar with');
    }

  } catch(e) {
    append('[18] with statement EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
