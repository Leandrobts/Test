<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 23 - DataView Aliasing + Detach</title></head>
<body>
<h2>TEST 23 — DataView Aliasing + Detach Race</h2>
<p><b>Alvo:</b> crash / leitura invalida via DataView sobre buffer transferido ou substituido</p>
<p><b>Por que crasha:</b> DataView mantem uma referencia interna ao backing store do ArrayBuffer.
Se o buffer e detachado (via transferencia) enquanto multiplos DataViews ainda o
referenciam, acessos subsequentes podem ser UAF. Alem disso, DataView de diferentes
tipos sobre o mesmo buffer pode revelar reinterpretacao de bits internos do JSC.</p>

<pre id="log">Pronto.</pre>
<button onclick="runTest1()">DATAVIEW MULTI-TIPO</button>
<button onclick="runTest2()">DATAVIEW APOS DETACH</button>
<button onclick="runTest3()">DATAVIEW OFFSET OOB</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }

function forceGC() {
  var t=[]; for(var i=0;i<50000;i++) t.push({x:i}); t=null;
}

function runTest1() {
  log.textContent = '[TEST 23-A] DataView multi-tipo sobre mesmo buffer...\n';
  try {
    var buf = new ArrayBuffer(256);

    // Criar varios tipos de views sobre o mesmo buffer
    var dv    = new DataView(buf);
    var f64   = new Float64Array(buf);
    var u32   = new Uint32Array(buf);
    var u8    = new Uint8Array(buf);
    var i16   = new Int16Array(buf);

    // Escrever via DataView e ler via TypedArray (aliasing de bytes)
    dv.setFloat64(0, 1.337, true); // little-endian
    var asU32Lo = u32[0];
    var asU32Hi = u32[1];
    var asF64   = f64[0];

    info('Escreveu 1.337 via DataView[0..7]');
    info('u32[0] (low bytes): 0x' + asU32Lo.toString(16).padStart(8,'0'));
    info('u32[1] (high bytes): 0x' + asU32Hi.toString(16).padStart(8,'0'));
    info('f64[0] readback: ' + asF64);

    if(asF64 !== 1.337) {
      alerta('MISMATCH float64: escreveu 1.337 mas leu ' + asF64 + ' — possivel corrupcao de bytes!');
    }

    // Escrever um "NaN boxing" manualmente e verificar como o JSC trata
    // JSC usa NaN-boxing: valores JS sao codificados como doubles especiais
    // Tentar escrever um valor que parece um objeto JSC no heap
    var JSC_OBJECT_TAG = 0xFFFF0001;
    dv.setUint32(8,  0x00001234, true); // low  - simula endereco de objeto
    dv.setUint32(12, JSC_OBJECT_TAG, true); // high - tag de objeto JSC

    var suspect = f64[1]; // ler como double
    info('Valor com tag JSC: ' + suspect + ' | isNaN=' + isNaN(suspect));

    // Se o motor tratar o NaN especial de forma diferente = anomalia
    var suspect_str = '' + suspect;
    info('String form: ' + suspect_str);

    if(suspect_str === 'NaN' && isNaN(suspect)) {
      // Tentar operacoes que o motor pode otimizar assumindo NaN "puro"
      var ops = [
        suspect + 1,
        suspect * 2,
        1 / suspect,
        Math.abs(suspect),
        suspect | 0
      ];
      ops.forEach(function(r, i) {
        info('op[' + i + '] = ' + r);
        if(typeof r === 'object') {
          alerta('OPERACAO EM NaN RETORNOU OBJETO: op[' + i + '] = ' + JSON.stringify(r) + ' — NaN boxing vazou!');
        }
      });
    }

  } catch(e) {
    alerta('EXCECAO: ' + e.message);
  }
}

function runTest2() {
  log.textContent = '[TEST 23-B] DataView apos buffer detachado via postMessage...\n';
  try {
    var buf = new ArrayBuffer(1024 * 512); // 512KB
    var dv1  = new DataView(buf);
    var dv2  = new DataView(buf, 128, 256); // DataView com offset
    var f64  = new Float64Array(buf);

    // Escrever antes de detach
    dv1.setUint32(0,   0xDEADBEEF, true);
    dv1.setFloat64(8,  1.337,      true);
    dv2.setUint32(0,   0xCAFEBABE, true); // escreve em buf[128]

    info('Buffer: ' + buf.byteLength + ' bytes');
    info('Antes do detach: dv1[0]=' + dv1.getUint32(0,true).toString(16));
    info('Antes do detach: dv2[0]=' + dv2.getUint32(0,true).toString(16));

    // Transferir o buffer (detach)
    postMessage('detach', '*', [buf]);
    info('Buffer transferido. byteLength agora=' + buf.byteLength);

    // Tentar acessar via DataViews antigas (backing store nao existe mais)
    var reads = [
      function() { return dv1.getUint32(0, true); },
      function() { return dv1.getFloat64(8, true); },
      function() { return dv2.getUint32(0, true); },
      function() { return f64[0]; },
    ];

    var labels = ['dv1.getUint32(0)', 'dv1.getFloat64(8)', 'dv2.getUint32(0)', 'f64[0]'];

    reads.forEach(function(fn, i) {
      try {
        var val = fn();
        alerta('LEITURA POS-DETACH sem excecao: ' + labels[i] + ' = ' +
          (typeof val === 'number' ? val.toString(16) : val) +
          ' — acesso ao backing store liberado!');
      } catch(e2) {
        ok(labels[i] + ' pos-detach lancou excecao corretamente: ' + e2.message);
      }
    });

    // Tentar criar novo DataView sobre o buffer detachado
    try {
      var dv3 = new DataView(buf);
      alerta('DATAVIEW CRIADO SOBRE BUFFER DETACHADO! byteLength=' + dv3.byteLength + ' — motor permitiu!');
    } catch(e3) {
      ok('new DataView(detachedBuf) lancou excecao: ' + e3.message);
    }

  } catch(e) {
    alerta('EXCECAO GERAL: ' + e.message);
  }
}

function runTest3() {
  log.textContent = '[TEST 23-C] DataView com offset/length no limite e alem...\n';
  try {
    var SIZE = 1024;
    var buf = new ArrayBuffer(SIZE);
    var u8  = new Uint8Array(buf);
    for(var i = 0; i < SIZE; i++) u8[i] = i & 0xFF;

    // Casos de borda de offset e byteLength
    var cases = [
      { offset: 0,      length: SIZE,   label: 'offset=0 length=SIZE (normal)' },
      { offset: SIZE-1, length: 1,      label: 'offset=SIZE-1 length=1 (ultimo byte)' },
      { offset: SIZE,   length: 0,      label: 'offset=SIZE length=0 (um alem)' },
      { offset: SIZE+1, length: 0,      label: 'offset=SIZE+1 (OOB)' },
      { offset: 0,      length: SIZE+1, label: 'length=SIZE+1 (OOB)' },
      { offset: -1,     length: 1,      label: 'offset=-1 (negativo)' },
      { offset: 0,      length: -1,     label: 'length=-1 (negativo)' },
      { offset: 0xFFFFFFFF, length: 1,  label: 'offset=MAX_UINT32' },
    ];

    cases.forEach(function(c) {
      try {
        var dv;
        if(c.length !== undefined) {
          dv = new DataView(buf, c.offset, c.length);
        } else {
          dv = new DataView(buf, c.offset);
        }
        info(c.label + ': OK | byteOffset=' + dv.byteOffset + ' byteLength=' + dv.byteLength);

        // Se criou com offset OOB, tentar ler
        if(c.offset >= SIZE || c.offset < 0) {
          var read = dv.getUint8(0);
          alerta('DATAVIEW OOB CRIADO E LEU: ' + c.label + ' → getUint8(0)=' + read + ' — possivel OOB read!');
        }
      } catch(e2) {
        // Comportamento correto para casos invalidos
        if(c.offset > SIZE || c.offset < 0 || (c.length !== undefined && c.length < 0)) {
          ok(c.label + ' → excecao esperada: ' + e2.message);
        } else {
          alerta('EXCECAO INESPERADA: ' + c.label + ' → ' + e2.message);
        }
      }
    });

    // Escrever via offset maximo e ler no proximo byte
    try {
      var dvEdge = new DataView(buf, SIZE - 4, 4);
      dvEdge.setUint32(0, 0xDEAD1337, true);
      // Tentar ler 1 byte alem do fim
      var beyondEnd = dvEdge.getUint8(4); // byteOffset=SIZE-4+4=SIZE → OOB
      alerta('LEITURA ALEM DO FIM DO DATAVIEW: getUint8(4)=' + beyondEnd + ' — OOB alem do buffer!');
    } catch(e2) {
      ok('getUint8(4) no DataView de borda lancou excecao: ' + e2.message);
    }

  } catch(e) {
    alerta('EXCECAO GERAL: ' + e.message);
  }
}
</script>
</body>
</html>
