<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 27 - Object.freeze Bypass</title></head>
<body>
<h2>TEST 27 — Object.freeze + Escrita via Prototype (Bypass Crash)</h2>
<p><b>Alvo:</b> crash / valor invalido ao tentar escrever em propriedade de objeto frozen via
caminhos alternativos (prototype chain, Reflect, defineProperty, Proxy)</p>
<p><b>Por que crasha:</b> JSC otimiza objetos frozen com um caminho especial no butterfly
(estrutura marcada como imutavel). Se uma escrita chega via caminho que o motor
nao verifica a flag de frozen (ex: Reflect.set sobre proto frozen), pode corromper
o butterfly marcado como imutavel.</p>

<pre id="log">Pronto.</pre>
<button onclick="runTest1()">FROZEN + REFLECT.SET</button>
<button onclick="runTest2()">FROZEN + PROTO CHAIN WRITE</button>
<button onclick="runTest3()">FREEZE DURANTE ENUMERATE</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }

function forceGC() {
  var t=[]; for(var i=0;i<50000;i++) t.push({x:i}); t=null;
}

function runTest1() {
  log.textContent = '[TEST 27-A] Object.freeze + Reflect.set bypass...\n';
  try {
    var target = { x: 1.337, y: 2.674, data: new Float64Array(100) };
    Object.freeze(target);
    info('target frozen. target.x=' + target.x);
    info('Object.isFrozen(target): ' + Object.isFrozen(target));

    // Tentativa 1: escrita direta (deve silenciosamente falhar em non-strict)
    target.x = 9999;
    info('Apos target.x = 9999: target.x=' + target.x);
    if(target.x !== 1.337) {
      alerta('ESCRITA DIRETA EM OBJETO FROZEN FUNCIONOU: target.x=' + target.x + ' — freeze nao foi aplicado!');
    }

    // Tentativa 2: Reflect.set (deve retornar false)
    var reflectResult = Reflect.set(target, 'x', 8888);
    info('Reflect.set(frozen, x, 8888): retornou ' + reflectResult + ' | target.x=' + target.x);
    if(reflectResult === true || target.x === 8888) {
      alerta('Reflect.set EM OBJETO FROZEN RETORNOU TRUE ou escreveu: ' + target.x + ' — bypass de freeze!');
    }

    // Tentativa 3: Object.defineProperty em objeto frozen
    try {
      Object.defineProperty(target, 'x', { value: 7777 });
      alerta('Object.defineProperty EM OBJETO FROZEN NAO LANCOU: target.x=' + target.x);
    } catch(e2) {
      ok('defineProperty em frozen lancou: ' + e2.message);
    }

    // Tentativa 4: __defineSetter__ / __defineGetter__ (legado)
    try {
      target.__defineGetter__('x', function() { return 6666; });
      var val = target.x;
      if(val === 6666) {
        alerta('__defineGetter__ EM OBJETO FROZEN FUNCIONOU: target.x=' + val + ' — getter instalado em objeto imutavel!');
      } else {
        ok('__defineGetter__ em frozen ignorado: target.x=' + val);
      }
    } catch(e2) {
      ok('__defineGetter__ em frozen lancou: ' + e2.message);
    }

    // Tentativa 5: via Proxy de receiver - escrita vai para o receiver (que pode nao ser frozen)
    var receiver = Object.create(target); // herda de target frozen
    var proxyResult = Reflect.set(target, 'x', 5555, receiver);
    info('Reflect.set(frozen, x, 5555, receiver): ' + proxyResult + ' | target.x=' + target.x + ' | receiver.x=' + receiver.x);

    if(target.x !== 1.337) {
      alerta('target.x MODIFICADO via receiver: ' + target.x + ' — escrita atravessou frozen via receiver!');
    }
    if(receiver.x !== undefined && receiver.x !== target.x) {
      ok('Escrita foi para receiver (correto): receiver.x=' + receiver.x);
    }

    forceGC();
    info('Apos GC: target.x=' + target.x + ' | Object.isFrozen(target)=' + Object.isFrozen(target));
    if(!Object.isFrozen(target)) {
      alerta('OBJETO NAO ESTA MAIS FROZEN apos GC! Freeze foi perdido!');
    }

  } catch(e) {
    alerta('EXCECAO GERAL: ' + e.message);
  }
}

function runTest2() {
  log.textContent = '[TEST 27-B] Escrita em propriedade herdada de objeto frozen...\n';
  try {
    var frozenProto = Object.freeze({ sharedProp: 1.337, data: [1,2,3] });
    var child = Object.create(frozenProto);
    child.ownProp = 99;

    info('frozenProto.sharedProp=' + frozenProto.sharedProp);
    info('child.sharedProp (herdado)=' + child.sharedProp);

    // Escrever sharedProp no child deve criar shadow property (NAOAO escrever em frozenProto)
    child.sharedProp = 9999;
    info('Apos child.sharedProp = 9999:');
    info('  child.sharedProp=' + child.sharedProp);
    info('  frozenProto.sharedProp=' + frozenProto.sharedProp);

    if(frozenProto.sharedProp !== 1.337) {
      alerta('ESCRITA ATRAVESSOU FROZEN PROTO: frozenProto.sharedProp=' + frozenProto.sharedProp + ' — shadow property nao criada, proto mutado!');
    } else if(child.sharedProp !== 9999) {
      alerta('SHADOW PROPERTY NAO CRIADA: child.sharedProp=' + child.sharedProp + ' ainda lendo do proto frozen!');
    } else {
      ok('Shadow property criada corretamente: child.sharedProp=9999, proto=1.337');
    }

    // Congelar o child e tentar escrever via seu proto
    Object.freeze(child);
    info('child tambem frozen agora. Tentando escrever child.sharedProp=8888...');
    child.sharedProp = 8888;
    info('child.sharedProp apos tentativa: ' + child.sharedProp);
    if(child.sharedProp === 8888) {
      alerta('ESCRITA EM CHILD FROZEN FUNCIONOU: child.sharedProp=' + child.sharedProp);
    }

    // Verificar integridade do array no proto frozen
    frozenProto.data.push(999); // Freeze nao congela objetos internos por padrao!
    info('frozenProto.data.push(999) → frozenProto.data=' + frozenProto.data);
    if(frozenProto.data.length > 3) {
      alerta('OBJETO INTERNO DO FROZEN NAO ESTA FROZEN: frozenProto.data foi mutado para ' + frozenProto.data.length + ' elementos — Object.freeze e shallow!');
    }

  } catch(e) {
    alerta('EXCECAO: ' + e.message);
  }
}

function runTest3() {
  log.textContent = '[TEST 27-C] Object.freeze chamado durante enumeracao de propriedades...\n';
  try {
    var obj = {};
    for(var i = 0; i < 50; i++) obj['prop_' + i] = i * 1.1;
    info('Objeto com 50 props criado');

    var frozeAt = -1;
    var enumOrder = [];

    for(var key in obj) {
      enumOrder.push(key);
      if(enumOrder.length === 25 && frozeAt === -1) {
        // Congelar durante enumeracao
        Object.freeze(obj);
        frozeAt = enumOrder.length;
        info('freeze() chamado na prop #25 durante for..in');
        forceGC();
      }
    }

    info('Total props enumeradas: ' + enumOrder.length);
    info('Freeze ocorreu na prop #' + frozeAt);
    info('Object.isFrozen(obj): ' + Object.isFrozen(obj));

    if(enumOrder.length !== 50) {
      alerta('ENUMERACAO INCOMPLETA apos freeze: apenas ' + enumOrder.length + '/50 propriedades foram enumeradas!');
    } else {
      ok('Todas 50 props enumeradas corretamente.');
    }

    // Tentar escrever apos freeze durante enum
    obj.prop_0 = 9999;
    info('Apos tentativa de escrita: obj.prop_0=' + obj.prop_0);
    if(obj.prop_0 !== 0) {
      alerta('ESCRITA APOS FREEZE-DURANTE-ENUM FUNCIONOU: prop_0=' + obj.prop_0);
    }

    // Adicionar nova prop apos freeze
    obj.new_prop = 'evil';
    info('obj.new_prop (tentativa pos-freeze): ' + obj.new_prop);
    if(obj.new_prop !== undefined) {
      alerta('NOVA PROP ADICIONADA A OBJETO FROZEN: new_prop=' + obj.new_prop);
    }

  } catch(e) {
    alerta('EXCECAO: ' + e.message);
  }
}
</script>
</body>
</html>
